package main

import (
	"context"
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// Input types for FTL operations
type FTLUpInput struct {
	ProjectPath string `json:"project_path" jsonschema:"description:Full path to the FTL project directory"`
	Watch       bool   `json:"watch,omitempty" jsonschema:"description:Run in watch mode,default:false"`
}

type GetLogsInput struct {
	ProjectPath string `json:"project_path" jsonschema:"description:Full path to the FTL project directory"`
	Since       int    `json:"since,omitempty" jsonschema:"description:Get logs since this line number (0 for all logs),default:0"`
}

type StopWatchInput struct {
	ProjectPath string `json:"project_path" jsonschema:"description:Full path to the FTL project directory"`
}

type StopRegularInput struct {
	ProjectPath string `json:"project_path" jsonschema:"description:Full path to the FTL project directory"`
}

type FTLBuildInput struct {
	ProjectPath string `json:"project_path" jsonschema:"description:Full path to the FTL project directory"`
	Clean       bool   `json:"clean,omitempty" jsonschema:"description:Clean build (rebuild all),default:false"`
}

type GetStatusInput struct {
	ProjectPath string `json:"project_path" jsonschema:"description:Full path to the FTL project directory"`
	Detailed    bool   `json:"detailed,omitempty" jsonschema:"description:Return detailed status for both regular and watch processes"`
}

type ProcessStatus struct {
	ProcessType string `json:"process_type"` // "watch", "regular", or "none"
	IsRunning   bool   `json:"is_running"`
	PID         int    `json:"pid"`
	Port        int    `json:"port"`
	ProjectPath string `json:"project_path"`
}

// Input types for FTL operations continue below...

// findAvailablePort finds an available port starting from the given port
// Always checks the current port first, then increments
func findAvailablePort(startPort int) (int, error) {
	for port := startPort; port < startPort+100; port++ {
		if isPortAvailable(port) {
			return port, nil
		}
	}
	return 0, fmt.Errorf("no available ports found in range %d-%d", startPort, startPort+99)
}

// isPortAvailable checks if a specific port is available
func isPortAvailable(port int) bool {
	// Test the exact address that FTL will try to bind to
	addr := fmt.Sprintf("127.0.0.1:%d", port)
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Port %d not available: %v\n", port, err)
		return false
	}
	listener.Close()
	fmt.Fprintf(os.Stderr, "Port %d is available\n", port)
	return true
}

// PID file management functions
func getPidFilePath(projectPath string) string {
	return filepath.Join(projectPath, ".ftl-watch.pid")
}

func getRegularPidFilePath(projectPath string) string {
	return filepath.Join(projectPath, ".ftl-regular.pid")
}

func getLogFilePath(projectPath string) string {
	return filepath.Join(projectPath, ".ftl-watch.log")
}

func getRegularLogFilePath(projectPath string) string {
	return filepath.Join(projectPath, ".ftl-regular.log")
}

func writePidFile(projectPath string, pid int, port int) error {
	pidFile := getPidFilePath(projectPath)
	content := fmt.Sprintf("%d\n%d\n", pid, port)
	fmt.Fprintf(os.Stderr, "DEBUG: Writing PID file: %s with content: %s", pidFile, content)
	err := os.WriteFile(pidFile, []byte(content), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: Failed to write PID file: %v\n", err)
	} else {
		fmt.Fprintf(os.Stderr, "DEBUG: Successfully wrote PID file: %s\n", pidFile)
	}
	return err
}

func readPidFile(projectPath string) (int, int, error) {
	pidFile := getPidFilePath(projectPath)
	fmt.Fprintf(os.Stderr, "DEBUG: Attempting to read PID file: %s\n", pidFile)
	
	content, err := os.ReadFile(pidFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: Failed to read PID file: %v\n", err)
		return 0, 0, err
	}
	
	fmt.Fprintf(os.Stderr, "DEBUG: PID file content: %s\n", string(content))
	
	lines := strings.Split(strings.TrimSpace(string(content)), "\n")
	if len(lines) < 2 {
		fmt.Fprintf(os.Stderr, "DEBUG: Invalid PID file format - only %d lines\n", len(lines))
		return 0, 0, fmt.Errorf("invalid PID file format")
	}
	
	pid, err := strconv.Atoi(lines[0])
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: Invalid PID in file: %v\n", err)
		return 0, 0, fmt.Errorf("invalid PID: %v", err)
	}
	
	port, err := strconv.Atoi(lines[1])
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: Invalid port in file: %v\n", err)
		return 0, 0, fmt.Errorf("invalid port: %v", err)
	}
	
	fmt.Fprintf(os.Stderr, "DEBUG: Successfully read PID file - PID: %d, Port: %d\n", pid, port)
	return pid, port, nil
}

func removePidFile(projectPath string) {
	pidFile := getPidFilePath(projectPath)
	fmt.Fprintf(os.Stderr, "DEBUG: Removing PID file: %s\n", pidFile)
	err := os.Remove(pidFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: Failed to remove PID file: %v\n", err)
	} else {
		fmt.Fprintf(os.Stderr, "DEBUG: Successfully removed PID file: %s\n", pidFile)
	}
}

func removeRegularPidFile(projectPath string) {
	pidFile := getRegularPidFilePath(projectPath)
	fmt.Fprintf(os.Stderr, "DEBUG: Removing regular PID file: %s\n", pidFile)
	err := os.Remove(pidFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: Failed to remove regular PID file: %v\n", err)
	} else {
		fmt.Fprintf(os.Stderr, "DEBUG: Successfully removed regular PID file: %s\n", pidFile)
	}
}

// validateAndCleanupPidFile checks if a PID file exists and the process is running
// If the process is not running, it removes the stale PID file
// Returns (pid, port, isRunning) or (0, 0, false) if no valid process
func validateAndCleanupPidFile(pidFilePath string, projectPath string, processType string) (int, int, bool) {
	content, err := os.ReadFile(pidFilePath)
	if err != nil {
		return 0, 0, false
	}
	
	lines := strings.Split(strings.TrimSpace(string(content)), "\n")
	if len(lines) < 2 {
		fmt.Fprintf(os.Stderr, "DEBUG: validateAndCleanupPidFile - invalid %s PID file format: %s\n", processType, pidFilePath)
		os.Remove(pidFilePath) // Remove malformed PID file
		return 0, 0, false
	}
	
	pid, err := strconv.Atoi(lines[0])
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: validateAndCleanupPidFile - invalid PID in %s file: %s\n", processType, pidFilePath)
		os.Remove(pidFilePath) // Remove invalid PID file
		return 0, 0, false
	}
	
	port, err := strconv.Atoi(lines[1])
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: validateAndCleanupPidFile - invalid port in %s file: %s\n", processType, pidFilePath)
		os.Remove(pidFilePath) // Remove invalid PID file
		return 0, 0, false
	}
	
	if isProcessRunning(pid) {
		fmt.Fprintf(os.Stderr, "DEBUG: validateAndCleanupPidFile - %s process %d is running on port %d\n", processType, pid, port)
		return pid, port, true
	}
	
	// Process not running, clean up stale PID file
	fmt.Fprintf(os.Stderr, "DEBUG: validateAndCleanupPidFile - %s process %d not running, removing stale PID file: %s\n", processType, pid, pidFilePath)
	os.Remove(pidFilePath)
	return 0, 0, false
}

func isProcessRunning(pid int) bool {
	// Invalid PID
	if pid <= 0 {
		return false
	}
	
	// Send signal 0 to check if process exists
	process, err := os.FindProcess(pid)
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: isProcessRunning - FindProcess failed for PID %d: %v\n", pid, err)
		return false
	}
	
	// On Unix systems, signal 0 can be used to check if process exists
	err = process.Signal(syscall.Signal(0))
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: isProcessRunning - Signal check failed for PID %d: %v\n", pid, err)
		return false
	}
	
	fmt.Fprintf(os.Stderr, "DEBUG: isProcessRunning - PID %d is running\n", pid)
	return true
}

type WatchInfo struct {
	PID         int
	Port        int
	ProjectPath string
	IsRunning   bool
	StartTime   time.Time
}

// Tool handlers
func ftlUp(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[FTLUpInput]) (*mcp.CallToolResultFor[struct{}], error) {
	fmt.Fprintf(os.Stderr, "DEBUG: ftlUp function called\n")
	projectPath := params.Arguments.ProjectPath
	watch := params.Arguments.Watch

	// Log the incoming payload to stderr (like the Rust version)
	fmt.Fprintf(os.Stderr, "DEBUG: ftl_up received payload: project_path='%s', watch='%t'\n", projectPath, watch)

	// Check if project directory exists
	if _, err := os.Stat(projectPath); os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "Error: Project directory '%s' does not exist\n", projectPath)
		response := fmt.Sprintf("‚ùå Error: Project directory '%s' does not exist", projectPath)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	if watch {
		// Handle watch mode - long-lived process
		return startWatchMode(ctx, projectPath)
	} else {
		// Handle regular mode - run once and return
		return runRegularMode(ctx, projectPath)
	}
}

func startWatchMode(ctx context.Context, projectPath string) (*mcp.CallToolResultFor[struct{}], error) {
	fmt.Fprintf(os.Stderr, "DEBUG: startWatchMode called with project path: %s\n", projectPath)
	
	// Check if there's already a running watch process
	if pid, port, err := readPidFile(projectPath); err == nil {
		fmt.Fprintf(os.Stderr, "DEBUG: startWatchMode - found existing PID file with PID: %d, Port: %d\n", pid, port)
		if isProcessRunning(pid) {
			fmt.Fprintf(os.Stderr, "DEBUG: startWatchMode - process %d is still running\n", pid)
			response := fmt.Sprintf("‚ö†Ô∏è Watch process already running for project: %s (PID: %d, Port: %d)", projectPath, pid, port)
			return &mcp.CallToolResultFor[struct{}]{
				Content: []mcp.Content{&mcp.TextContent{Text: response}},
			}, nil
		} else {
			// Stale PID file, remove it
			fmt.Fprintf(os.Stderr, "DEBUG: startWatchMode - process %d is not running, removing stale PID file\n", pid)
			removePidFile(projectPath)
		}
	} else {
		fmt.Fprintf(os.Stderr, "DEBUG: startWatchMode - no existing PID file found: %v\n", err)
	}

	// Find an available port starting from 3000
	availablePort, err := findAvailablePort(3000)
	if err != nil {
		response := fmt.Sprintf("‚ùå Failed to find available port: %s", err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Create log file for capturing output
	logFile := getLogFilePath(projectPath)
	logWriter, err := os.Create(logFile)
	if err != nil {
		response := fmt.Sprintf("‚ùå Failed to create log file: %s", err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Create new watch process with available port
	portStr := strconv.Itoa(availablePort)
	cmd := exec.Command("ftl", "up", "--watch", "--port", portStr)
	cmd.Dir = projectPath
	cmd.Stdout = logWriter
	cmd.Stderr = logWriter
	
	// Log the command being executed
	fmt.Fprintf(os.Stderr, "Starting FTL command: ftl up --watch --port %s in directory %s\n", portStr, projectPath)

	// Start the command
	if err := cmd.Start(); err != nil {
		logWriter.Close()
		response := fmt.Sprintf("‚ùå Failed to start 'ftl up --watch': %s", err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	pid := cmd.Process.Pid
	fmt.Fprintf(os.Stderr, "FTL process started with PID: %d on port %d\n", pid, availablePort)

	// Write PID file
	if err := writePidFile(projectPath, pid, availablePort); err != nil {
		cmd.Process.Kill()
		logWriter.Close()
		response := fmt.Sprintf("‚ùå Failed to write PID file: %s", err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Monitor process in background and clean up when it exits
	go func() {
		cmd.Wait()
		logWriter.Close()
		removePidFile(projectPath)
		fmt.Fprintf(os.Stderr, "FTL watch process (PID: %d) has stopped\n", pid)
	}()

	response := fmt.Sprintf("üöÄ Started 'ftl up --watch' in project: %s (PID: %d, Port: %d)", projectPath, pid, availablePort)
	return &mcp.CallToolResultFor[struct{}]{
		Content: []mcp.Content{&mcp.TextContent{Text: response}},
	}, nil
}

func runRegularMode(ctx context.Context, projectPath string) (*mcp.CallToolResultFor[struct{}], error) {
	fmt.Fprintf(os.Stderr, "DEBUG: runRegularMode called with project path: %s\n", projectPath)
	
	// Check if there's already a running regular server process
	regularPidFile := getRegularPidFilePath(projectPath)
	fmt.Fprintf(os.Stderr, "DEBUG: runRegularMode - checking for existing PID file: %s\n", regularPidFile)
	
	if existingPid, existingPort, isRunning := validateAndCleanupPidFile(regularPidFile, projectPath, "regular"); isRunning {
		fmt.Fprintf(os.Stderr, "DEBUG: runRegularMode - process %d is still running on port %d\n", existingPid, existingPort)
		response := fmt.Sprintf("‚ö†Ô∏è Regular FTL server already running for project: %s (PID: %d, Port: %d)", projectPath, existingPid, existingPort)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Find an available port starting from 3000
	availablePort, err := findAvailablePort(3000)
	if err != nil {
		response := fmt.Sprintf("‚ùå Failed to find available port: %s", err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Create log file for capturing output
	regularLogFile := getRegularLogFilePath(projectPath)
	logWriter, err := os.Create(regularLogFile)
	if err != nil {
		response := fmt.Sprintf("‚ùå Failed to create log file: %s", err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Create new regular server process with available port
	portStr := strconv.Itoa(availablePort)
	cmd := exec.Command("ftl", "up", "--port", portStr)
	cmd.Dir = projectPath
	cmd.Stdout = logWriter
	cmd.Stderr = logWriter
	
	// Log the command being executed
	fmt.Fprintf(os.Stderr, "Starting FTL command: ftl up --port %s in directory %s\n", portStr, projectPath)

	// Start the command
	if err := cmd.Start(); err != nil {
		logWriter.Close()
		response := fmt.Sprintf("‚ùå Failed to start 'ftl up': %s", err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	pid := cmd.Process.Pid
	fmt.Fprintf(os.Stderr, "FTL regular process started with PID: %d on port %d\n", pid, availablePort)

	// Write PID file for regular mode
	pidContent := fmt.Sprintf("%d\n%d\n", pid, availablePort)
	fmt.Fprintf(os.Stderr, "DEBUG: runRegularMode - writing PID file %s with content: %s", regularPidFile, pidContent)
	if err := os.WriteFile(regularPidFile, []byte(pidContent), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: runRegularMode - failed to write PID file: %v\n", err)
		cmd.Process.Kill()
		logWriter.Close()
		response := fmt.Sprintf("‚ùå Failed to write PID file: %s", err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}
	fmt.Fprintf(os.Stderr, "DEBUG: runRegularMode - successfully wrote PID file: %s\n", regularPidFile)

	// Monitor process in background and clean up when it exits
	go func() {
		cmd.Wait()
		logWriter.Close()
		removeRegularPidFile(projectPath)
		fmt.Fprintf(os.Stderr, "FTL regular process (PID: %d) has stopped\n", pid)
	}()

	// Wait a moment for the server to start up, then read initial output
	time.Sleep(2 * time.Second)
	
	// Read the initial startup output from log file
	logContent, _ := os.ReadFile(regularLogFile)
	output := string(logContent)

	response := fmt.Sprintf("üöÄ Started 'ftl up' in project: %s (PID: %d, Port: %d)\n\nInitial output:\n%s", projectPath, pid, availablePort, output)
	return &mcp.CallToolResultFor[struct{}]{
		Content: []mcp.Content{&mcp.TextContent{Text: response}},
	}, nil
}

func getLogs(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[GetLogsInput]) (*mcp.CallToolResultFor[struct{}], error) {
	fmt.Fprintf(os.Stderr, "=== getLogs FUNCTION CALLED ===\n")
	since := params.Arguments.Since
	projectPath := params.Arguments.ProjectPath

	// Validate project path exists
	if _, err := os.Stat(projectPath); os.IsNotExist(err) {
		response := fmt.Sprintf("‚ùå Error: Project directory '%s' does not exist", projectPath)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}
	
	// Check for both watch and regular processes
	var pid, port int
	var logFile string
	var processType string
	var isRunning bool
	
	// First check for watch process
	if watchPid, watchPort, watchRunning := validateAndCleanupPidFile(getPidFilePath(projectPath), projectPath, "watch"); watchRunning {
		pid, port = watchPid, watchPort
		logFile = getLogFilePath(projectPath)
		processType = "watch"
		isRunning = true
	}
	
	// If no running watch process, check for regular process
	if !isRunning {
		if regularPid, regularPort, regularRunning := validateAndCleanupPidFile(getRegularPidFilePath(projectPath), projectPath, "regular"); regularRunning {
			pid, port = regularPid, regularPort
			logFile = getRegularLogFilePath(projectPath)
			processType = "regular"
			isRunning = true
		}
	}
	
	// If no processes found
	if !isRunning {
		response := "üìä No FTL processes found (neither watch nor regular)"
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Read log file
	content, err := os.ReadFile(logFile)
	if err != nil {
		response := fmt.Sprintf("üìä Project: %s, %s process running: %t (PID: %d, Port: %d), No logs available", 
			projectPath, processType, isRunning, pid, port)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	lines := strings.Split(string(content), "\n")
	totalLines := len(lines)

	if since >= totalLines {
		// No new logs
		response := fmt.Sprintf("üìä Project: %s, %s process running: %t (PID: %d, Port: %d), Total logs: %d, No new logs since line %d", 
			projectPath, processType, isRunning, pid, port, totalLines, since)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Get new logs since the specified line
	newLines := lines[since:]
	logText := strings.Join(newLines, "\n")

	response := fmt.Sprintf("üìä Project: %s, %s process running: %t (PID: %d, Port: %d), New logs (lines %d-%d):\n%s", 
		projectPath, processType, isRunning, pid, port, since, totalLines-1, logText)
	return &mcp.CallToolResultFor[struct{}]{
		Content: []mcp.Content{&mcp.TextContent{Text: response}},
	}, nil
}

func stopWatch(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[StopWatchInput]) (*mcp.CallToolResultFor[struct{}], error) {
	projectPath := params.Arguments.ProjectPath
	fmt.Fprintf(os.Stderr, "DEBUG: stopWatch called with project path: %s\n", projectPath)

	// Check if there's a running watch process
	pid, port, err := readPidFile(projectPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "DEBUG: stopWatch - readPidFile failed: %v\n", err)
		response := fmt.Sprintf("‚ö†Ô∏è No running watch process found for project: %s", projectPath)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	if !isProcessRunning(pid) {
		// Process is not running, clean up stale PID file
		removePidFile(projectPath)
		response := fmt.Sprintf("‚ö†Ô∏è Watch process (PID: %d) was not running for project: %s", pid, projectPath)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Kill the process
	process, err := os.FindProcess(pid)
	if err != nil {
		response := fmt.Sprintf("‚ùå Failed to find process %d: %v", pid, err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	if err := process.Kill(); err != nil {
		response := fmt.Sprintf("‚ùå Failed to kill process %d: %v", pid, err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Clean up PID file
	removePidFile(projectPath)

	response := fmt.Sprintf("üõë Stopped watch process for project: %s (PID: %d, Port: %d)", projectPath, pid, port)
	return &mcp.CallToolResultFor[struct{}]{
		Content: []mcp.Content{&mcp.TextContent{Text: response}},
	}, nil
}

func stopRegular(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[StopRegularInput]) (*mcp.CallToolResultFor[struct{}], error) {
	projectPath := params.Arguments.ProjectPath
	fmt.Fprintf(os.Stderr, "DEBUG: stopRegular called with project path: %s\n", projectPath)

	// Check if there's a running regular server process
	regularPidFile := getRegularPidFilePath(projectPath)
	fmt.Fprintf(os.Stderr, "DEBUG: stopRegular - looking for PID file: %s\n", regularPidFile)
	
	pid, port, isRunning := validateAndCleanupPidFile(regularPidFile, projectPath, "regular")
	if !isRunning {
		response := fmt.Sprintf("‚ö†Ô∏è No running regular FTL server found for project: %s", projectPath)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Kill the process
	process, err := os.FindProcess(pid)
	if err != nil {
		response := fmt.Sprintf("‚ùå Failed to find process %d: %v", pid, err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	if err := process.Kill(); err != nil {
		response := fmt.Sprintf("‚ùå Failed to kill process %d: %v", pid, err)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Clean up PID file
	removeRegularPidFile(projectPath)

	response := fmt.Sprintf("üõë Stopped regular FTL server for project: %s (PID: %d, Port: %d)", projectPath, pid, port)
	return &mcp.CallToolResultFor[struct{}]{
		Content: []mcp.Content{&mcp.TextContent{Text: response}},
	}, nil
}

func ftlBuild(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[FTLBuildInput]) (*mcp.CallToolResultFor[struct{}], error) {
	fmt.Fprintf(os.Stderr, "DEBUG: ftlBuild function called\n")
	projectPath := params.Arguments.ProjectPath
	clean := params.Arguments.Clean

	// Log the incoming payload to stderr
	fmt.Fprintf(os.Stderr, "DEBUG: ftl_build received payload: project_path='%s', clean='%t'\n", projectPath, clean)

	// Check if project directory exists
	if _, err := os.Stat(projectPath); os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "Error: Project directory '%s' does not exist\n", projectPath)
		response := fmt.Sprintf("‚ùå Error: Project directory '%s' does not exist", projectPath)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	// Build command arguments
	args := []string{"build"}
	if clean {
		args = append(args, "--clean")
	}

	fmt.Fprintf(os.Stderr, "DEBUG: Executing command: ftl %s in directory: %s\n", strings.Join(args, " "), projectPath)

	// Execute build command
	cmd := exec.Command("ftl", args...)
	cmd.Dir = projectPath
	
	output, err := cmd.CombinedOutput()
	outputStr := string(output)
	
	fmt.Fprintf(os.Stderr, "DEBUG: Command output: %s\n", outputStr)
	fmt.Fprintf(os.Stderr, "DEBUG: Command error: %v\n", err)
	
	if err != nil {
		response := fmt.Sprintf("‚ùå Build failed: %s\n\nOutput:\n%s", err, outputStr)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: response}},
		}, nil
	}

	response := fmt.Sprintf("‚úÖ Build completed successfully\n\nOutput:\n%s", outputStr)
	return &mcp.CallToolResultFor[struct{}]{
		Content: []mcp.Content{&mcp.TextContent{Text: response}},
	}, nil
}

func getStatus(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[GetStatusInput]) (*mcp.CallToolResultFor[struct{}], error) {
	projectPath := params.Arguments.ProjectPath
	detailed := params.Arguments.Detailed
	fmt.Fprintf(os.Stderr, "=== getStatus FUNCTION CALLED ===\n")
	fmt.Fprintf(os.Stderr, "DEBUG: getStatus called with project path: %s, detailed: %t\n", projectPath, detailed)
	
	// Validate project path exists
	if _, err := os.Stat(projectPath); os.IsNotExist(err) {
		statusJSON := `{"error": "Project directory does not exist", "project_path": "` + projectPath + `"}`
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: statusJSON}},
		}, nil
	}
	
	// Check both process types
	watchPid, watchPort, watchRunning := validateAndCleanupPidFile(getPidFilePath(projectPath), projectPath, "watch")
	regularPid, regularPort, regularRunning := validateAndCleanupPidFile(getRegularPidFilePath(projectPath), projectPath, "regular")
	
	if detailed {
		// Return detailed status for both process types
		statusJSON := fmt.Sprintf(`{
			"project_path": "%s",
			"regular": {
				"is_running": %t,
				"pid": %d,
				"port": %d
			},
			"watch": {
				"is_running": %t,
				"pid": %d,
				"port": %d
			}
		}`, projectPath, regularRunning, regularPid, regularPort, watchRunning, watchPid, watchPort)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: statusJSON}},
		}, nil
	}
	
	// Legacy single-process format (watch takes priority)
	if watchRunning {
		statusJSON := fmt.Sprintf(`{"process_type": "watch", "is_running": true, "pid": %d, "port": %d, "project_path": "%s"}`, watchPid, watchPort, projectPath)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: statusJSON}},
		}, nil
	}
	
	if regularRunning {
		statusJSON := fmt.Sprintf(`{"process_type": "regular", "is_running": true, "pid": %d, "port": %d, "project_path": "%s"}`, regularPid, regularPort, projectPath)
		return &mcp.CallToolResultFor[struct{}]{
			Content: []mcp.Content{&mcp.TextContent{Text: statusJSON}},
		}, nil
	}
	
	// No processes running
	statusJSON := fmt.Sprintf(`{"process_type": "none", "is_running": false, "pid": 0, "port": 0, "project_path": "%s"}`, projectPath)
	return &mcp.CallToolResultFor[struct{}]{
		Content: []mcp.Content{&mcp.TextContent{Text: statusJSON}},
	}, nil
}

func main() {
	fmt.Fprintf(os.Stderr, "DEBUG: Starting FTL MCP server\n")
	server := mcp.NewServer(&mcp.Implementation{
		Name:    "ftl-server",
		Version: "1.0.0",
	}, &mcp.ServerOptions{
		Instructions: "FTL server - handles ftl up operations in regular and watch modes",
	})

	// Add tools
	mcp.AddTool(server, &mcp.Tool{
		Name:        "ftl-server__up",
		Description: "Run ftl up in regular or watch mode",
	}, ftlUp)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "ftl-server__get_logs",
		Description: "Get logs from running watch process",
	}, getLogs)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "ftl-server__stop_watch",
		Description: "Stop a running watch process",
	}, stopWatch)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "ftl-server__stop_regular",
		Description: "Stop a running regular FTL server",
	}, stopRegular)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "ftl-server__build",
		Description: "Run ftl build command",
	}, ftlBuild)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "ftl-server__get_status",
		Description: "Get current status of FTL processes",
	}, getStatus)

	// Run with stdio transport
	server.Run(context.Background(), mcp.NewStdioTransport())
}