// Test org mode policy - security validation

use crate::policy_test_helpers::*;
use crate::test_setup::setup_default_test_config;
use spin_test_sdk::{bindings::wasi::http, spin_test};

#[spin_test]
fn test_org_mode_blocks_users_from_other_orgs() {
    setup_default_test_config();

    // EXACT policy generated by platform.Process() for org mode
    let policy = r#"package mcp.authorization

# Organization mode: Members and machines can access
default allow = false

# Allow org members (user tokens without org_id claim)
allow if {
	not input.token.claims.org_id
	input.token.sub == data.members[_]
}

# Allow machines from the same org (machine tokens with org_id claim)
allow if {
	input.token.claims.org_id
	input.token.claims.org_id == data.org_id
}
"#;

    // Policy data with specific org members
    let policy_data = r#"{
        "members": [
            "user_01K26ABNQZ97VV1TZ5HWP4PN55",
            "user_01K1J1CWJ81Z9SVQNBZFCC7Z55"
        ],
        "org_id": "org_01K1HVQRBFJ9J7D12G3TPQTX55"
    }"#;

    let (private_key, _public_key) = setup_test_jwt_validation();

    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy", policy);
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set(
        "mcp_policy_data",
        policy_data,
    );

    // Test 1: Org member should have access
    let member_token = create_policy_test_token_with_key(
        &private_key,
        "user_01K26ABNQZ97VV1TZ5HWP4PN55", // This user IS in members list
        vec![],
        vec![], // No org_id claim for user tokens
    );

    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", member_token).as_bytes(),
        )
        .unwrap();

    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    assert_eq!(response.status(), 200, "Org member should have access");

    // Test 2: User from DIFFERENT org should be DENIED
    let other_org_user_token = create_policy_test_token_with_key(
        &private_key,
        "user_99DIFFERENT_ORG_USER", // This user is NOT in members list
        vec![],
        vec![], // No org_id claim for user tokens
    );

    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", other_org_user_token).as_bytes(),
        )
        .unwrap();

    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    let status = response.status();

    // Debug: Print response if not 401
    if status != 401 {
        let body = response.body().unwrap_or_default();
        let body_str = String::from_utf8_lossy(&body);
        eprintln!(
            "SECURITY ISSUE: User from different org got status: {}",
            status
        );
        eprintln!("Response body: {}", body_str);
    }

    assert_eq!(status, 401, "User from different org should be DENIED");

    // Test 3: Machine from correct org should have access
    let machine_token = create_policy_test_token_with_key(
        &private_key,
        "client_01K29ET9RWPE8WS2J9RFFW5F55",
        vec![],
        vec![
            (
                "org_id",
                serde_json::json!("org_01K1HVQRBFJ9J7D12G3TPQTX55"),
            ), // Matching org_id
        ],
    );

    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", machine_token).as_bytes(),
        )
        .unwrap();

    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    assert_eq!(
        response.status(),
        200,
        "Machine from same org should have access"
    );

    // Test 4: Machine from DIFFERENT org should be DENIED
    let wrong_org_machine_token = create_policy_test_token_with_key(
        &private_key,
        "client_99DIFFERENT_MACHINE",
        vec![],
        vec![
            ("org_id", serde_json::json!("org_99DIFFERENT_ORG")), // Different org_id
        ],
    );

    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", wrong_org_machine_token).as_bytes(),
        )
        .unwrap();

    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    assert_eq!(
        response.status(),
        401,
        "Machine from different org should be DENIED"
    );
}

#[spin_test]
fn test_org_mode_empty_members_list() {
    setup_default_test_config();

    let policy = r#"package mcp.authorization

# Organization mode: Members and machines can access
default allow = false

# Allow org members (user tokens without org_id claim)
allow if {
	not input.token.claims.org_id
	input.token.sub == data.members[_]
}

# Allow machines from the same org (machine tokens with org_id claim)
allow if {
	input.token.claims.org_id
	input.token.claims.org_id == data.org_id
}
"#;

    // Empty members list - only machines should have access
    let policy_data = r#"{
        "members": [],
        "org_id": "org_01K1HVQRBFJ9J7D12G3TPQTX55"
    }"#;

    let (private_key, _public_key) = setup_test_jwt_validation();

    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy", policy);
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set(
        "mcp_policy_data",
        policy_data,
    );

    // User should be denied (empty members list)
    let user_token = create_policy_test_token_with_key(
        &private_key,
        "user_01K26ABNQZ97VV1TZ5HWP4PN55",
        vec![],
        vec![],
    );

    let headers = http::types::Headers::new();
    headers
        .append("authorization", format!("Bearer {}", user_token).as_bytes())
        .unwrap();

    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    assert_eq!(
        response.status(),
        401,
        "User should be denied with empty members list"
    );

    // Machine from correct org should still have access
    let machine_token = create_policy_test_token_with_key(
        &private_key,
        "client_01K29ET9RWPE8WS2J9RFFW5F55",
        vec![],
        vec![(
            "org_id",
            serde_json::json!("org_01K1HVQRBFJ9J7D12G3TPQTX55"),
        )],
    );

    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", machine_token).as_bytes(),
        )
        .unwrap();

    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    assert_eq!(
        response.status(),
        200,
        "Machine should have access even with empty members list"
    );
}
