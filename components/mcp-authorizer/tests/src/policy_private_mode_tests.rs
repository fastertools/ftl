// Test private mode policy - exactly as deployed by platform processor

use crate::policy_test_helpers::*;
use crate::test_setup::setup_default_test_config;
use spin_test_sdk::{bindings::wasi::http, spin_test};

#[spin_test]
fn test_platform_generated_private_mode_policy() {
    setup_default_test_config();

    // EXACT policy generated by platform.Process() for private mode
    // Updated with 'if' keyword for Regorus compatibility
    let policy = r#"package mcp.authorization

# Private mode: Only the owner can access
default allow = false

allow if {
	input.token.sub == data.owner
}
"#;

    // EXACT policy data from deployment logs
    let policy_data = r#"{"owner":"user_01JZM9BA77AEBQ1DTDPP2PMHG6"}"#;

    let (private_key, _public_key) = setup_test_jwt_validation();
    
    // Set the exact policy and data as seen in deployment
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy", policy);
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy_data", policy_data);

    // Test 1: Owner should have access
    let owner_token = create_policy_test_token_with_key(
        &private_key,
        "user_01JZM9BA77AEBQ1DTDPP2PMHG6", // Exact user ID from deployment
        vec![],
        vec![],
    );

    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", owner_token).as_bytes(),
        )
        .unwrap();
    headers.append("content-type", b"application/json").unwrap();
    
    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Post).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();
    
    // MCP tools/list request body
    let body = r#"{"jsonrpc":"2.0","method":"tools/list","id":1}"#;
    let body_stream = request.body().unwrap();
    body_stream.write_bytes(body.as_bytes());

    let response = spin_test_sdk::perform_request(request);
    let status = response.status();
    
    // Debug: Print response if not 200
    if status != 200 {
        let body = response.body().unwrap_or_default();
        let body_str = String::from_utf8_lossy(&body);
        eprintln!("Response status: {}", status);
        eprintln!("Response body: {}", body_str);
    }
    
    assert_eq!(
        status,
        200,
        "Owner user_01JZM9BA77AEBQ1DTDPP2PMHG6 should have access"
    );

    // Test 2: Different user should be denied
    let other_token = create_policy_test_token_with_key(
        &private_key,
        "user_01DIFFERENT_USER_ID",
        vec![],
        vec![],
    );

    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", other_token).as_bytes(),
        )
        .unwrap();
    headers.append("content-type", b"application/json").unwrap();
    
    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Post).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();
    
    let body_stream = request.body().unwrap();
    body_stream.write_bytes(body.as_bytes());

    let response = spin_test_sdk::perform_request(request);
    assert_eq!(
        response.status(),
        401,
        "Non-owner should be denied access"
    );
}

#[spin_test]
fn test_private_mode_with_workos_jwt_format() {
    setup_default_test_config();

    // Policy as generated by platform
    let policy = r#"package mcp.authorization

# Private mode: Only the owner can access
default allow = false

allow if {
	input.token.sub == data.owner
}
"#;

    let policy_data = r#"{"owner":"user_01JZM9BA77AEBQ1DTDPP2PMHG6"}"#;

    let (private_key, _public_key) = setup_test_jwt_validation();
    
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy", policy);
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy_data", policy_data);

    // Create token with WorkOS-style claims (no org_id for user tokens)
    let owner_token = create_policy_test_token_with_key(
        &private_key,
        "user_01JZM9BA77AEBQ1DTDPP2PMHG6",
        vec![],
        vec![
            ("email", serde_json::json!("user@example.com")),
            ("sid", serde_json::json!("session_01ABC123")),
            // Note: No org_id claim for WorkOS user tokens
        ],
    );

    // Test with GET request (no body)
    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", owner_token).as_bytes(),
        )
        .unwrap();
    
    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    assert_eq!(
        response.status(),
        200,
        "Owner should have access with WorkOS-style token"
    );
}

#[spin_test]
fn test_private_mode_policy_data_parsing() {
    setup_default_test_config();

    let policy = r#"package mcp.authorization

default allow = false

allow if {
	input.token.sub == data.owner
}
"#;

    // Test with different policy_data formats
    let test_cases = vec![
        (
            r#"{"owner":"user_01JZM9BA77AEBQ1DTDPP2PMHG6"}"#,
            "user_01JZM9BA77AEBQ1DTDPP2PMHG6",
            true,
        ),
        (
            r#"{"owner":"user_01JZM9BA77AEBQ1DTDPP2PMHG6"}"#,
            "user_DIFFERENT",
            false,
        ),
    ];

    let (private_key, _public_key) = setup_test_jwt_validation();
    
    for (policy_data, sub, should_allow) in test_cases {
        spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy", policy);
        spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy_data", policy_data);

        let token = create_policy_test_token_with_key(&private_key, sub, vec![], vec![]);

        let headers = http::types::Headers::new();
        headers
            .append("authorization", format!("Bearer {}", token).as_bytes())
            .unwrap();
        
        let request = http::types::OutgoingRequest::new(headers);
        request.set_method(&http::types::Method::Get).unwrap();
        request.set_path_with_query(Some("/mcp")).unwrap();

        let response = spin_test_sdk::perform_request(request);
        let expected_status = if should_allow { 200 } else { 401 };
        
        assert_eq!(
            response.status(),
            expected_status,
            "User {} should {} have access with policy_data: {}",
            sub,
            if should_allow { "" } else { "not" },
            policy_data
        );
    }
}

#[spin_test]
fn test_private_mode_malformed_policy_data() {
    setup_default_test_config();

    let policy = r#"package mcp.authorization

default allow = false

allow if {
	input.token.sub == data.owner
}
"#;

    let (private_key, _public_key) = setup_test_jwt_validation();
    
    // Test with malformed JSON in policy_data
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy", policy);
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy_data", "not valid json");

    let token = create_policy_test_token_with_key(
        &private_key,
        "user_01JZM9BA77AEBQ1DTDPP2PMHG6",
        vec![],
        vec![],
    );

    let headers = http::types::Headers::new();
    headers
        .append("authorization", format!("Bearer {}", token).as_bytes())
        .unwrap();
    
    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    
    // Should return 500 for configuration error
    assert_eq!(
        response.status(),
        500,
        "Malformed policy_data should cause configuration error"
    );
}

#[spin_test]
fn test_private_mode_missing_policy_data() {
    setup_default_test_config();

    let policy = r#"package mcp.authorization

default allow = false

allow if {
	input.token.sub == data.owner
}
"#;

    let (private_key, _public_key) = setup_test_jwt_validation();
    
    // Set policy but no policy_data (data.owner will be undefined)
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy", policy);
    // Not setting mcp_policy_data

    let token = create_policy_test_token_with_key(
        &private_key,
        "user_01JZM9BA77AEBQ1DTDPP2PMHG6",
        vec![],
        vec![],
    );

    let headers = http::types::Headers::new();
    headers
        .append("authorization", format!("Bearer {}", token).as_bytes())
        .unwrap();
    
    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Get).unwrap();
    request.set_path_with_query(Some("/mcp")).unwrap();

    let response = spin_test_sdk::perform_request(request);
    
    // Should deny access since data.owner is undefined
    assert_eq!(
        response.status(),
        401,
        "Missing policy_data should deny access (data.owner undefined)"
    );
}

#[spin_test]
fn test_private_mode_with_mcp_tool_call() {
    setup_default_test_config();

    let policy = r#"package mcp.authorization

# Private mode: Only the owner can access
default allow = false

allow if {
	input.token.sub == data.owner
}
"#;

    let policy_data = r#"{"owner":"user_01JZM9BA77AEBQ1DTDPP2PMHG6"}"#;

    let (private_key, _public_key) = setup_test_jwt_validation();
    
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy", policy);
    spin_test_sdk::bindings::fermyon::spin_test_virt::variables::set("mcp_policy_data", policy_data);

    // Owner making a tool call
    let owner_token = create_policy_test_token_with_key(
        &private_key,
        "user_01JZM9BA77AEBQ1DTDPP2PMHG6",
        vec![],
        vec![],
    );

    // Test with actual MCP tool call
    let body = r#"{
        "jsonrpc":"2.0",
        "id":1,
        "method":"tools/call",
        "params":{
            "name":"read_data",
            "arguments":{"file":"test.txt"}
        }
    }"#;

    let headers = http::types::Headers::new();
    headers
        .append(
            "authorization",
            format!("Bearer {}", owner_token).as_bytes(),
        )
        .unwrap();
    headers.append("content-type", b"application/json").unwrap();
    
    let request = http::types::OutgoingRequest::new(headers);
    request.set_method(&http::types::Method::Post).unwrap();
    request.set_path_with_query(Some("/mcp/x/graph")).unwrap();
    
    let body_stream = request.body().unwrap();
    body_stream.write_bytes(body.as_bytes());

    let response = spin_test_sdk::perform_request(request);
    let status = response.status();
    
    // Debug: Print response if not 200
    if status != 200 {
        let body = response.body().unwrap_or_default();
        let body_str = String::from_utf8_lossy(&body);
        eprintln!("Tool call response status: {}", status);
        eprintln!("Tool call response body: {}", body_str);
    }
    
    assert_eq!(
        status,
        200,
        "Owner should be able to call tools"
    );
}