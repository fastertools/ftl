//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"text/template"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	"cuelang.org/go/cue/load"
)

// Constants represents the structure we export from CUE
type Constants struct {
	Languages        []string            `json:"languages"`
	Formats          []string            `json:"formats"`
	OutputFields     []string            `json:"output_fields"`
	MCPTools         []string            `json:"mcp_tools"`
	WatchPatterns    map[string][]string `json:"watch_patterns"`
	ConfigPriorities map[string][]string `json:"config_priorities"`
}

const goTemplate = `// Code generated by go run generate.go; DO NOT EDIT.

package constants

// ValidLanguages lists all supported FTL project languages
var ValidLanguages = []string{
{{- range .Languages}}
	"{{.}}",
{{- end}}
}

// ValidFormats lists all supported configuration file formats
var ValidFormats = []string{
{{- range .Formats}}
	"{{.}}",
{{- end}}
}

// OrderedKeys defines the column order for CLI table output
var OrderedKeys = []string{
{{- range .OutputFields}}
	"{{.}}",
{{- end}}
}

// MCPCoreTools lists the core MCP tools provided by FTL
var MCPCoreTools = []string{
{{- range .MCPTools}}
	"{{.}}",
{{- end}}
}

// WatchPatterns maps languages to their file watch patterns
var WatchPatterns = map[string][]string{
{{- range $lang, $patterns := .WatchPatterns}}
	"{{$lang}}": {
	{{- range $patterns}}
		"{{.}}",
	{{- end}}
	},
{{- end}}
}

// ConfigPriorities defines config file search priorities by context
var ConfigPriorities = map[string][]string{
{{- range $context, $files := .ConfigPriorities}}
	"{{$context}}": {
	{{- range $files}}
		"{{.}}",
	{{- end}}
	},
{{- end}}
}
`

func main() {
	// Load the CUE package
	buildInstances := load.Instances([]string{"../../ui"}, nil)
	if len(buildInstances) == 0 {
		log.Fatal("No CUE instances found")
	}

	ctx := cuecontext.New()
	val := ctx.BuildInstance(buildInstances[0])
	if err := val.Err(); err != nil {
		log.Fatalf("Error building CUE instance: %v", err)
	}

	// Extract constants
	constantsVal := val.LookupPath(cue.ParsePath("#Constants"))
	if !constantsVal.Exists() {
		log.Fatal("#Constants not found in CUE file")
	}

	var constants Constants
	if err := constantsVal.Decode(&constants); err != nil {
		log.Fatalf("Error decoding constants: %v", err)
	}

	// Generate Go code
	tmpl, err := template.New("constants").Parse(goTemplate)
	if err != nil {
		log.Fatalf("Error parsing template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, constants); err != nil {
		log.Fatalf("Error executing template: %v", err)
	}

	// Write to file
	if err := os.WriteFile("constants_gen.go", buf.Bytes(), 0644); err != nil {
		log.Fatalf("Error writing file: %v", err)
	}

	fmt.Println("Generated constants_gen.go")
}