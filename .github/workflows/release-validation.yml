name: Release Validation

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '.release-please-manifest.json'
      - 'release-please-config.json'
      - '**/Cargo.toml'
      - '**/package.json'
      - '**/pyproject.toml'
      - '.release-please-manifest.json'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run validation in dry-run mode'
        required: false
        default: true
        type: boolean

permissions:
  contents: read
  pull-requests: write

jobs:
  validate-configuration:
    name: Validate Release Configuration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate release-please config
        run: |
          # Validate JSON syntax
          jq empty release-please-config.json || {
            echo "‚ùå release-please-config.json is not valid JSON"
            exit 1
          }
          jq empty .release-please-manifest.json || {
            echo "‚ùå .release-please-manifest.json is not valid JSON"
            exit 1
          }
          
          echo "‚úÖ JSON configuration files are valid"

      - name: Validate configuration schema
        run: |
          # Download release-please schema
          curl -fsSL https://raw.githubusercontent.com/googleapis/release-please/main/schemas/config.json -o schema.json
          
          # Install ajv-cli for JSON schema validation
          npm install -g ajv-cli ajv-formats
          
          # Validate against schema
          ajv validate -s schema.json -d release-please-config.json --strict=false || {
            echo "‚ö†Ô∏è  Configuration may not match schema (non-critical)"
          }

      - name: Check package paths exist
        run: |
          # Extract all package paths from config
          PACKAGES=$(jq -r '.packages | keys[]' release-please-config.json)
          
          FAILED=false
          for package in $PACKAGES; do
            if [[ "$package" == "." ]]; then
              echo "‚úÖ Root package configured"
              continue
            fi
            
            if [[ -d "$package" ]]; then
              echo "‚úÖ Package path exists: $package"
            else
              echo "‚ùå Package path does not exist: $package"
              FAILED=true
            fi
          done
          
          if [ "$FAILED" = true ]; then
            echo "Some package paths are invalid"
            exit 1
          fi

  validate-versions:
    name: Validate Version Consistency
    runs-on: ubuntu-latest
    # Skip version validation for release PRs as versions will be different
    if: "${{ !contains(github.event.pull_request.labels.*.name, 'autorelease: pending') }}"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup languages
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Setup Rust
        uses: ./.github/actions/setup-rust

      - name: Validate manifest versions
        run: |
          echo "Checking version consistency across all files..."
          
          # Check if this is a release PR
          IS_RELEASE_PR=false
          if [[ "${{ github.event.pull_request.labels.*.name }}" == *"autorelease: pending"* ]]; then
            IS_RELEASE_PR=true
            echo "‚ÑπÔ∏è  Release PR detected - scaffold versions may lag behind"
          fi
          
          # Load manifest versions
          MANIFEST_VERSIONS=$(cat .release-please-manifest.json)
          
          # Validate CLI version
          CLI_MANIFEST=$(echo "$MANIFEST_VERSIONS" | jq -r '."cmd/ftl"')
          CLI_SCAFFOLD=$(jq -r '."cmd/ftl"' .release-please-manifest.json)
          
          if [[ "$CLI_MANIFEST" != "$CLI_SCAFFOLD" ]]; then
            if [[ "$IS_RELEASE_PR" == "true" ]]; then
              echo "‚ö†Ô∏è  CLI version mismatch (expected for release PR):"
              echo "   Manifest: $CLI_MANIFEST"
              echo "   Scaffold: $CLI_SCAFFOLD"
              echo "   Note: Scaffold versions will be updated post-release"
            else
              echo "‚ùå CLI version mismatch:"
              echo "   Manifest: $CLI_MANIFEST"
              echo "   Scaffold: $CLI_SCAFFOLD"
              exit 1
            fi
          else
            echo "‚úÖ CLI version consistent: $CLI_MANIFEST"
          fi
          
          # Validate SDK versions
          # Note: Rust SDK now uses "sdk" key instead of "sdk/rust"
          for entry in "go:sdk/go" "python:sdk/python" "typescript:sdk/typescript"; do
            IFS=':' read -r name path <<< "$entry"
            SDK_MANIFEST=$(echo "$MANIFEST_VERSIONS" | jq -r ".[\"$path\"]")
            SDK_SCAFFOLD=$(jq -r ".\"$path\"" .release-please-manifest.json)
            
            if [[ "$SDK_MANIFEST" != "$SDK_SCAFFOLD" ]]; then
              if [[ "$IS_RELEASE_PR" == "true" ]]; then
                echo "‚ö†Ô∏è  $name SDK version mismatch (expected for release PR):"
                echo "   Manifest: $SDK_MANIFEST"
                echo "   Scaffold: $SDK_SCAFFOLD"
              else
                echo "‚ùå $name SDK version mismatch:"
                echo "   Manifest: $SDK_MANIFEST"
                echo "   Scaffold: $SDK_SCAFFOLD"
                exit 1
              fi
            else
              echo "‚úÖ $name SDK version consistent: $SDK_MANIFEST"
            fi
          done
          
          # Check Rust SDK 
          RUST_SDK_MANIFEST=$(echo "$MANIFEST_VERSIONS" | jq -r '."sdk/rust"')
          RUST_SDK_SCAFFOLD=$(jq -r '."sdk/rust"' .release-please-manifest.json)
          
          if [[ "$RUST_SDK_MANIFEST" != "$RUST_SDK_SCAFFOLD" ]]; then
            if [[ "$IS_RELEASE_PR" == "true" ]]; then
              echo "‚ö†Ô∏è  Rust SDK version mismatch (expected for release PR):"
              echo "   Manifest: $RUST_SDK_MANIFEST"
              echo "   Scaffold: $RUST_SDK_SCAFFOLD"
            else
              echo "‚ùå Rust SDK version mismatch:"
              echo "   Manifest: $RUST_SDK_MANIFEST"
              echo "   Scaffold: $RUST_SDK_SCAFFOLD"
              exit 1
            fi
          else
            echo "‚úÖ Rust SDK version consistent: $RUST_SDK_MANIFEST"
          fi
          
          # Validate components version (now unified)
          COMPONENTS_MANIFEST=$(echo "$MANIFEST_VERSIONS" | jq -r '.components')
          COMPONENTS_SCAFFOLD=$(jq -r '.components' .release-please-manifest.json)
          
          if [[ "$COMPONENTS_MANIFEST" != "$COMPONENTS_SCAFFOLD" ]]; then
            if [[ "$IS_RELEASE_PR" == "true" ]]; then
              echo "‚ö†Ô∏è  Components version mismatch (expected for release PR):"
              echo "   Manifest: $COMPONENTS_MANIFEST"
              echo "   Scaffold: $COMPONENTS_SCAFFOLD"
            else
              echo "‚ùå Components version mismatch:"
              echo "   Manifest: $COMPONENTS_MANIFEST"
              echo "   Scaffold: $COMPONENTS_SCAFFOLD"
              exit 1
            fi
          else
            echo "‚úÖ Components version consistent: $COMPONENTS_MANIFEST"
          fi

      - name: Validate Rust workspace versions
        run: |
          # Check if this is a release PR
          IS_RELEASE_PR=false
          if [[ "${{ github.event.pull_request.labels.*.name }}" == *"autorelease: pending"* ]]; then
            IS_RELEASE_PR=true
            echo "‚ÑπÔ∏è  Release PR detected - workspace versions may be ahead of manifest"
          fi
          
          # Check Rust SDK workspace version
          MANIFEST_VERSION=$(jq -r '."sdk/rust"' .release-please-manifest.json)
          WORKSPACE_VERSION=$(grep '^\s*version = ' sdk/Cargo.toml | head -1 | cut -d'"' -f2)
          
          if [[ "$MANIFEST_VERSION" != "$WORKSPACE_VERSION" ]]; then
            if [[ "$IS_RELEASE_PR" == "true" ]]; then
              echo "‚ö†Ô∏è  Rust SDK workspace version difference (expected for release PR):"
              echo "   Manifest: $MANIFEST_VERSION"
              echo "   Workspace Cargo.toml: $WORKSPACE_VERSION"
            else
              echo "‚ùå Rust SDK workspace version mismatch:"
              echo "   Manifest: $MANIFEST_VERSION"
              echo "   Workspace Cargo.toml: $WORKSPACE_VERSION"
              exit 1
            fi
          else
            echo "‚úÖ Rust SDK workspace version consistent: $WORKSPACE_VERSION"
          fi
          
          # Check Components workspace version
          COMPONENTS_MANIFEST=$(jq -r '.components' .release-please-manifest.json)
          COMPONENTS_WORKSPACE=$(grep '^\s*version = ' components/Cargo.toml | head -1 | cut -d'"' -f2)
          
          if [[ "$COMPONENTS_MANIFEST" != "$COMPONENTS_WORKSPACE" ]]; then
            if [[ "$IS_RELEASE_PR" == "true" ]]; then
              echo "‚ö†Ô∏è  Components workspace version difference (expected for release PR):"
              echo "   Manifest: $COMPONENTS_MANIFEST"
              echo "   Workspace Cargo.toml: $COMPONENTS_WORKSPACE"
            else
              echo "‚ùå Components workspace version mismatch:"
              echo "   Manifest: $COMPONENTS_MANIFEST"
              echo "   Workspace Cargo.toml: $COMPONENTS_WORKSPACE"
              exit 1
            fi
          else
            echo "‚úÖ Components workspace version consistent: $COMPONENTS_WORKSPACE"
          fi

      - name: Validate Python package version
        run: |
          # Check if this is a release PR
          IS_RELEASE_PR=false
          if [[ "${{ github.event.pull_request.labels.*.name }}" == *"autorelease: pending"* ]]; then
            IS_RELEASE_PR=true
            echo "‚ÑπÔ∏è  Release PR detected - pyproject.toml version may be ahead of manifest"
          fi
          
          MANIFEST_VERSION=$(jq -r '."sdk/python"' .release-please-manifest.json)
          
          # Check pyproject.toml
          python -c "
          import tomllib
          with open('sdk/python/pyproject.toml', 'rb') as f:
              config = tomllib.load(f)
              version = config['project']['version']
              expected = '${MANIFEST_VERSION}'
              is_release_pr = '${IS_RELEASE_PR}'
              if version != expected:
                  if is_release_pr == 'true':
                      print(f'‚ö†Ô∏è  Python version difference (expected for release PR):')
                      print(f'   Manifest: {expected}')
                      print(f'   pyproject.toml: {version}')
                  else:
                      print(f'‚ùå Python version mismatch: {version} != {expected}')
                      exit(1)
              else:
                  print('‚úÖ Python package version consistent')
          " || python -c "
          import toml
          config = toml.load('sdk/python/pyproject.toml')
          version = config['project']['version']
          expected = '${MANIFEST_VERSION}'
          is_release_pr = '${IS_RELEASE_PR}'
          if version != expected:
              if is_release_pr == 'true':
                  print(f'‚ö†Ô∏è  Python version difference (expected for release PR):')
                  print(f'   Manifest: {expected}')
                  print(f'   pyproject.toml: {version}')
              else:
                  print(f'‚ùå Python version mismatch: {version} != {expected}')
                  exit(1)
          else:
              print('‚úÖ Python package version consistent')
          "

      - name: Validate TypeScript package version
        run: |
          # Check if this is a release PR
          IS_RELEASE_PR=false
          if [[ "${{ github.event.pull_request.labels.*.name }}" == *"autorelease: pending"* ]]; then
            IS_RELEASE_PR=true
            echo "‚ÑπÔ∏è  Release PR detected - package.json version may be ahead of manifest"
          fi
          
          MANIFEST_VERSION=$(jq -r '."sdk/typescript"' .release-please-manifest.json)
          PACKAGE_VERSION=$(node -p "require('./sdk/typescript/package.json').version")
          
          if [[ "$MANIFEST_VERSION" != "$PACKAGE_VERSION" ]]; then
            if [[ "$IS_RELEASE_PR" == "true" ]]; then
              echo "‚ö†Ô∏è  TypeScript version difference (expected for release PR):"
              echo "   Manifest: $MANIFEST_VERSION"
              echo "   package.json: $PACKAGE_VERSION"
            else
              echo "‚ùå TypeScript version mismatch:"
              echo "   Manifest: $MANIFEST_VERSION"
              echo "   package.json: $PACKAGE_VERSION"
              exit 1
            fi
          else
            echo "‚úÖ TypeScript package version consistent"
          fi

  validate-dependencies:
    name: Validate Cross-Package Dependencies
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check Rust SDK dependencies
        run: |
          # Ensure ftl-sdk depends on correct ftl-sdk-macros version
          SDK_VERSION=$(jq -r '."sdk/rust"' .release-please-manifest.json)
          MACROS_DEP=$(grep 'ftl-sdk-macros.*version' sdk/rust/Cargo.toml | cut -d'"' -f2)
          
          if [[ "$MACROS_DEP" != "=$SDK_VERSION" ]] && [[ "$MACROS_DEP" != "$SDK_VERSION" ]]; then
            echo "‚ö†Ô∏è  ftl-sdk should depend on ftl-sdk-macros version $SDK_VERSION"
            echo "   Current dependency: $MACROS_DEP"
          else
            echo "‚úÖ Rust SDK dependencies correct"
          fi

      - name: Check example dependencies
        run: |
          echo "Checking example project dependencies..."
          
          # Find all example ftl.toml files
          find examples -name "ftl.toml" -type f | while read -r ftl_file; do
            echo "Checking: $ftl_file"
            
            # Extract component dependencies
            if grep -q "rust-sdk" "$ftl_file"; then
              EXAMPLE_VERSION=$(grep "rust-sdk" "$ftl_file" | grep -oP 'v\K[0-9.]+' || echo "unknown")
              EXPECTED_VERSION=$(jq -r '."sdk/rust"' .release-please-manifest.json)
              
              if [[ "$EXAMPLE_VERSION" != "$EXPECTED_VERSION" ]] && [[ "$EXAMPLE_VERSION" != "unknown" ]]; then
                echo "  ‚ö†Ô∏è  Example uses rust-sdk v$EXAMPLE_VERSION, expected v$EXPECTED_VERSION"
              fi
            fi
          done

  test-release-simulation:
    name: Test Release Simulation
    runs-on: ubuntu-latest
    if: "${{ github.event_name == 'workflow_dispatch' || contains(github.event.pull_request.labels.*.name, 'test-release') }}"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Simulate release-please
        run: |
          echo "Simulating release-please behavior..."
          
          # Check what would be released based on recent commits
          git log --oneline -10 --pretty=format:"%s" | while read -r commit; do
            if [[ "$commit" =~ ^feat ]]; then
              echo "  üöÄ Feature commit would trigger minor version bump: $commit"
            elif [[ "$commit" =~ ^fix ]]; then
              echo "  üêõ Fix commit would trigger patch version bump: $commit"
            elif [[ "$commit" =~ ^[a-z]+! ]] || [[ "$commit" =~ "BREAKING CHANGE" ]]; then
              echo "  üí• Breaking change would trigger major version bump: $commit"
            else
              echo "  üìù Non-release commit: $commit"
            fi
          done

      - name: Check changelog generation
        run: |
          echo "Checking changelog generation readiness..."
          
          # Verify CHANGELOG files exist or will be created
          for changelog in CHANGELOG.md cmd/ftl/CHANGELOG.md sdk/*/CHANGELOG.md components/*/CHANGELOG.md; do
            if [[ -f "$changelog" ]]; then
              echo "‚úÖ Changelog exists: $changelog"
            else
              dir=$(dirname "$changelog")
              if [[ -d "$dir" ]]; then
                echo "üìù Changelog will be created: $changelog"
              fi
            fi
          done

  validate-wasm-constraints:
    name: Validate WASM Constraints
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for forbidden dependencies
        run: |
          echo "Checking for WASM-incompatible dependencies..."
          
          FORBIDDEN_DEPS=("tokio" "async-trait" "futures")
          FAILED=false
          
          # Check all Rust components
          find . -name "Cargo.toml" -path "*/components/*" -o -path "*/sdk/rust*" | while read -r cargo_file; do
            echo "Checking: $cargo_file"
            
            for dep in "${FORBIDDEN_DEPS[@]}"; do
              if grep -q "^$dep = " "$cargo_file" || grep -q "\"$dep\"" "$cargo_file"; then
                echo "‚ùå Found forbidden WASM dependency '$dep' in $cargo_file"
                FAILED=true
              fi
            done
          done
          
          if [ "$FAILED" = true ]; then
            echo ""
            echo "Found WASM-incompatible dependencies!"
            echo "See CLAUDE.md for WASM runtime constraints"
            exit 1
          else
            echo "‚úÖ No forbidden WASM dependencies found"
          fi

  create-validation-report:
    name: Create Validation Report
    needs: [validate-configuration, validate-versions, validate-dependencies, validate-wasm-constraints]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Generate app token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Create validation summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const results = {
              configuration: '${{ needs.validate-configuration.result }}',
              versions: '${{ needs.validate-versions.result }}',
              dependencies: '${{ needs.validate-dependencies.result }}',
              wasm: '${{ needs.validate-wasm-constraints.result }}'
            };
            
            // Check if this is a release PR
            const isReleasePR = context.payload.pull_request?.labels?.some(
              label => label.name === 'autorelease: pending'
            ) || false;
            
            let allPassed = true;
            let summary = '## Release Validation Report\n\n';
            summary += '| Check | Status | Description |\n';
            summary += '|-------|--------|-------------|\n';
            
            const descriptions = {
              configuration: 'Release configuration files valid',
              versions: 'Version consistency across all files',
              dependencies: 'Cross-package dependency alignment',
              wasm: 'WASM runtime constraint compliance'
            };
            
            for (const [check, result] of Object.entries(results)) {
              const icon = result === 'success' ? '‚úÖ' : result === 'skipped' ? '‚è≠Ô∏è' : '‚ùå';
              const status = result === 'success' ? 'Passed' : result === 'skipped' ? 'Skipped' : 'Failed';
              summary += `| ${icon} ${check} | ${status} | ${descriptions[check]} |\n`;
              
              if (result !== 'success' && result !== 'skipped') {
                allPassed = false;
              }
            }
            
            summary += '\n';
            
            if (isReleasePR && results.versions === 'skipped') {
              summary += '### ‚ÑπÔ∏è Release PR Validation\n\n';
              summary += 'Version consistency checks are skipped for release PRs as the versions are being updated.\n';
              summary += 'This is expected behavior.\n';
            } else if (allPassed) {
              summary += '### ‚úÖ All validation checks passed\n\n';
              summary += 'The release configuration is valid and ready for use.\n';
            } else {
              summary += '### ‚ùå Validation failed\n\n';
              summary += 'Please fix the issues identified above before proceeding with releases.\n';
            }
            
            // Add recommendations
            summary += '\n### Recommendations\n\n';
            summary += '- Ensure all version files are synchronized\n';
            summary += '- Verify conventional commit messages are being used\n';
            summary += '- Check that all package paths in release-please-config.json are correct\n';
            summary += '- Review WASM dependencies for compatibility\n';
            
            await core.summary.addRaw(summary).write();
            
            // Comment on PR if this is a PR event
            if (context.eventName === 'pull_request') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
            }
            
            // Fail the workflow if validation failed (except for release PRs with skipped version checks)
            if (!allPassed && !(isReleasePR && results.versions === 'skipped')) {
              core.setFailed('Release validation failed');
            }