name: Prepare Release

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Component to release'
        required: true
        type: choice
        options:
          - cli
          - sdk-rust
          - sdk-typescript
          - mcp-authorizer
          - mcp-gateway
      version_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: 'Custom version (overrides version_type)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write  # Required for creating labels

jobs:
  prepare:
    name: Prepare Release PR
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT || github.token }}
          fetch-depth: 0
      
      - name: Setup Git
        uses: ./.github/actions/setup-git
        with:
          token: ${{ secrets.PAT || github.token }}
      
      - name: Setup Node.js
        if: inputs.component == 'sdk-typescript'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup Rust
        if: inputs.component != 'sdk-typescript'
        uses: dtolnay/rust-toolchain@stable
      
      - name: Determine version
        id: version
        run: |
          COMPONENT="${{ inputs.component }}"
          VERSION_TYPE="${{ inputs.version_type }}"
          CUSTOM_VERSION="${{ inputs.custom_version }}"
          
          # Function to bump version
          bump_version() {
            local current=$1
            local type=$2
            
            IFS='.' read -r major minor patch <<< "$current"
            
            case "$type" in
              major)
                echo "$((major + 1)).0.0"
                ;;
              minor)
                echo "$major.$((minor + 1)).0"
                ;;
              patch)
                echo "$major.$minor.$((patch + 1))"
                ;;
            esac
          }
          
          # Get current version based on component
          case "$COMPONENT" in
            cli)
              CURRENT_VERSION=$(grep '^version' cli/Cargo.toml | head -1 | cut -d'"' -f2)
              ;;
            sdk-rust)
              CURRENT_VERSION=$(grep '^version' sdk/rust/Cargo.toml | head -1 | cut -d'"' -f2)
              ;;
            sdk-typescript)
              CURRENT_VERSION=$(node -p "require('./sdk/typescript/package.json').version")
              ;;
            mcp-authorizer|mcp-gateway)
              CURRENT_VERSION=$(grep '^version' "components/${COMPONENT}/Cargo.toml" | head -1 | cut -d'"' -f2)
              ;;
          esac
          
          # Determine new version
          if [ -n "$CUSTOM_VERSION" ]; then
            NEW_VERSION="$CUSTOM_VERSION"
          else
            NEW_VERSION=$(bump_version "$CURRENT_VERSION" "$VERSION_TYPE")
          fi
          
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Component: $COMPONENT"
          echo "Current version: $CURRENT_VERSION"
          echo "New version: $NEW_VERSION"
      
      - name: Create release branch
        run: |
          BRANCH="release/${{ inputs.component }}-v${{ steps.version.outputs.new }}"
          
          # Check if branch exists locally or remotely
          if git show-ref --verify --quiet "refs/heads/$BRANCH"; then
            echo "Branch $BRANCH exists locally, deleting it"
            git branch -D "$BRANCH"
          fi
          
          if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
            echo "Branch $BRANCH exists remotely, deleting it"
            git push origin --delete "$BRANCH" || true
          fi
          
          git checkout -b "$BRANCH"
          echo "RELEASE_BRANCH=$BRANCH" >> $GITHUB_ENV
      
      - name: Update version
        run: |
          COMPONENT="${{ inputs.component }}"
          NEW_VERSION="${{ steps.version.outputs.new }}"
          
          case "$COMPONENT" in
            cli)
              sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" cli/Cargo.toml
              # Update Cargo.lock - use workspace flag for consistency
              cargo update --workspace -p ftl-cli --precise "$NEW_VERSION" || cargo update --workspace -p ftl-cli
              ;;
            sdk-rust)
              sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" sdk/rust/Cargo.toml
              
              # Also update the macros crate version to match
              if [ -f sdk/rust-macros/Cargo.toml ]; then
                sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" sdk/rust-macros/Cargo.toml
                echo "Updated ftl-sdk-macros version to $NEW_VERSION"
                
                # Update the ftl-sdk dependency on macros to use the new version
                sed -i "s/ftl-sdk-macros = { version = \"[^\"]*\"/ftl-sdk-macros = { version = \"$NEW_VERSION\"/" sdk/rust/Cargo.toml
                echo "Updated ftl-sdk dependency on ftl-sdk-macros to $NEW_VERSION"
              fi
              
              # Update Cargo.lock - use workspace flag to avoid scanning subdirectories
              cargo update --workspace -p ftl-sdk --precise "$NEW_VERSION"
              cargo update --workspace -p ftl-sdk-macros --precise "$NEW_VERSION"
              
              # Note: We do NOT update templates here because the new version isn't published yet
              # Templates will be updated in a follow-up PR after the SDK is published
              ;;
            sdk-typescript)
              cd sdk/typescript
              npm version "$NEW_VERSION" --no-git-tag-version
              # Update package-lock.json
              npm install --package-lock-only
              cd ../..
              ;;
            mcp-authorizer|mcp-gateway)
              sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" "components/${COMPONENT}/Cargo.toml"
              # Update Cargo.lock - components use ftl- prefix in package names
              cargo update --workspace -p "ftl-${COMPONENT}" --precise "$NEW_VERSION" || cargo update --workspace -p "ftl-${COMPONENT}"
              
              # Update example ftl.toml files to use the new version
              echo "Updating component references in examples..."
              find examples -name "ftl.toml" -type f | while read -r file; do
                # Update gateway versions
                if [ "${COMPONENT}" = "mcp-gateway" ]; then
                  echo "Updating gateway version to ${NEW_VERSION} in $file"
                  sed -i "s/^version = \"[^\"]*\"/version = \"${NEW_VERSION}\"/" "$file"
                fi
                # Update authorizer versions
                if [ "${COMPONENT}" = "mcp-authorizer" ]; then
                  echo "Updating authorizer version to ${NEW_VERSION} in $file"
                  sed -i "s/^authorizer_version = \"[^\"]*\"/authorizer_version = \"${NEW_VERSION}\"/" "$file"
                fi
              done
              
              # Update template ftl.toml files to use the new version
              echo "Updating component references in templates..."
              find templates -name "ftl.toml" -type f | while read -r file; do
                # Update gateway versions
                if [ "${COMPONENT}" = "mcp-gateway" ]; then
                  echo "Updating gateway version to ${NEW_VERSION} in $file"
                  sed -i "s/^version = \"[^\"]*\"/version = \"${NEW_VERSION}\"/" "$file"
                fi
                # Update authorizer versions
                if [ "${COMPONENT}" = "mcp-authorizer" ]; then
                  echo "Updating authorizer version to ${NEW_VERSION} in $file"
                  sed -i "s/^authorizer_version = \"[^\"]*\"/authorizer_version = \"${NEW_VERSION}\"/" "$file"
                fi
              done
              ;;
          esac
      
      - name: Store release info
        id: release_info
        run: |
          COMPONENT="${{ inputs.component }}"
          NEW_VERSION="${{ steps.version.outputs.new }}"
          
          # Store component info for PR body
          echo "COMPONENT=$COMPONENT" >> $GITHUB_ENV
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
      
      - name: Commit changes
        run: |
          git add -A
          git commit -m "chore(${{ inputs.component }}): prepare release v${{ steps.version.outputs.new }}"
      
      - name: Push branch
        run: |
          git push origin "$RELEASE_BRANCH" --force-with-lease
      
      - name: Create or verify labels
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Create labels if they don't exist
          gh label create "release" --description "Release PR" --color "0E8A16" --force || true
          gh label create "automated" --description "Automated PR" --color "0052CC" --force || true
      
      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ secrets.PAT || github.token }}
        run: |
          COMPONENT="${{ inputs.component }}"
          NEW_VERSION="${{ steps.version.outputs.new }}"
          
          # Determine tag name
          case "$COMPONENT" in
            cli)
              TAG="cli-v${NEW_VERSION}"
              TITLE="release: CLI v${NEW_VERSION}"
              ;;
            sdk-rust)
              TAG="sdk-rust-v${NEW_VERSION}"
              TITLE="release: Rust SDK v${NEW_VERSION}"
              ;;
            sdk-typescript)
              TAG="sdk-typescript-v${NEW_VERSION}"
              TITLE="release: TypeScript SDK v${NEW_VERSION}"
              ;;
            mcp-authorizer|mcp-gateway)
              TAG="component-${COMPONENT}-v${NEW_VERSION}"
              TITLE="release: ${COMPONENT} v${NEW_VERSION}"
              ;;
          esac
          
          PR_BODY=$(cat <<EOF
          ## ${TITLE}
          
          This PR prepares the release of **${COMPONENT} v${NEW_VERSION}**.
          
          ### 📋 Checklist
          
          - [ ] Version bumped correctly
          - [ ] Changes are ready for release
          - [ ] All tests passing
          - [ ] Documentation updated if needed
          
          ### 📝 Release Notes
          
          GitHub will automatically generate release notes from the commits and pull requests included in this release.
          
          ### 🔄 Release Process
          
          1. Review and merge this PR
          2. The release will be tagged automatically
          3. The release workflow will then:
             - Build and publish artifacts
             - Create GitHub release
             - Publish to package registries
          
          ### ⚠️ Important
          
          - Ensure all CI checks pass before merging
          - Review the included changes
          - Verify version numbers are correct
          - **DO NOT** manually create the tag - it will be created automatically when merged
          EOF
          )
          
          gh pr create \
            --title "$TITLE" \
            --body "$PR_BODY" \
            --base main \
            --head "$RELEASE_BRANCH" \
            --label "release" \
            --label "automated"