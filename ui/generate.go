//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	"cuelang.org/go/cue/load"
)

func main() {
	// Load CUE files
	ctx := cuecontext.New()
	
	// Load the ui package
	cfg := &load.Config{
		Dir: ".",
	}
	instances := load.Instances([]string{"."}, cfg)
	if len(instances) != 1 {
		log.Fatal("expected exactly one instance")
	}
	
	inst := instances[0]
	if inst.Err != nil {
		log.Fatal(inst.Err)
	}
	
	// Build the CUE value
	value := ctx.BuildInstance(inst)
	if value.Err() != nil {
		log.Fatal(value.Err())
	}
	
	// Generate strings file
	if err := generateStringsFile(value); err != nil {
		log.Fatal(err)
	}
	
	// Generate styles file
	if err := generateStylesFile(value); err != nil {
		log.Fatal(err)
	}
	
	fmt.Println("âœ… Generated UI constants successfully")
}

func generateStringsFile(value cue.Value) error {
	var buf bytes.Buffer
	
	// Write header
	buf.WriteString(`// Code generated by ui/generate.go. DO NOT EDIT.

package ui

`)
	
	// Process ProcessNames
	if err := generateProcessNames(&buf, value); err != nil {
		return err
	}
	
	// Process StatusStrings
	if err := generateStatusStrings(&buf, value); err != nil {
		return err
	}
	
	// Process WebUI
	if err := generateWebUI(&buf, value); err != nil {
		return err
	}
	
	// Process CLI
	if err := generateCLI(&buf, value); err != nil {
		return err
	}
	
	// Process MCP
	if err := generateMCP(&buf, value); err != nil {
		return err
	}
	
	// Process Handlers
	if err := generateHandlers(&buf, value); err != nil {
		return err
	}
	
	// Format the Go code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format Go code: %w", err)
	}
	
	// Create output directory
	outputDir := filepath.Join("..", "internal", "ui")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}
	
	// Write the file
	outputFile := filepath.Join(outputDir, "strings_gen.go")
	return ioutil.WriteFile(outputFile, formatted, 0644)
}

func generateProcessNames(buf *bytes.Buffer, value cue.Value) error {
	buf.WriteString("// Process display names\n")
	buf.WriteString("const (\n")
	
	processNames := value.LookupPath(cue.ParsePath("#ProcessNames"))
	iter, err := processNames.Fields()
	if err != nil {
		return err
	}
	
	for iter.Next() {
		name := iter.Label()
		val, err := iter.Value().String()
		if err != nil {
			return err
		}
		constName := "ProcessName" + strings.Title(name)
		buf.WriteString(fmt.Sprintf("\t%s = %q\n", constName, val))
	}
	
	buf.WriteString(")\n\n")
	return nil
}

func generateStatusStrings(buf *bytes.Buffer, value cue.Value) error {
	buf.WriteString("// Status strings\n")
	buf.WriteString("const (\n")
	
	statusStrings := value.LookupPath(cue.ParsePath("#StatusStrings"))
	iter, err := statusStrings.Fields()
	if err != nil {
		return err
	}
	
	for iter.Next() {
		name := iter.Label()
		val, err := iter.Value().String()
		if err != nil {
			return err
		}
		constName := "Status" + strings.Title(name)
		buf.WriteString(fmt.Sprintf("\t%s = %q\n", constName, val))
	}
	
	buf.WriteString(")\n\n")
	return nil
}

func generateWebUI(buf *bytes.Buffer, value cue.Value) error {
	buf.WriteString("// WebUI contains all web interface strings\n")
	buf.WriteString("var WebUI = struct {\n")
	buf.WriteString("\tTitles   map[string]string\n")
	buf.WriteString("\tTabs     map[string]string\n")
	buf.WriteString("\tButtons  map[string]string\n")
	buf.WriteString("\tMessages map[string]string\n")
	buf.WriteString("\tForms    map[string]string\n")
	buf.WriteString("}{\n")
	
	webUI := value.LookupPath(cue.ParsePath("#WebUI"))
	
	// Generate each map
	categories := []string{"titles", "tabs", "buttons", "messages", "forms"}
	for _, cat := range categories {
		buf.WriteString(fmt.Sprintf("\t%s: map[string]string{\n", strings.Title(cat)))
		
		catValue := webUI.LookupPath(cue.ParsePath(cat))
		iter, err := catValue.Fields()
		if err != nil {
			return err
		}
		
		for iter.Next() {
			key := iter.Label()
			val, err := iter.Value().String()
			if err != nil {
				return err
			}
			buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
		}
		
		buf.WriteString("\t},\n")
	}
	
	buf.WriteString("}\n\n")
	return nil
}

func generateCLI(buf *bytes.Buffer, value cue.Value) error {
	buf.WriteString("// CLI contains all command-line interface strings\n")
	buf.WriteString("var CLI = struct {\n")
	buf.WriteString("\tCommands map[string]struct {\n")
	buf.WriteString("\t\tShort string\n")
	buf.WriteString("\t\tLong  string\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tMessages map[string]string\n")
	buf.WriteString("\tErrors   map[string]string\n")
	buf.WriteString("\tFlags    map[string]string\n")
	buf.WriteString("}{\n")
	
	cli := value.LookupPath(cue.ParsePath("#CLI"))
	
	// Generate commands
	buf.WriteString("\tCommands: map[string]struct {\n")
	buf.WriteString("\t\tShort string\n")
	buf.WriteString("\t\tLong  string\n")
	buf.WriteString("\t}{\n")
	
	commands := cli.LookupPath(cue.ParsePath("commands"))
	iter, err := commands.Fields()
	if err != nil {
		return err
	}
	
	for iter.Next() {
		cmdName := iter.Label()
		cmdValue := iter.Value()
		
		shortDesc, _ := cmdValue.LookupPath(cue.ParsePath("short")).String()
		longDesc, _ := cmdValue.LookupPath(cue.ParsePath("long")).String()
		
		buf.WriteString(fmt.Sprintf("\t\t%q: {\n", cmdName))
		buf.WriteString(fmt.Sprintf("\t\t\tShort: %q,\n", shortDesc))
		buf.WriteString(fmt.Sprintf("\t\t\tLong:  %q,\n", longDesc))
		buf.WriteString("\t\t},\n")
	}
	
	buf.WriteString("\t},\n")
	
	// Generate messages, errors, and flags as simple maps
	for _, field := range []string{"messages", "errors", "flags"} {
		buf.WriteString(fmt.Sprintf("\t%s: map[string]string{\n", strings.Title(field)))
		
		fieldValue := cli.LookupPath(cue.ParsePath(field))
		iter, err := fieldValue.Fields()
		if err != nil {
			return err
		}
		
		for iter.Next() {
			key := iter.Label()
			val, _ := iter.Value().String()
			buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
		}
		
		buf.WriteString("\t},\n")
	}
	
	buf.WriteString("}\n\n")
	return nil
}

func generateMCP(buf *bytes.Buffer, value cue.Value) error {
	buf.WriteString("// MCP contains all MCP server strings\n")
	buf.WriteString("var MCP = struct {\n")
	buf.WriteString("\tServer struct {\n")
	buf.WriteString("\t\tName        string\n")
	buf.WriteString("\t\tDescription string\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tTools    map[string]struct {\n")
	buf.WriteString("\t\tName        string\n")
	buf.WriteString("\t\tDescription string\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tMessages map[string]string\n")
	buf.WriteString("\tErrors   map[string]string\n")
	buf.WriteString("}{\n")
	
	mcp := value.LookupPath(cue.ParsePath("#MCP"))
	
	// Generate server info
	server := mcp.LookupPath(cue.ParsePath("server"))
	serverName, _ := server.LookupPath(cue.ParsePath("name")).String()
	serverDesc, _ := server.LookupPath(cue.ParsePath("description")).String()
	
	buf.WriteString("\tServer: struct {\n")
	buf.WriteString("\t\tName        string\n")
	buf.WriteString("\t\tDescription string\n")
	buf.WriteString("\t}{\n")
	buf.WriteString(fmt.Sprintf("\t\tName:        %q,\n", serverName))
	buf.WriteString(fmt.Sprintf("\t\tDescription: %q,\n", serverDesc))
	buf.WriteString("\t},\n")
	
	// Generate tools
	buf.WriteString("\tTools: map[string]struct {\n")
	buf.WriteString("\t\tName        string\n")
	buf.WriteString("\t\tDescription string\n")
	buf.WriteString("\t}{\n")
	
	tools := mcp.LookupPath(cue.ParsePath("tools"))
	iter, err := tools.Fields()
	if err != nil {
		return err
	}
	
	for iter.Next() {
		toolKey := iter.Label()
		toolValue := iter.Value()
		
		name, _ := toolValue.LookupPath(cue.ParsePath("name")).String()
		desc, _ := toolValue.LookupPath(cue.ParsePath("description")).String()
		
		buf.WriteString(fmt.Sprintf("\t\t%q: {\n", toolKey))
		buf.WriteString(fmt.Sprintf("\t\t\tName:        %q,\n", name))
		buf.WriteString(fmt.Sprintf("\t\t\tDescription: %q,\n", desc))
		buf.WriteString("\t\t},\n")
	}
	
	buf.WriteString("\t},\n")
	
	// Generate messages and errors
	for _, field := range []string{"messages", "errors"} {
		buf.WriteString(fmt.Sprintf("\t%s: map[string]string{\n", strings.Title(field)))
		
		fieldValue := mcp.LookupPath(cue.ParsePath(field))
		iter, err := fieldValue.Fields()
		if err != nil {
			return err
		}
		
		for iter.Next() {
			key := iter.Label()
			val, _ := iter.Value().String()
			buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
		}
		
		buf.WriteString("\t},\n")
	}
	
	buf.WriteString("}\n\n")
	return nil
}

func generateHandlers(buf *bytes.Buffer, value cue.Value) error {
	buf.WriteString("// Handlers contains all HTTP handler messages\n")
	buf.WriteString("var Handlers = struct {\n")
	buf.WriteString("\tErrors  map[string]string\n")
	buf.WriteString("\tSuccess map[string]string\n")
	buf.WriteString("}{\n")
	
	handlers := value.LookupPath(cue.ParsePath("#Handlers"))
	
	// Generate errors and success maps
	for _, field := range []string{"errors", "success"} {
		buf.WriteString(fmt.Sprintf("\t%s: map[string]string{\n", strings.Title(field)))
		
		fieldValue := handlers.LookupPath(cue.ParsePath(field))
		iter, err := fieldValue.Fields()
		if err != nil {
			return err
		}
		
		for iter.Next() {
			key := iter.Label()
			val, _ := iter.Value().String()
			buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
		}
		
		buf.WriteString("\t},\n")
	}
	
	buf.WriteString("}\n")
	return nil
}

func generateStylesFile(value cue.Value) error {
	var buf bytes.Buffer
	
	// Write header
	buf.WriteString(`// Code generated by ui/generate.go. DO NOT EDIT.

package ui

`)
	
	// Generate color constants
	buf.WriteString("// Color constants\n")
	buf.WriteString("var Colors = struct {\n")
	buf.WriteString("\tPrimary   struct{ BG, Text string }\n")
	buf.WriteString("\tSecondary struct{ BG, Text string }\n")
	buf.WriteString("\tAccents   map[string]string\n")
	buf.WriteString("\tStatus    map[string]string\n")
	buf.WriteString("}{\n")
	
	colors := value.LookupPath(cue.ParsePath("#Colors"))
	
	// Primary colors
	primary := colors.LookupPath(cue.ParsePath("primary"))
	primaryBG, _ := primary.LookupPath(cue.ParsePath("bg")).String()
	primaryText, _ := primary.LookupPath(cue.ParsePath("text")).String()
	buf.WriteString(fmt.Sprintf("\tPrimary: struct{ BG, Text string }{BG: %q, Text: %q},\n", primaryBG, primaryText))
	
	// Secondary colors
	secondary := colors.LookupPath(cue.ParsePath("secondary"))
	secondaryBG, _ := secondary.LookupPath(cue.ParsePath("bg")).String()
	secondaryText, _ := secondary.LookupPath(cue.ParsePath("text")).String()
	buf.WriteString(fmt.Sprintf("\tSecondary: struct{ BG, Text string }{BG: %q, Text: %q},\n", secondaryBG, secondaryText))
	
	// Accents
	buf.WriteString("\tAccents: map[string]string{\n")
	accents := colors.LookupPath(cue.ParsePath("accents"))
	iter, _ := accents.Fields()
	for iter.Next() {
		key := iter.Label()
		val, _ := iter.Value().String()
		buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
	}
	buf.WriteString("\t},\n")
	
	// Status colors
	buf.WriteString("\tStatus: map[string]string{\n")
	status := colors.LookupPath(cue.ParsePath("status"))
	iter, _ = status.Fields()
	for iter.Next() {
		key := iter.Label()
		val, _ := iter.Value().String()
		buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
	}
	buf.WriteString("\t},\n")
	
	buf.WriteString("}\n\n")
	
	// Generate CSS classes
	buf.WriteString("// CSS class mappings\n")
	buf.WriteString("var CSSClasses = struct {\n")
	buf.WriteString("\tText       map[string]string\n")
	buf.WriteString("\tStatusDots map[string]string\n")
	buf.WriteString("\tButtons    map[string]string\n")
	buf.WriteString("\tPanels     map[string]string\n")
	buf.WriteString("}{\n")
	
	cssClasses := value.LookupPath(cue.ParsePath("#CSSClasses"))
	
	// Text classes
	buf.WriteString("\tText: map[string]string{\n")
	text := cssClasses.LookupPath(cue.ParsePath("text"))
	iter, _ = text.Fields()
	for iter.Next() {
		key := iter.Label()
		val, _ := iter.Value().String()
		buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
	}
	buf.WriteString("\t},\n")
	
	// Status dots
	buf.WriteString("\tStatusDots: map[string]string{\n")
	dots := cssClasses.LookupPath(cue.ParsePath("status_dots"))
	iter, _ = dots.Fields()
	for iter.Next() {
		key := iter.Label()
		val, _ := iter.Value().String()
		buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
	}
	buf.WriteString("\t},\n")
	
	// Buttons
	buf.WriteString("\tButtons: map[string]string{\n")
	buttons := cssClasses.LookupPath(cue.ParsePath("buttons"))
	iter, _ = buttons.Fields()
	for iter.Next() {
		key := iter.Label()
		val, _ := iter.Value().String()
		buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
	}
	buf.WriteString("\t},\n")
	
	// Panels
	buf.WriteString("\tPanels: map[string]string{\n")
	panels := cssClasses.LookupPath(cue.ParsePath("panels"))
	iter, _ = panels.Fields()
	for iter.Next() {
		key := iter.Label()
		val, _ := iter.Value().String()
		buf.WriteString(fmt.Sprintf("\t\t%q: %q,\n", key, val))
	}
	buf.WriteString("\t},\n")
	
	buf.WriteString("}\n")
	
	// Format the Go code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format Go code: %w", err)
	}
	
	// Create output directory
	outputDir := filepath.Join("..", "internal", "ui")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}
	
	// Write the file
	outputFile := filepath.Join(outputDir, "styles_gen.go")
	return ioutil.WriteFile(outputFile, formatted, 0644)
}