
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ftl: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/fastertools/ftl-cli/cmd/ftl/main.go (0.0%)</option>
				
				<option value="file1">github.com/fastertools/ftl-cli/internal/api/client.gen.go (20.3%)</option>
				
				<option value="file2">github.com/fastertools/ftl-cli/internal/api/client.go (43.1%)</option>
				
				<option value="file3">github.com/fastertools/ftl-cli/internal/auth/auth.go (95.9%)</option>
				
				<option value="file4">github.com/fastertools/ftl-cli/internal/auth/mocks.go (96.3%)</option>
				
				<option value="file5">github.com/fastertools/ftl-cli/internal/auth/oauth.go (87.0%)</option>
				
				<option value="file6">github.com/fastertools/ftl-cli/internal/auth/storage.go (89.5%)</option>
				
				<option value="file7">github.com/fastertools/ftl-cli/internal/auth/types.go (100.0%)</option>
				
				<option value="file8">github.com/fastertools/ftl-cli/internal/cli/add.go (82.3%)</option>
				
				<option value="file9">github.com/fastertools/ftl-cli/internal/cli/auth.go (16.8%)</option>
				
				<option value="file10">github.com/fastertools/ftl-cli/internal/cli/build.go (90.7%)</option>
				
				<option value="file11">github.com/fastertools/ftl-cli/internal/cli/component.go (12.3%)</option>
				
				<option value="file12">github.com/fastertools/ftl-cli/internal/cli/component_add.go (51.4%)</option>
				
				<option value="file13">github.com/fastertools/ftl-cli/internal/cli/delete.go (11.9%)</option>
				
				<option value="file14">github.com/fastertools/ftl-cli/internal/cli/deploy.go (46.4%)</option>
				
				<option value="file15">github.com/fastertools/ftl-cli/internal/cli/exec_mock.go (0.0%)</option>
				
				<option value="file16">github.com/fastertools/ftl-cli/internal/cli/init.go (70.9%)</option>
				
				<option value="file17">github.com/fastertools/ftl-cli/internal/cli/list.go (55.9%)</option>
				
				<option value="file18">github.com/fastertools/ftl-cli/internal/cli/output.go (76.4%)</option>
				
				<option value="file19">github.com/fastertools/ftl-cli/internal/cli/registry.go (30.0%)</option>
				
				<option value="file20">github.com/fastertools/ftl-cli/internal/cli/root.go (79.4%)</option>
				
				<option value="file21">github.com/fastertools/ftl-cli/internal/cli/status.go (39.3%)</option>
				
				<option value="file22">github.com/fastertools/ftl-cli/internal/cli/synth.go (27.1%)</option>
				
				<option value="file23">github.com/fastertools/ftl-cli/internal/cli/test.go (95.7%)</option>
				
				<option value="file24">github.com/fastertools/ftl-cli/internal/cli/test_helpers.go (11.8%)</option>
				
				<option value="file25">github.com/fastertools/ftl-cli/internal/cli/up.go (64.7%)</option>
				
				<option value="file26">github.com/fastertools/ftl-cli/internal/ftl/deployment.go (0.0%)</option>
				
				<option value="file27">github.com/fastertools/ftl-cli/internal/ftl/ecr_auth.go (0.0%)</option>
				
				<option value="file28">github.com/fastertools/ftl-cli/internal/ftl/synthesis.go (28.6%)</option>
				
				<option value="file29">github.com/fastertools/ftl-cli/internal/ftl/types.go (31.8%)</option>
				
				<option value="file30">github.com/fastertools/ftl-cli/internal/scaffold/scaffold.go (86.9%)</option>
				
				<option value="file31">github.com/fastertools/ftl-cli/internal/synthesis/cdk.go (85.5%)</option>
				
				<option value="file32">github.com/fastertools/ftl-cli/internal/synthesis/helpers.go (100.0%)</option>
				
				<option value="file33">github.com/fastertools/ftl-cli/internal/synthesis/synthesizer.go (85.0%)</option>
				
				<option value="file34">github.com/fastertools/ftl-cli/pkg/spin/executor.go (90.9%)</option>
				
				<option value="file35">github.com/fastertools/ftl-cli/pkg/types/types.go (96.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "os"

        "github.com/fastertools/ftl-cli/internal/cli"
)

// Version information set at build time
var (
        version   = "dev"
        commit    = "unknown"
        buildDate = "unknown"
)

func main() <span class="cov0" title="0">{
        // Set version information for commands to use
        cli.SetVersion(version, commit, buildDate)

        // Execute the root command
        if err := cli.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"

        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AppAccessControl.
const (
        AppAccessControlCustom  AppAccessControl = "custom"
        AppAccessControlOrg     AppAccessControl = "org"
        AppAccessControlPrivate AppAccessControl = "private"
        AppAccessControlPublic  AppAccessControl = "public"
)

// Defines values for AppLatestDeploymentStatus.
const (
        AppLatestDeploymentStatusDeployed   AppLatestDeploymentStatus = "deployed"
        AppLatestDeploymentStatusDeploying  AppLatestDeploymentStatus = "deploying"
        AppLatestDeploymentStatusFailed     AppLatestDeploymentStatus = "failed"
        AppLatestDeploymentStatusPending    AppLatestDeploymentStatus = "pending"
        AppLatestDeploymentStatusRolledBack AppLatestDeploymentStatus = "rolled_back"
)

// Defines values for AppStatus.
const (
        AppStatusACTIVE   AppStatus = "ACTIVE"
        AppStatusCREATING AppStatus = "CREATING"
        AppStatusDELETED  AppStatus = "DELETED"
        AppStatusDELETING AppStatus = "DELETING"
        AppStatusFAILED   AppStatus = "FAILED"
        AppStatusPENDING  AppStatus = "PENDING"
)

// Defines values for CreateAppRequestAccessControl.
const (
        CreateAppRequestAccessControlCustom  CreateAppRequestAccessControl = "custom"
        CreateAppRequestAccessControlOrg     CreateAppRequestAccessControl = "org"
        CreateAppRequestAccessControlPrivate CreateAppRequestAccessControl = "private"
        CreateAppRequestAccessControlPublic  CreateAppRequestAccessControl = "public"
)

// Defines values for CreateAppResponseBodyStatus.
const (
        CreateAppResponseBodyStatusACTIVE   CreateAppResponseBodyStatus = "ACTIVE"
        CreateAppResponseBodyStatusCREATING CreateAppResponseBodyStatus = "CREATING"
        CreateAppResponseBodyStatusDELETED  CreateAppResponseBodyStatus = "DELETED"
        CreateAppResponseBodyStatusDELETING CreateAppResponseBodyStatus = "DELETING"
        CreateAppResponseBodyStatusFAILED   CreateAppResponseBodyStatus = "FAILED"
        CreateAppResponseBodyStatusPENDING  CreateAppResponseBodyStatus = "PENDING"
)

// Defines values for CreateDeploymentRequestAccess.
const (
        CreateDeploymentRequestAccessCustom  CreateDeploymentRequestAccess = "custom"
        CreateDeploymentRequestAccessOrg     CreateDeploymentRequestAccess = "org"
        CreateDeploymentRequestAccessPrivate CreateDeploymentRequestAccess = "private"
        CreateDeploymentRequestAccessPublic  CreateDeploymentRequestAccess = "public"
)

// Defines values for CreateDeploymentRequestApplicationAccess.
const (
        CreateDeploymentRequestApplicationAccessCustom  CreateDeploymentRequestApplicationAccess = "custom"
        CreateDeploymentRequestApplicationAccessOrg     CreateDeploymentRequestApplicationAccess = "org"
        CreateDeploymentRequestApplicationAccessPrivate CreateDeploymentRequestApplicationAccess = "private"
        CreateDeploymentRequestApplicationAccessPublic  CreateDeploymentRequestApplicationAccess = "public"
)

// Defines values for CreateDeploymentRequestApplicationAuthProvider.
const (
        CreateDeploymentRequestApplicationAuthProviderCustom CreateDeploymentRequestApplicationAuthProvider = "custom"
        CreateDeploymentRequestApplicationAuthProviderWorkos CreateDeploymentRequestApplicationAuthProvider = "workos"
)

// Defines values for CreateDeploymentRequestAuthProvider.
const (
        CreateDeploymentRequestAuthProviderCustom CreateDeploymentRequestAuthProvider = "custom"
        CreateDeploymentRequestAuthProviderWorkos CreateDeploymentRequestAuthProvider = "workos"
)

// Defines values for CreateDeploymentRequestEnvironment.
const (
        Development CreateDeploymentRequestEnvironment = "development"
        Production  CreateDeploymentRequestEnvironment = "production"
        Staging     CreateDeploymentRequestEnvironment = "staging"
)

// Defines values for CreateDeploymentResponseBodyStatus.
const (
        CreateDeploymentResponseBodyStatusDEPLOYED  CreateDeploymentResponseBodyStatus = "DEPLOYED"
        CreateDeploymentResponseBodyStatusDEPLOYING CreateDeploymentResponseBodyStatus = "DEPLOYING"
        CreateDeploymentResponseBodyStatusFAILED    CreateDeploymentResponseBodyStatus = "FAILED"
)

// Defines values for ListAppsResponseBodyAppsAccessControl.
const (
        Custom  ListAppsResponseBodyAppsAccessControl = "custom"
        Org     ListAppsResponseBodyAppsAccessControl = "org"
        Private ListAppsResponseBodyAppsAccessControl = "private"
        Public  ListAppsResponseBodyAppsAccessControl = "public"
)

// Defines values for ListAppsResponseBodyAppsLatestDeploymentStatus.
const (
        ListAppsResponseBodyAppsLatestDeploymentStatusDeployed   ListAppsResponseBodyAppsLatestDeploymentStatus = "deployed"
        ListAppsResponseBodyAppsLatestDeploymentStatusDeploying  ListAppsResponseBodyAppsLatestDeploymentStatus = "deploying"
        ListAppsResponseBodyAppsLatestDeploymentStatusFailed     ListAppsResponseBodyAppsLatestDeploymentStatus = "failed"
        ListAppsResponseBodyAppsLatestDeploymentStatusPending    ListAppsResponseBodyAppsLatestDeploymentStatus = "pending"
        ListAppsResponseBodyAppsLatestDeploymentStatusRolledBack ListAppsResponseBodyAppsLatestDeploymentStatus = "rolled_back"
)

// Defines values for ListAppsResponseBodyAppsStatus.
const (
        ListAppsResponseBodyAppsStatusACTIVE   ListAppsResponseBodyAppsStatus = "ACTIVE"
        ListAppsResponseBodyAppsStatusCREATING ListAppsResponseBodyAppsStatus = "CREATING"
        ListAppsResponseBodyAppsStatusDELETED  ListAppsResponseBodyAppsStatus = "DELETED"
        ListAppsResponseBodyAppsStatusDELETING ListAppsResponseBodyAppsStatus = "DELETING"
        ListAppsResponseBodyAppsStatusFAILED   ListAppsResponseBodyAppsStatus = "FAILED"
        ListAppsResponseBodyAppsStatusPENDING  ListAppsResponseBodyAppsStatus = "PENDING"
)

// App Application object
type App struct {
        AccessControl *AppAccessControl  `json:"accessControl,omitempty"`
        AllowedRoles  *[]string          `json:"allowedRoles,omitempty"`
        AppId         openapi_types.UUID `json:"appId"`
        AppName       string             `json:"appName"`
        CreatedAt     string             `json:"createdAt"`
        CustomAuth    *struct {
                Audience string `json:"audience"`
                Issuer   string `json:"issuer"`
        } `json:"customAuth,omitempty"`

        // LatestDeployment Latest deployment information for this app
        LatestDeployment *struct {
                CreatedAt          *float32                  `json:"createdAt,omitempty"`
                DeployedAt         *float32                  `json:"deployedAt,omitempty"`
                DeploymentDuration *float32                  `json:"deploymentDuration,omitempty"`
                DeploymentId       string                    `json:"deploymentId"`
                Environment        *string                   `json:"environment,omitempty"`
                Status             AppLatestDeploymentStatus `json:"status"`
                StatusMessage      *string                   `json:"statusMessage,omitempty"`
        } `json:"latestDeployment"`
        OrgId         *string   `json:"orgId,omitempty"`
        ProviderError *string   `json:"providerError,omitempty"`
        ProviderUrl   *string   `json:"providerUrl,omitempty"`
        Status        AppStatus `json:"status"`
        UpdatedAt     string    `json:"updatedAt"`
}

// AppAccessControl defines model for App.AccessControl.
type AppAccessControl string

// AppLatestDeploymentStatus defines model for App.LatestDeployment.Status.
type AppLatestDeploymentStatus string

// AppStatus defines model for App.Status.
type AppStatus string

// CreateAppRequest Request body for creating an app
type CreateAppRequest struct {
        // AccessControl Access control mode for the application
        AccessControl *CreateAppRequestAccessControl `json:"accessControl,omitempty"`

        // AppName The name of the application
        AppName string `json:"appName"`
}

// CreateAppRequestAccessControl Access control mode for the application
type CreateAppRequestAccessControl string

// CreateAppResponseBody Response for successful app creation
type CreateAppResponseBody struct {
        AppId     openapi_types.UUID          `json:"appId"`
        AppName   string                      `json:"appName"`
        CreatedAt string                      `json:"createdAt"`
        Status    CreateAppResponseBodyStatus `json:"status"`
        UpdatedAt string                      `json:"updatedAt"`
}

// CreateAppResponseBodyStatus defines model for CreateAppResponseBody.Status.
type CreateAppResponseBodyStatus string

// CreateDeploymentRequest Request body for creating a deployment
type CreateDeploymentRequest struct {
        // Access Access control override
        Access *CreateDeploymentRequestAccess `json:"access,omitempty"`

        // Application FTL application configuration
        Application struct {
                // Access Access control mode
                Access *CreateDeploymentRequestApplicationAccess `json:"access,omitempty"`

                // Auth Authentication configuration
                Auth *struct {
                        JwtAudience *string                                         `json:"jwt_audience,omitempty"`
                        JwtIssuer   *string                                         `json:"jwt_issuer,omitempty"`
                        OrgId       *string                                         `json:"org_id,omitempty"`
                        Provider    *CreateDeploymentRequestApplicationAuthProvider `json:"provider,omitempty"`
                } `json:"auth,omitempty"`

                // Components Application components
                Components *[]struct {
                        // Id Component ID
                        Id string `json:"id"`

                        // Source Registry reference to pushed component (components must be pushed to ECR first)
                        Source struct {
                                // Package Package path (e.g., app123abc/graph)
                                Package string `json:"package"`

                                // Registry ECR registry endpoint (e.g., 795394005211.dkr.ecr.us-west-2.amazonaws.com)
                                Registry string `json:"registry"`

                                // Version Component version (e.g., 0.1.0)
                                Version string `json:"version"`
                        } `json:"source"`

                        // Variables Component-specific variables
                        Variables *map[string]string `json:"variables,omitempty"`
                } `json:"components,omitempty"`

                // Description Application description
                Description *string `json:"description,omitempty"`

                // Name Application name
                Name string `json:"name"`

                // Variables Application variables
                Variables *map[string]string `json:"variables,omitempty"`

                // Version Application version
                Version *string `json:"version,omitempty"`
        } `json:"application"`

        // Auth Auth configuration override
        Auth *struct {
                JwtAudience *string                              `json:"jwt_audience,omitempty"`
                JwtIssuer   *string                              `json:"jwt_issuer,omitempty"`
                OrgId       *string                              `json:"org_id,omitempty"`
                Provider    *CreateDeploymentRequestAuthProvider `json:"provider,omitempty"`
        } `json:"auth,omitempty"`

        // Environment Deployment environment
        Environment *CreateDeploymentRequestEnvironment `json:"environment,omitempty"`

        // Variables Environment-specific variables
        Variables *map[string]string `json:"variables,omitempty"`
}

// CreateDeploymentRequestAccess Access control override
type CreateDeploymentRequestAccess string

// CreateDeploymentRequestApplicationAccess Access control mode
type CreateDeploymentRequestApplicationAccess string

// CreateDeploymentRequestApplicationAuthProvider defines model for CreateDeploymentRequest.Application.Auth.Provider.
type CreateDeploymentRequestApplicationAuthProvider string

// CreateDeploymentRequestAuthProvider defines model for CreateDeploymentRequest.Auth.Provider.
type CreateDeploymentRequestAuthProvider string

// CreateDeploymentRequestEnvironment Deployment environment
type CreateDeploymentRequestEnvironment string

// CreateDeploymentResponseBody Response for successful deployment creation
type CreateDeploymentResponseBody struct {
        // AppId Application identifier
        AppId string `json:"appId"`

        // AppName Application name
        AppName string `json:"appName"`

        // AppUrl Application URL once deployed
        AppUrl *string `json:"appUrl,omitempty"`

        // DeploymentId Unique deployment identifier
        DeploymentId string `json:"deploymentId"`

        // Message Status message
        Message string `json:"message"`

        // Status Deployment status
        Status CreateDeploymentResponseBodyStatus `json:"status"`
}

// CreateDeploymentResponseBodyStatus Deployment status
type CreateDeploymentResponseBodyStatus string

// CreateEcrTokenRequest Request body for creating ECR token
type CreateEcrTokenRequest struct {
        // AppId Application ID to create ECR token for
        AppId openapi_types.UUID `json:"appId"`

        // Components Component names to create/ensure repositories for
        Components []string `json:"components"`
}

// CreateEcrTokenResponseBody ECR token response with app-scoped credentials
type CreateEcrTokenResponseBody struct {
        // AppId Original app UUID for reference
        AppId *string `json:"appId,omitempty"`

        // AuthorizationToken Base64 encoded username:password for Docker login
        AuthorizationToken string `json:"authorizationToken"`

        // ExpiresAt Token expiration time in ISO 8601 format
        ExpiresAt string `json:"expiresAt"`

        // PackageNamespace Sanitized namespace for spin deps publish commands
        PackageNamespace *string `json:"packageNamespace,omitempty"`

        // ProxyEndpoint Full ECR endpoint URL
        ProxyEndpoint string `json:"proxyEndpoint"`

        // Region AWS region
        Region string `json:"region"`

        // RegistryUri ECR registry URI without https://
        RegistryUri string `json:"registryUri"`
}

// DeleteAppResponseBody Response for successful app deletion
type DeleteAppResponseBody struct {
        Message string `json:"message"`
}

// ErrorResponse Standard error response format
type ErrorResponse struct {
        Details *[]interface{} `json:"details,omitempty"`
        Error   *string        `json:"error,omitempty"`
        Message string         `json:"message"`
}

// GetAppLogsResponseBody Application logs response
type GetAppLogsResponseBody struct {
        // AppId Application ID
        AppId openapi_types.UUID `json:"appId"`

        // Logs Raw log output from the application
        Logs     string `json:"logs"`
        Metadata struct {
                // Since Time range used for the query
                Since string `json:"since"`

                // Tail Number of lines requested
                Tail float32 `json:"tail"`
        } `json:"metadata"`
}

// GetUserOrgsResponseBody List of user organizations
type GetUserOrgsResponseBody struct {
        // Organizations List of organizations the user belongs to
        Organizations []struct {
                // Id Organization ID from WorkOS
                Id string `json:"id"`

                // Name Organization name
                Name string `json:"name"`
        } `json:"organizations"`
}

// ListAppsResponseBody List of applications with pagination
type ListAppsResponseBody struct {
        Apps []struct {
                AccessControl *ListAppsResponseBodyAppsAccessControl `json:"accessControl,omitempty"`
                AllowedRoles  *[]string                              `json:"allowedRoles,omitempty"`
                AppId         openapi_types.UUID                     `json:"appId"`
                AppName       string                                 `json:"appName"`
                CreatedAt     string                                 `json:"createdAt"`
                CustomAuth    *struct {
                        Audience string `json:"audience"`
                        Issuer   string `json:"issuer"`
                } `json:"customAuth,omitempty"`

                // LatestDeployment Latest deployment information for this app
                LatestDeployment *struct {
                        CreatedAt          *float32                                       `json:"createdAt,omitempty"`
                        DeployedAt         *float32                                       `json:"deployedAt,omitempty"`
                        DeploymentDuration *float32                                       `json:"deploymentDuration,omitempty"`
                        DeploymentId       string                                         `json:"deploymentId"`
                        Environment        *string                                        `json:"environment,omitempty"`
                        Status             ListAppsResponseBodyAppsLatestDeploymentStatus `json:"status"`
                        StatusMessage      *string                                        `json:"statusMessage,omitempty"`
                } `json:"latestDeployment"`
                OrgId         *string                        `json:"orgId,omitempty"`
                ProviderError *string                        `json:"providerError,omitempty"`
                ProviderUrl   *string                        `json:"providerUrl,omitempty"`
                Status        ListAppsResponseBodyAppsStatus `json:"status"`
                UpdatedAt     string                         `json:"updatedAt"`
        } `json:"apps"`
        NextToken *string `json:"nextToken,omitempty"`
}

// ListAppsResponseBodyAppsAccessControl defines model for ListAppsResponseBody.Apps.AccessControl.
type ListAppsResponseBodyAppsAccessControl string

// ListAppsResponseBodyAppsLatestDeploymentStatus defines model for ListAppsResponseBody.Apps.LatestDeployment.Status.
type ListAppsResponseBodyAppsLatestDeploymentStatus string

// ListAppsResponseBodyAppsStatus defines model for ListAppsResponseBody.Apps.Status.
type ListAppsResponseBodyAppsStatus string

// ListComponentsResponseBody List of components for an app
type ListComponentsResponseBody struct {
        AppId      openapi_types.UUID `json:"appId"`
        AppName    string             `json:"appName"`
        Components []struct {
                ComponentName  string  `json:"componentName"`
                Description    *string `json:"description,omitempty"`
                RepositoryName *string `json:"repositoryName,omitempty"`
                RepositoryUri  *string `json:"repositoryUri,omitempty"`
        } `json:"components"`
}

// UpdateComponentsRequest Request body for updating components
type UpdateComponentsRequest struct {
        Components []struct {
                ComponentName string  `json:"componentName"`
                Description   *string `json:"description,omitempty"`
        } `json:"components"`
}

// UpdateComponentsResponseBody Response for successful components update
type UpdateComponentsResponseBody struct {
        Changes struct {
                Created []string `json:"created"`
                Removed []string `json:"removed"`
                Updated []string `json:"updated"`
        } `json:"changes"`
        Components []struct {
                ComponentName  string  `json:"componentName"`
                Description    *string `json:"description,omitempty"`
                RepositoryName *string `json:"repositoryName,omitempty"`
                RepositoryUri  *string `json:"repositoryUri,omitempty"`
        } `json:"components"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
        // Limit Number of items to return (1-100)
        Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

        // NextToken Pagination token from previous response
        NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

        // Name Filter by app name
        Name *string `form:"name,omitempty" json:"name,omitempty"`

        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// CreateAppParams defines parameters for CreateApp.
type CreateAppParams struct {
        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// DeleteAppParams defines parameters for DeleteApp.
type DeleteAppParams struct {
        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// GetAppParams defines parameters for GetApp.
type GetAppParams struct {
        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// ListAppComponentsParams defines parameters for ListAppComponents.
type ListAppComponentsParams struct {
        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// UpdateComponentsParams defines parameters for UpdateComponents.
type UpdateComponentsParams struct {
        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// CreateDeploymentParams defines parameters for CreateDeployment.
type CreateDeploymentParams struct {
        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// GetAppLogsParams defines parameters for GetAppLogs.
type GetAppLogsParams struct {
        // Since Time range for logs (e.g., "30m", "1h", "7d", or RFC3339/Unix timestamp)
        Since *string `form:"since,omitempty" json:"since,omitempty"`

        // Tail Number of log lines from the end (1-1000)
        Tail *string `form:"tail,omitempty" json:"tail,omitempty"`

        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// CreateEcrTokenParams defines parameters for CreateEcrToken.
type CreateEcrTokenParams struct {
        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// GetUserOrgsParams defines parameters for GetUserOrgs.
type GetUserOrgsParams struct {
        // Authorization Bearer token for authentication
        Authorization string `json:"Authorization"`
}

// CreateAppJSONRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody = CreateAppRequest

// UpdateComponentsJSONRequestBody defines body for UpdateComponents for application/json ContentType.
type UpdateComponentsJSONRequestBody = UpdateComponentsRequest

// CreateDeploymentJSONRequestBody defines body for CreateDeployment for application/json ContentType.
type CreateDeploymentJSONRequestBody = CreateDeploymentRequest

// CreateEcrTokenJSONRequestBody defines body for CreateEcrToken for application/json ContentType.
type CreateEcrTokenJSONRequestBody = CreateEcrTokenRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
        Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
        // The endpoint of the server conforming to this interface, with scheme,
        // https://api.deepmap.com for example. This can contain a path relative
        // to the server, such as https://api.deepmap.com/dev-test, and all the
        // paths in the swagger spec will be appended to the server.
        Server string

        // Doer for performing requests, typically a *http.Client with any
        // customized settings, such as certificate chains.
        Client HttpRequestDoer

        // A list of callbacks for modifying requests which are generated before sending over
        // the network.
        RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) <span class="cov8" title="1">{
        // create a client with sane default values
        client := Client{
                Server: server,
        }
        // mutate client and add all optional params
        for _, o := range opts </span><span class="cov8" title="1">{
                if err := o(&amp;client); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        // ensure the server URL always has a trailing slash
        <span class="cov8" title="1">if !strings.HasSuffix(client.Server, "/") </span><span class="cov8" title="1">{
                client.Server += "/"
        }</span>
        // create httpClient, if not already present
        <span class="cov8" title="1">if client.Client == nil </span><span class="cov0" title="0">{
                client.Client = &amp;http.Client{}
        }</span>
        <span class="cov8" title="1">return &amp;client, nil</span>
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption <span class="cov8" title="1">{
        return func(c *Client) error </span><span class="cov8" title="1">{
                c.Client = doer
                return nil
        }</span>
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                c.RequestEditors = append(c.RequestEditors, fn)
                return nil
        }</span>
}

// The interface specification for the client above.
type ClientInterface interface {
        // ListApps request
        ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // CreateAppWithBody request with any body
        CreateAppWithBody(ctx context.Context, params *CreateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        CreateApp(ctx context.Context, params *CreateAppParams, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // DeleteApp request
        DeleteApp(ctx context.Context, appId openapi_types.UUID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetApp request
        GetApp(ctx context.Context, appId openapi_types.UUID, params *GetAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // ListAppComponents request
        ListAppComponents(ctx context.Context, appId openapi_types.UUID, params *ListAppComponentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // UpdateComponentsWithBody request with any body
        UpdateComponentsWithBody(ctx context.Context, appId openapi_types.UUID, params *UpdateComponentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        UpdateComponents(ctx context.Context, appId openapi_types.UUID, params *UpdateComponentsParams, body UpdateComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // CreateDeploymentWithBody request with any body
        CreateDeploymentWithBody(ctx context.Context, appId openapi_types.UUID, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        CreateDeployment(ctx context.Context, appId openapi_types.UUID, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetAppLogs request
        GetAppLogs(ctx context.Context, appId openapi_types.UUID, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

        // CreateEcrTokenWithBody request with any body
        CreateEcrTokenWithBody(ctx context.Context, params *CreateEcrTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

        CreateEcrToken(ctx context.Context, params *CreateEcrTokenParams, body CreateEcrTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

        // GetUserOrgs request
        GetUserOrgs(ctx context.Context, params *GetUserOrgsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov8" title="1">{
        req, err := NewListAppsRequest(c.Server, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return c.Client.Do(req)</span>
}

func (c *Client) CreateAppWithBody(ctx context.Context, params *CreateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewCreateAppRequestWithBody(c.Server, params, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) CreateApp(ctx context.Context, params *CreateAppParams, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov8" title="1">{
        req, err := NewCreateAppRequest(c.Server, params, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return c.Client.Do(req)</span>
}

func (c *Client) DeleteApp(ctx context.Context, appId openapi_types.UUID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov8" title="1">{
        req, err := NewDeleteAppRequest(c.Server, appId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return c.Client.Do(req)</span>
}

func (c *Client) GetApp(ctx context.Context, appId openapi_types.UUID, params *GetAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov8" title="1">{
        req, err := NewGetAppRequest(c.Server, appId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return c.Client.Do(req)</span>
}

func (c *Client) ListAppComponents(ctx context.Context, appId openapi_types.UUID, params *ListAppComponentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewListAppComponentsRequest(c.Server, appId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) UpdateComponentsWithBody(ctx context.Context, appId openapi_types.UUID, params *UpdateComponentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewUpdateComponentsRequestWithBody(c.Server, appId, params, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) UpdateComponents(ctx context.Context, appId openapi_types.UUID, params *UpdateComponentsParams, body UpdateComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewUpdateComponentsRequest(c.Server, appId, params, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) CreateDeploymentWithBody(ctx context.Context, appId openapi_types.UUID, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewCreateDeploymentRequestWithBody(c.Server, appId, params, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) CreateDeployment(ctx context.Context, appId openapi_types.UUID, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewCreateDeploymentRequest(c.Server, appId, params, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetAppLogs(ctx context.Context, appId openapi_types.UUID, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetAppLogsRequest(c.Server, appId, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) CreateEcrTokenWithBody(ctx context.Context, params *CreateEcrTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewCreateEcrTokenRequestWithBody(c.Server, params, contentType, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) CreateEcrToken(ctx context.Context, params *CreateEcrTokenParams, body CreateEcrTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewCreateEcrTokenRequest(c.Server, params, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

func (c *Client) GetUserOrgs(ctx context.Context, params *GetUserOrgsParams, reqEditors ...RequestEditorFn) (*http.Response, error) <span class="cov0" title="0">{
        req, err := NewGetUserOrgsRequest(c.Server, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, params *ListAppsParams) (*http.Request, error) <span class="cov8" title="1">{
        var err error

        serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">operationPath := fmt.Sprintf("/v1/apps")
        if operationPath[0] == '/' </span><span class="cov8" title="1">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov8" title="1">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Limit != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.NextToken != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Name != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov8" title="1">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov8" title="1">return req, nil</span>
}

// NewCreateAppRequest calls the generic CreateApp builder with application/json body
func NewCreateAppRequest(server string, params *CreateAppParams, body CreateAppJSONRequestBody) (*http.Request, error) <span class="cov8" title="1">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">bodyReader = bytes.NewReader(buf)
        return NewCreateAppRequestWithBody(server, params, "application/json", bodyReader)</span>
}

// NewCreateAppRequestWithBody generates requests for CreateApp with any type of body
func NewCreateAppRequestWithBody(server string, params *CreateAppParams, contentType string, body io.Reader) (*http.Request, error) <span class="cov8" title="1">{
        var err error

        serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">operationPath := fmt.Sprintf("/v1/apps")
        if operationPath[0] == '/' </span><span class="cov8" title="1">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov8" title="1">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req.Header.Add("Content-Type", contentType)

        if params != nil </span><span class="cov8" title="1">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov8" title="1">return req, nil</span>
}

// NewDeleteAppRequest generates requests for DeleteApp
func NewDeleteAppRequest(server string, appId openapi_types.UUID, params *DeleteAppParams) (*http.Request, error) <span class="cov8" title="1">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
        if operationPath[0] == '/' </span><span class="cov8" title="1">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov8" title="1">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("DELETE", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if params != nil </span><span class="cov8" title="1">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov8" title="1">return req, nil</span>
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, appId openapi_types.UUID, params *GetAppParams) (*http.Request, error) <span class="cov8" title="1">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
        if operationPath[0] == '/' </span><span class="cov8" title="1">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov8" title="1">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if params != nil </span><span class="cov8" title="1">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov8" title="1">return req, nil</span>
}

// NewListAppComponentsRequest generates requests for ListAppComponents
func NewListAppComponentsRequest(server string, appId openapi_types.UUID, params *ListAppComponentsParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/apps/%s/components", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov0" title="0">return req, nil</span>
}

// NewUpdateComponentsRequest calls the generic UpdateComponents builder with application/json body
func NewUpdateComponentsRequest(server string, appId openapi_types.UUID, params *UpdateComponentsParams, body UpdateComponentsJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewUpdateComponentsRequestWithBody(server, appId, params, "application/json", bodyReader)</span>
}

// NewUpdateComponentsRequestWithBody generates requests for UpdateComponents with any type of body
func NewUpdateComponentsRequestWithBody(server string, appId openapi_types.UUID, params *UpdateComponentsParams, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/apps/%s/components", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov0" title="0">return req, nil</span>
}

// NewCreateDeploymentRequest calls the generic CreateDeployment builder with application/json body
func NewCreateDeploymentRequest(server string, appId openapi_types.UUID, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewCreateDeploymentRequestWithBody(server, appId, params, "application/json", bodyReader)</span>
}

// NewCreateDeploymentRequestWithBody generates requests for CreateDeployment with any type of body
func NewCreateDeploymentRequestWithBody(server string, appId openapi_types.UUID, params *CreateDeploymentParams, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/apps/%s/deployments", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetAppLogsRequest generates requests for GetAppLogs
func NewGetAppLogsRequest(server string, appId openapi_types.UUID, params *GetAppLogsParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        var pathParam0 string

        pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/apps/%s/logs", pathParam0)
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                queryValues := queryURL.Query()

                if params.Since != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">if params.Tail != nil </span><span class="cov0" title="0">{

                        if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tail", runtime.ParamLocationQuery, *params.Tail); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> if parsed, err := url.ParseQuery(queryFrag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                for k, v := range parsed </span><span class="cov0" title="0">{
                                        for _, v2 := range v </span><span class="cov0" title="0">{
                                                queryValues.Add(k, v2)
                                        }</span>
                                }
                        }

                }

                <span class="cov0" title="0">queryURL.RawQuery = queryValues.Encode()</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov0" title="0">return req, nil</span>
}

// NewCreateEcrTokenRequest calls the generic CreateEcrToken builder with application/json body
func NewCreateEcrTokenRequest(server string, params *CreateEcrTokenParams, body CreateEcrTokenJSONRequestBody) (*http.Request, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        buf, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyReader = bytes.NewReader(buf)
        return NewCreateEcrTokenRequestWithBody(server, params, "application/json", bodyReader)</span>
}

// NewCreateEcrTokenRequestWithBody generates requests for CreateEcrToken with any type of body
func NewCreateEcrTokenRequestWithBody(server string, params *CreateEcrTokenParams, contentType string, body io.Reader) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/registry/tokens")
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", queryURL.String(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Add("Content-Type", contentType)

        if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov0" title="0">return req, nil</span>
}

// NewGetUserOrgsRequest generates requests for GetUserOrgs
func NewGetUserOrgsRequest(server string, params *GetUserOrgsParams) (*http.Request, error) <span class="cov0" title="0">{
        var err error

        serverURL, err := url.Parse(server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">operationPath := fmt.Sprintf("/v1/user/orgs")
        if operationPath[0] == '/' </span><span class="cov0" title="0">{
                operationPath = "." + operationPath
        }</span>

        <span class="cov0" title="0">queryURL, err := serverURL.Parse(operationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{

                var headerParam0 string

                headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req.Header.Set("Authorization", headerParam0)</span>

        }

        <span class="cov0" title="0">return req, nil</span>
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error <span class="cov8" title="1">{
        for _, r := range c.RequestEditors </span><span class="cov0" title="0">{
                if err := r(ctx, req); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">for _, r := range additionalEditors </span><span class="cov0" title="0">{
                if err := r(ctx, req); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
        ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) <span class="cov8" title="1">{
        client, err := NewClient(server, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ClientWithResponses{client}, nil</span>
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                newBaseURL, err := url.Parse(baseURL)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c.Server = newBaseURL.String()
                return nil</span>
        }
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
        // ListAppsWithResponse request
        ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

        // CreateAppWithBodyWithResponse request with any body
        CreateAppWithBodyWithResponse(ctx context.Context, params *CreateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

        CreateAppWithResponse(ctx context.Context, params *CreateAppParams, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

        // DeleteAppWithResponse request
        DeleteAppWithResponse(ctx context.Context, appId openapi_types.UUID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error)

        // GetAppWithResponse request
        GetAppWithResponse(ctx context.Context, appId openapi_types.UUID, params *GetAppParams, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

        // ListAppComponentsWithResponse request
        ListAppComponentsWithResponse(ctx context.Context, appId openapi_types.UUID, params *ListAppComponentsParams, reqEditors ...RequestEditorFn) (*ListAppComponentsResponse, error)

        // UpdateComponentsWithBodyWithResponse request with any body
        UpdateComponentsWithBodyWithResponse(ctx context.Context, appId openapi_types.UUID, params *UpdateComponentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentsResponse, error)

        UpdateComponentsWithResponse(ctx context.Context, appId openapi_types.UUID, params *UpdateComponentsParams, body UpdateComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentsResponse, error)

        // CreateDeploymentWithBodyWithResponse request with any body
        CreateDeploymentWithBodyWithResponse(ctx context.Context, appId openapi_types.UUID, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

        CreateDeploymentWithResponse(ctx context.Context, appId openapi_types.UUID, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

        // GetAppLogsWithResponse request
        GetAppLogsWithResponse(ctx context.Context, appId openapi_types.UUID, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*GetAppLogsResponse, error)

        // CreateEcrTokenWithBodyWithResponse request with any body
        CreateEcrTokenWithBodyWithResponse(ctx context.Context, params *CreateEcrTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEcrTokenResponse, error)

        CreateEcrTokenWithResponse(ctx context.Context, params *CreateEcrTokenParams, body CreateEcrTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEcrTokenResponse, error)

        // GetUserOrgsWithResponse request
        GetUserOrgsWithResponse(ctx context.Context, params *GetUserOrgsParams, reqEditors ...RequestEditorFn) (*GetUserOrgsResponse, error)
}

type ListAppsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *ListAppsResponseBody
        JSON400      *ErrorResponse
        JSON401      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CreateAppResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON201      *CreateAppResponseBody
        JSON400      *ErrorResponse
        JSON401      *ErrorResponse
        JSON409      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateAppResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteAppResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON202      *DeleteAppResponseBody
        JSON401      *ErrorResponse
        JSON404      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAppResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetAppResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *App
        JSON401      *ErrorResponse
        JSON404      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListAppComponentsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *ListComponentsResponseBody
        JSON401      *ErrorResponse
        JSON404      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListAppComponentsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppComponentsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateComponentsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *UpdateComponentsResponseBody
        JSON400      *ErrorResponse
        JSON401      *ErrorResponse
        JSON404      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateComponentsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateComponentsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CreateDeploymentResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON202      *CreateDeploymentResponseBody
        JSON400      *ErrorResponse
        JSON401      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateDeploymentResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeploymentResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetAppLogsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *GetAppLogsResponseBody
        JSON400      *ErrorResponse
        JSON401      *ErrorResponse
        JSON403      *ErrorResponse
        JSON404      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAppLogsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppLogsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CreateEcrTokenResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *CreateEcrTokenResponseBody
        JSON401      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateEcrTokenResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEcrTokenResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserOrgsResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *GetUserOrgsResponseBody
        JSON401      *ErrorResponse
        JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUserOrgsResponse) Status() string <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.Status
        }</span>
        <span class="cov0" title="0">return http.StatusText(0)</span>
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOrgsResponse) StatusCode() int <span class="cov0" title="0">{
        if r.HTTPResponse != nil </span><span class="cov0" title="0">{
                return r.HTTPResponse.StatusCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) <span class="cov8" title="1">{
        rsp, err := c.ListApps(ctx, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ParseListAppsResponse(rsp)</span>
}

// CreateAppWithBodyWithResponse request with arbitrary body returning *CreateAppResponse
func (c *ClientWithResponses) CreateAppWithBodyWithResponse(ctx context.Context, params *CreateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) <span class="cov0" title="0">{
        rsp, err := c.CreateAppWithBody(ctx, params, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseCreateAppResponse(rsp)</span>
}

func (c *ClientWithResponses) CreateAppWithResponse(ctx context.Context, params *CreateAppParams, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) <span class="cov8" title="1">{
        rsp, err := c.CreateApp(ctx, params, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ParseCreateAppResponse(rsp)</span>
}

// DeleteAppWithResponse request returning *DeleteAppResponse
func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, appId openapi_types.UUID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error) <span class="cov8" title="1">{
        rsp, err := c.DeleteApp(ctx, appId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ParseDeleteAppResponse(rsp)</span>
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, appId openapi_types.UUID, params *GetAppParams, reqEditors ...RequestEditorFn) (*GetAppResponse, error) <span class="cov8" title="1">{
        rsp, err := c.GetApp(ctx, appId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ParseGetAppResponse(rsp)</span>
}

// ListAppComponentsWithResponse request returning *ListAppComponentsResponse
func (c *ClientWithResponses) ListAppComponentsWithResponse(ctx context.Context, appId openapi_types.UUID, params *ListAppComponentsParams, reqEditors ...RequestEditorFn) (*ListAppComponentsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.ListAppComponents(ctx, appId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseListAppComponentsResponse(rsp)</span>
}

// UpdateComponentsWithBodyWithResponse request with arbitrary body returning *UpdateComponentsResponse
func (c *ClientWithResponses) UpdateComponentsWithBodyWithResponse(ctx context.Context, appId openapi_types.UUID, params *UpdateComponentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.UpdateComponentsWithBody(ctx, appId, params, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseUpdateComponentsResponse(rsp)</span>
}

func (c *ClientWithResponses) UpdateComponentsWithResponse(ctx context.Context, appId openapi_types.UUID, params *UpdateComponentsParams, body UpdateComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.UpdateComponents(ctx, appId, params, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseUpdateComponentsResponse(rsp)</span>
}

// CreateDeploymentWithBodyWithResponse request with arbitrary body returning *CreateDeploymentResponse
func (c *ClientWithResponses) CreateDeploymentWithBodyWithResponse(ctx context.Context, appId openapi_types.UUID, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) <span class="cov0" title="0">{
        rsp, err := c.CreateDeploymentWithBody(ctx, appId, params, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseCreateDeploymentResponse(rsp)</span>
}

func (c *ClientWithResponses) CreateDeploymentWithResponse(ctx context.Context, appId openapi_types.UUID, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) <span class="cov0" title="0">{
        rsp, err := c.CreateDeployment(ctx, appId, params, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseCreateDeploymentResponse(rsp)</span>
}

// GetAppLogsWithResponse request returning *GetAppLogsResponse
func (c *ClientWithResponses) GetAppLogsWithResponse(ctx context.Context, appId openapi_types.UUID, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*GetAppLogsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetAppLogs(ctx, appId, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetAppLogsResponse(rsp)</span>
}

// CreateEcrTokenWithBodyWithResponse request with arbitrary body returning *CreateEcrTokenResponse
func (c *ClientWithResponses) CreateEcrTokenWithBodyWithResponse(ctx context.Context, params *CreateEcrTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEcrTokenResponse, error) <span class="cov0" title="0">{
        rsp, err := c.CreateEcrTokenWithBody(ctx, params, contentType, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseCreateEcrTokenResponse(rsp)</span>
}

func (c *ClientWithResponses) CreateEcrTokenWithResponse(ctx context.Context, params *CreateEcrTokenParams, body CreateEcrTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEcrTokenResponse, error) <span class="cov0" title="0">{
        rsp, err := c.CreateEcrToken(ctx, params, body, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseCreateEcrTokenResponse(rsp)</span>
}

// GetUserOrgsWithResponse request returning *GetUserOrgsResponse
func (c *ClientWithResponses) GetUserOrgsWithResponse(ctx context.Context, params *GetUserOrgsParams, reqEditors ...RequestEditorFn) (*GetUserOrgsResponse, error) <span class="cov0" title="0">{
        rsp, err := c.GetUserOrgs(ctx, params, reqEditors...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ParseGetUserOrgsResponse(rsp)</span>
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) <span class="cov8" title="1">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov8" title="1">{ _ = rsp.Body.Close() }</span>()
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">response := &amp;ListAppsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov8" title="1">
                var dest ListAppsResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov8" title="1">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">response.JSON500 = &amp;dest</span>

        }

        <span class="cov8" title="1">return response, nil</span>
}

// ParseCreateAppResponse parses an HTTP response from a CreateAppWithResponse call
func ParseCreateAppResponse(rsp *http.Response) (*CreateAppResponse, error) <span class="cov8" title="1">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov8" title="1">{ _ = rsp.Body.Close() }</span>()
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">response := &amp;CreateAppResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 201:<span class="cov8" title="1">
                var dest CreateAppResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">response.JSON201 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 409:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON409 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov8" title="1">return response, nil</span>
}

// ParseDeleteAppResponse parses an HTTP response from a DeleteAppWithResponse call
func ParseDeleteAppResponse(rsp *http.Response) (*DeleteAppResponse, error) <span class="cov8" title="1">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov8" title="1">{ _ = rsp.Body.Close() }</span>()
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">response := &amp;DeleteAppResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 202:<span class="cov0" title="0">
                var dest DeleteAppResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON202 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov8" title="1">return response, nil</span>
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) <span class="cov8" title="1">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov8" title="1">{ _ = rsp.Body.Close() }</span>()
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">response := &amp;GetAppResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov8" title="1">
                var dest App
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov8" title="1">return response, nil</span>
}

// ParseListAppComponentsResponse parses an HTTP response from a ListAppComponentsWithResponse call
func ParseListAppComponentsResponse(rsp *http.Response) (*ListAppComponentsResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;ListAppComponentsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest ListComponentsResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseUpdateComponentsResponse parses an HTTP response from a UpdateComponentsWithResponse call
func ParseUpdateComponentsResponse(rsp *http.Response) (*UpdateComponentsResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;UpdateComponentsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest UpdateComponentsResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseCreateDeploymentResponse parses an HTTP response from a CreateDeploymentWithResponse call
func ParseCreateDeploymentResponse(rsp *http.Response) (*CreateDeploymentResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;CreateDeploymentResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 202:<span class="cov0" title="0">
                var dest CreateDeploymentResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON202 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetAppLogsResponse parses an HTTP response from a GetAppLogsWithResponse call
func ParseGetAppLogsResponse(rsp *http.Response) (*GetAppLogsResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetAppLogsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest GetAppLogsResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 400:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON400 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 403:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON403 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 404:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON404 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseCreateEcrTokenResponse parses an HTTP response from a CreateEcrTokenWithResponse call
func ParseCreateEcrTokenResponse(rsp *http.Response) (*CreateEcrTokenResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;CreateEcrTokenResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest CreateEcrTokenResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}

// ParseGetUserOrgsResponse parses an HTTP response from a GetUserOrgsWithResponse call
func ParseGetUserOrgsResponse(rsp *http.Response) (*GetUserOrgsResponse, error) <span class="cov0" title="0">{
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() </span><span class="cov0" title="0">{ _ = rsp.Body.Close() }</span>()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := &amp;GetUserOrgsResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch </span>{
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 200:<span class="cov0" title="0">
                var dest GetUserOrgsResponseBody
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON200 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 401:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON401 = &amp;dest</span>

        case strings.Contains(rsp.Header.Get("Content-Type"), "json") &amp;&amp; rsp.StatusCode == 500:<span class="cov0" title="0">
                var dest ErrorResponse
                if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">response.JSON500 = &amp;dest</span>

        }

        <span class="cov0" title="0">return response, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/google/uuid"
        openapi_types "github.com/oapi-codegen/runtime/types"

        "github.com/fastertools/ftl-cli/internal/auth"
)

const (
        // DefaultAPIBaseURL is the default FTL API endpoint
        DefaultAPIBaseURL = "https://vnwyancgjj.execute-api.us-west-2.amazonaws.com"
)

// FTLClient wraps the generated API client with authentication
type FTLClient struct {
        client      *ClientWithResponses
        authManager *auth.Manager
        baseURL     string
}

// NewFTLClient creates a new FTL API client with authentication
func NewFTLClient(authManager *auth.Manager, baseURL string) (*FTLClient, error) <span class="cov8" title="1">{
        if baseURL == "" </span><span class="cov8" title="1">{
                baseURL = DefaultAPIBaseURL
        }</span>

        // Create HTTP client with auth interceptor
        <span class="cov8" title="1">httpClient := &amp;authHTTPClient{
                authManager: authManager,
                underlying: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }

        // Create the generated client
        client, err := NewClientWithResponses(baseURL, WithHTTPClient(httpClient))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create API client: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;FTLClient{
                client:      client,
                authManager: authManager,
                baseURL:     baseURL,
        }, nil</span>
}

// authHTTPClient adds authentication headers to requests
type authHTTPClient struct {
        authManager *auth.Manager
        underlying  *http.Client
}

// Do implements the HTTP client interface with authentication
func (c *authHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        // Get the auth token
        token, err := c.authManager.GetToken(req.Context())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auth token: %w", err)
        }</span>

        // Add authorization header
        <span class="cov8" title="1">req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))

        // Execute the request
        return c.underlying.Do(req)</span>
}

// Client returns the underlying generated client for direct access
func (c *FTLClient) Client() *ClientWithResponses <span class="cov8" title="1">{
        return c.client
}</span>

// parseUUID converts a string to an openapi UUID type
func parseUUID(s string) (openapi_types.UUID, error) <span class="cov8" title="1">{
        u, err := uuid.Parse(s)
        if err != nil </span><span class="cov8" title="1">{
                return openapi_types.UUID{}, err
        }</span>
        <span class="cov8" title="1">return openapi_types.UUID(u), nil</span>
}

// Apps API methods

// ListApps retrieves a list of applications
func (c *FTLClient) ListApps(ctx context.Context, params *ListAppsParams) (*ListAppsResponseBody, error) <span class="cov8" title="1">{
        resp, err := c.client.ListAppsWithResponse(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list apps: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.HTTPResponse.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API error: %s", string(resp.Body))
        }</span>

        <span class="cov8" title="1">if resp.JSON200 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected response format")
        }</span>

        <span class="cov8" title="1">return resp.JSON200, nil</span>
}

// CreateApp creates a new application
func (c *FTLClient) CreateApp(ctx context.Context, request CreateAppRequest) (*CreateAppResponseBody, error) <span class="cov8" title="1">{
        params := &amp;CreateAppParams{}
        resp, err := c.client.CreateAppWithResponse(ctx, params, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create app: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.HTTPResponse.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %s", string(resp.Body))
        }</span>

        <span class="cov8" title="1">if resp.JSON201 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected response format")
        }</span>

        <span class="cov8" title="1">return resp.JSON201, nil</span>
}

// GetApp retrieves details of a specific app
func (c *FTLClient) GetApp(ctx context.Context, appID string) (*App, error) <span class="cov8" title="1">{
        appUUID, err := parseUUID(appID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid app ID: %w", err)
        }</span>
        <span class="cov8" title="1">params := &amp;GetAppParams{}
        resp, err := c.client.GetAppWithResponse(ctx, appUUID, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get app: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.HTTPResponse.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %s", string(resp.Body))
        }</span>

        <span class="cov8" title="1">if resp.JSON200 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected response format")
        }</span>

        <span class="cov8" title="1">return resp.JSON200, nil</span>
}

// DeleteApp deletes an application
func (c *FTLClient) DeleteApp(ctx context.Context, appID string) error <span class="cov8" title="1">{
        appUUID, err := parseUUID(appID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid app ID: %w", err)
        }</span>
        <span class="cov8" title="1">params := &amp;DeleteAppParams{}
        resp, err := c.client.DeleteAppWithResponse(ctx, appUUID, params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete app: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.HTTPResponse.StatusCode != http.StatusAccepted &amp;&amp; resp.HTTPResponse.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                return fmt.Errorf("API error: %s", string(resp.Body))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Registry API methods

// CreateECRToken creates a temporary ECR authorization token
func (c *FTLClient) CreateECRToken(ctx context.Context, appID string, components []string) (*CreateEcrTokenResponseBody, error) <span class="cov0" title="0">{
        appUUID, err := parseUUID(appID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid app ID: %w", err)
        }</span>
        <span class="cov0" title="0">request := CreateEcrTokenRequest{
                AppId:      appUUID,
                Components: components,
        }
        params := &amp;CreateEcrTokenParams{}

        resp, err := c.client.CreateEcrTokenWithResponse(ctx, params, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create ECR token: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.HTTPResponse.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %s", string(resp.Body))
        }</span>

        <span class="cov0" title="0">if resp.JSON200 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected response format")
        }</span>

        <span class="cov0" title="0">return resp.JSON200, nil</span>
}

// Component API methods

// UpdateComponents updates the component list for an app
func (c *FTLClient) UpdateComponents(ctx context.Context, appID string, request UpdateComponentsRequest) (*UpdateComponentsResponseBody, error) <span class="cov0" title="0">{
        appUUID, err := parseUUID(appID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid app ID: %w", err)
        }</span>
        <span class="cov0" title="0">params := &amp;UpdateComponentsParams{}

        resp, err := c.client.UpdateComponentsWithResponse(ctx, appUUID, params, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update components: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.HTTPResponse.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %s", string(resp.Body))
        }</span>

        <span class="cov0" title="0">if resp.JSON200 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected response format")
        }</span>

        <span class="cov0" title="0">return resp.JSON200, nil</span>
}

// Deployment API methods

// CreateDeployment triggers a new deployment for an application
func (c *FTLClient) CreateDeployment(ctx context.Context, appID string, request CreateDeploymentRequest) (*CreateDeploymentResponseBody, error) <span class="cov0" title="0">{
        appUUID, err := parseUUID(appID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid app ID: %w", err)
        }</span>
        <span class="cov0" title="0">params := &amp;CreateDeploymentParams{}

        resp, err := c.client.CreateDeploymentWithResponse(ctx, appUUID, params, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create deployment: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.HTTPResponse.StatusCode != http.StatusAccepted </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %s", string(resp.Body))
        }</span>

        <span class="cov0" title="0">if resp.JSON202 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected response format")
        }</span>

        <span class="cov0" title="0">return resp.JSON202, nil</span>
}

// Organization API methods

// GetUserOrgs retrieves the organizations for the authenticated user
func (c *FTLClient) GetUserOrgs(ctx context.Context) (*GetUserOrgsResponseBody, error) <span class="cov0" title="0">{
        params := &amp;GetUserOrgsParams{}
        resp, err := c.client.GetUserOrgsWithResponse(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user orgs: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.HTTPResponse.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %s", string(resp.Body))
        }</span>

        <span class="cov0" title="0">if resp.JSON200 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected response format")
        }</span>

        <span class="cov0" title="0">return resp.JSON200, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/browser"
)

// Manager handles authentication operations
type Manager struct {
        store         CredentialStore
        oauthProvider OAuthProvider
        browserOpener BrowserOpener
        config        *LoginConfig
}

// defaultBrowserOpener implements BrowserOpener using the browser package
type defaultBrowserOpener struct{}

func (d *defaultBrowserOpener) OpenURL(url string) error <span class="cov0" title="0">{
        return browser.OpenURL(url)
}</span>

// NewManager creates a new authentication manager
func NewManager(store CredentialStore, config *LoginConfig) *Manager <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = &amp;LoginConfig{
                        AuthKitDomain: DefaultAuthKitDomain,
                        ClientID:      DefaultClientID,
                }
        }</span>

        <span class="cov8" title="1">return &amp;Manager{
                store:         store,
                oauthProvider: NewOAuthClient(config.AuthKitDomain, config.ClientID),
                browserOpener: &amp;defaultBrowserOpener{},
                config:        config,
        }</span>
}

// NewManagerWithProvider creates a new authentication manager with a custom OAuth provider
// This is primarily for testing but can be used for custom OAuth implementations
func NewManagerWithProvider(store CredentialStore, provider OAuthProvider, config *LoginConfig) *Manager <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = &amp;LoginConfig{
                        AuthKitDomain: DefaultAuthKitDomain,
                        ClientID:      DefaultClientID,
                }
        }</span>

        <span class="cov8" title="1">return &amp;Manager{
                store:         store,
                oauthProvider: provider,
                browserOpener: &amp;defaultBrowserOpener{},
                config:        config,
        }</span>
}

// NewManagerWithMocks creates a new authentication manager with all dependencies mocked
// This is specifically for testing to prevent any external interactions
func NewManagerWithMocks(store CredentialStore, provider OAuthProvider, browser BrowserOpener, config *LoginConfig) *Manager <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = &amp;LoginConfig{
                        AuthKitDomain: DefaultAuthKitDomain,
                        ClientID:      DefaultClientID,
                }
        }</span>

        // Always disable browser in tests, regardless of config
        <span class="cov8" title="1">config.NoBrowser = true

        return &amp;Manager{
                store:         store,
                oauthProvider: provider,
                browserOpener: browser,
                config:        config,
        }</span>
}

// StartDeviceFlow starts the OAuth device flow and returns device auth info
func (m *Manager) StartDeviceFlow(ctx context.Context) (*DeviceAuthResponse, error) <span class="cov8" title="1">{
        // Check if already logged in (unless force is set)
        if !m.config.Force </span><span class="cov8" title="1">{
                if creds, err := m.store.Load(); err == nil &amp;&amp; creds != nil </span><span class="cov8" title="1">{
                        if !creds.IsExpired() </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("already logged in")
                        }</span>
                        // Try to refresh if we have a refresh token
                        <span class="cov8" title="1">if creds.RefreshToken != "" </span><span class="cov8" title="1">{
                                if _, err := m.Refresh(ctx, creds); err == nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("already logged in (token refreshed)")
                                }</span>
                        }
                }
        }

        // Start device flow
        <span class="cov8" title="1">deviceAuth, err := m.oauthProvider.StartDeviceFlow(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to start device flow: %w", err)
        }</span>

        // Open browser if not disabled
        <span class="cov8" title="1">if !m.config.NoBrowser &amp;&amp; m.browserOpener != nil </span><span class="cov8" title="1">{
                _ = m.browserOpener.OpenURL(deviceAuth.VerificationURIComplete)
        }</span>

        <span class="cov8" title="1">return deviceAuth, nil</span>
}

// CompleteDeviceFlow completes the device flow authentication
func (m *Manager) CompleteDeviceFlow(ctx context.Context, deviceAuth *DeviceAuthResponse) (*Credentials, error) <span class="cov8" title="1">{
        // Poll for token
        interval := time.Duration(deviceAuth.Interval) * time.Second
        token, err := m.oauthProvider.PollForToken(ctx, deviceAuth.DeviceCode, interval)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to complete login: %w", err)
        }</span>

        // Create credentials
        <span class="cov8" title="1">creds := &amp;Credentials{
                AuthKitDomain: m.config.AuthKitDomain,
                AccessToken:   token.AccessToken,
                RefreshToken:  token.RefreshToken,
                ClientID:      m.config.ClientID,
        }

        // Calculate expiration time
        if token.ExpiresIn &gt; 0 </span><span class="cov8" title="1">{
                expiresAt := time.Now().Add(time.Duration(token.ExpiresIn) * time.Second)
                creds.ExpiresAt = &amp;expiresAt
        }</span>

        // Save credentials
        <span class="cov8" title="1">if err := m.store.Save(creds); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to save credentials: %w", err)
        }</span>

        <span class="cov8" title="1">return creds, nil</span>
}

// Login performs the complete OAuth device flow login
func (m *Manager) Login(ctx context.Context) (*Credentials, error) <span class="cov8" title="1">{
        deviceAuth, err := m.StartDeviceFlow(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m.CompleteDeviceFlow(ctx, deviceAuth)</span>
}

// Logout removes stored credentials
func (m *Manager) Logout() error <span class="cov8" title="1">{
        return m.store.Delete()
}</span>

// Status returns the current authentication status
func (m *Manager) Status() *AuthStatus <span class="cov8" title="1">{
        creds, err := m.store.Load()
        if err != nil || creds == nil </span><span class="cov8" title="1">{
                return &amp;AuthStatus{
                        LoggedIn: false,
                        Error:    err,
                }
        }</span>

        <span class="cov8" title="1">status := &amp;AuthStatus{
                LoggedIn:    true,
                Credentials: creds,
        }

        if creds.IsExpired() </span><span class="cov8" title="1">{
                status.NeedsRefresh = true
        }</span>

        <span class="cov8" title="1">return status</span>
}

// GetToken returns the current access token, refreshing if necessary
func (m *Manager) GetToken(ctx context.Context) (string, error) <span class="cov8" title="1">{
        creds, err := m.store.Load()
        if err != nil || creds == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("not logged in")
        }</span>

        // Check if token needs refresh
        <span class="cov8" title="1">if creds.IsExpired() </span><span class="cov8" title="1">{
                if creds.RefreshToken == "" </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("token expired and no refresh token available")
                }</span>
                <span class="cov8" title="1">refreshed, err := m.Refresh(ctx, creds)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to refresh token: %w", err)
                }</span>
                <span class="cov8" title="1">creds = refreshed</span>
        }

        <span class="cov8" title="1">return creds.AccessToken, nil</span>
}

// Refresh refreshes an expired access token
func (m *Manager) Refresh(ctx context.Context, creds *Credentials) (*Credentials, error) <span class="cov8" title="1">{
        if creds.RefreshToken == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no refresh token available")
        }</span>

        <span class="cov8" title="1">token, err := m.oauthProvider.RefreshToken(ctx, creds.RefreshToken)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to refresh token: %w", err)
        }</span>

        // Update credentials
        <span class="cov8" title="1">newCreds := &amp;Credentials{
                AuthKitDomain: creds.AuthKitDomain,
                AccessToken:   token.AccessToken,
                RefreshToken:  creds.RefreshToken, // Keep existing refresh token if not provided
                ClientID:      creds.ClientID,
        }

        // Update refresh token if provided
        if token.RefreshToken != "" </span><span class="cov8" title="1">{
                newCreds.RefreshToken = token.RefreshToken
        }</span>

        // Calculate expiration time
        <span class="cov8" title="1">if token.ExpiresIn &gt; 0 </span><span class="cov8" title="1">{
                expiresAt := time.Now().Add(time.Duration(token.ExpiresIn) * time.Second)
                newCreds.ExpiresAt = &amp;expiresAt
        }</span>

        // Save updated credentials
        <span class="cov8" title="1">if err := m.store.Save(newCreds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save refreshed credentials: %w", err)
        }</span>

        <span class="cov8" title="1">return newCreds, nil</span>
}

// GetOrRefreshToken gets a valid token, refreshing if necessary
func (m *Manager) GetOrRefreshToken(ctx context.Context) (string, error) <span class="cov8" title="1">{
        return m.GetToken(ctx)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"
)

// MockOAuthProvider is a mock implementation of OAuthProvider for testing
type MockOAuthProvider struct {
        mu sync.Mutex

        // StartDeviceFlow behavior
        StartDeviceFlowFunc  func(ctx context.Context) (*DeviceAuthResponse, error)
        StartDeviceFlowCalls []struct {
                Ctx context.Context
        }

        // PollForToken behavior
        PollForTokenFunc  func(ctx context.Context, deviceCode string, interval time.Duration) (*TokenResponse, error)
        PollForTokenCalls []struct {
                Ctx        context.Context
                DeviceCode string
                Interval   time.Duration
        }

        // RefreshToken behavior
        RefreshTokenFunc  func(ctx context.Context, refreshToken string) (*TokenResponse, error)
        RefreshTokenCalls []struct {
                Ctx          context.Context
                RefreshToken string
        }
}

// StartDeviceFlow implements OAuthProvider
func (m *MockOAuthProvider) StartDeviceFlow(ctx context.Context) (*DeviceAuthResponse, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.StartDeviceFlowCalls = append(m.StartDeviceFlowCalls, struct {
                Ctx context.Context
        }{
                Ctx: ctx,
        })

        if m.StartDeviceFlowFunc != nil </span><span class="cov8" title="1">{
                return m.StartDeviceFlowFunc(ctx)
        }</span>

        // Default response
        <span class="cov8" title="1">return &amp;DeviceAuthResponse{
                DeviceCode:      "mock-device-code",
                UserCode:        "MOCK-CODE",
                VerificationURI: "https://mock.auth/device",
                ExpiresIn:       600,
                Interval:        5,
        }, nil</span>
}

// PollForToken implements OAuthProvider
func (m *MockOAuthProvider) PollForToken(ctx context.Context, deviceCode string, interval time.Duration) (*TokenResponse, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.PollForTokenCalls = append(m.PollForTokenCalls, struct {
                Ctx        context.Context
                DeviceCode string
                Interval   time.Duration
        }{
                Ctx:        ctx,
                DeviceCode: deviceCode,
                Interval:   interval,
        })

        if m.PollForTokenFunc != nil </span><span class="cov8" title="1">{
                return m.PollForTokenFunc(ctx, deviceCode, interval)
        }</span>

        // Default response
        <span class="cov8" title="1">return &amp;TokenResponse{
                AccessToken:  "mock-access-token",
                RefreshToken: "mock-refresh-token",
                ExpiresIn:    3600,
                TokenType:    "Bearer",
        }, nil</span>
}

// RefreshToken implements OAuthProvider
func (m *MockOAuthProvider) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.RefreshTokenCalls = append(m.RefreshTokenCalls, struct {
                Ctx          context.Context
                RefreshToken string
        }{
                Ctx:          ctx,
                RefreshToken: refreshToken,
        })

        if m.RefreshTokenFunc != nil </span><span class="cov8" title="1">{
                return m.RefreshTokenFunc(ctx, refreshToken)
        }</span>

        // Default response
        <span class="cov8" title="1">return &amp;TokenResponse{
                AccessToken:  "mock-refreshed-token",
                RefreshToken: "mock-new-refresh-token",
                ExpiresIn:    3600,
                TokenType:    "Bearer",
        }, nil</span>
}

// Reset clears all recorded calls
func (m *MockOAuthProvider) Reset() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.StartDeviceFlowCalls = nil
        m.PollForTokenCalls = nil
        m.RefreshTokenCalls = nil
}</span>

// Ensure MockOAuthProvider implements OAuthProvider
var _ OAuthProvider = (*MockOAuthProvider)(nil)

// MockHTTPClient is a mock implementation of HTTPClient for testing
type MockHTTPClient struct {
        mu sync.Mutex

        // Do behavior
        DoFunc  func(req *http.Request) (*http.Response, error)
        DoCalls []struct {
                Req *http.Request
        }
}

// Do implements HTTPClient
func (m *MockHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.DoCalls = append(m.DoCalls, struct {
                Req *http.Request
        }{
                Req: req,
        })

        if m.DoFunc != nil </span><span class="cov8" title="1">{
                return m.DoFunc(req)
        }</span>

        // Default error response
        <span class="cov8" title="1">return nil, fmt.Errorf("mock HTTP client: no DoFunc configured")</span>
}

// Reset clears all recorded calls
func (m *MockHTTPClient) Reset() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.DoCalls = nil
}</span>

// Ensure MockHTTPClient implements HTTPClient
var _ HTTPClient = (*MockHTTPClient)(nil)

// MockBrowserOpener is a mock implementation of BrowserOpener for testing
type MockBrowserOpener struct {
        mu sync.Mutex

        // OpenURL behavior
        OpenURLFunc  func(url string) error
        OpenURLCalls []struct {
                URL string
        }
}

// OpenURL implements BrowserOpener
func (m *MockBrowserOpener) OpenURL(url string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.OpenURLCalls = append(m.OpenURLCalls, struct {
                URL string
        }{
                URL: url,
        })

        if m.OpenURLFunc != nil </span><span class="cov8" title="1">{
                return m.OpenURLFunc(url)
        }</span>

        // Default: do nothing (no browser opened in tests)
        <span class="cov8" title="1">return nil</span>
}

// Reset clears all recorded calls
func (m *MockBrowserOpener) Reset() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.OpenURLCalls = nil
}</span>

// Ensure MockBrowserOpener implements BrowserOpener
var _ BrowserOpener = (*MockBrowserOpener)(nil)

// MockBuilder provides a fluent interface for building test scenarios
type MockBuilder struct {
        provider *MockOAuthProvider
        store    *MockStore
        browser  *MockBrowserOpener
}

// NewMockBuilder creates a new mock builder
func NewMockBuilder() *MockBuilder <span class="cov8" title="1">{
        return &amp;MockBuilder{
                provider: &amp;MockOAuthProvider{},
                store:    NewMockStore(nil, nil),
                browser:  &amp;MockBrowserOpener{},
        }
}</span>

// WithDeviceFlow configures the device flow response
func (b *MockBuilder) WithDeviceFlow(resp *DeviceAuthResponse, err error) *MockBuilder <span class="cov8" title="1">{
        b.provider.StartDeviceFlowFunc = func(ctx context.Context) (*DeviceAuthResponse, error) </span><span class="cov8" title="1">{
                return resp, err
        }</span>
        <span class="cov8" title="1">return b</span>
}

// WithTokenPolling configures the token polling behavior
// This simulates the entire polling loop, handling authorization_pending internally
func (b *MockBuilder) WithTokenPolling(responses []interface{}) *MockBuilder <span class="cov8" title="1">{
        b.provider.PollForTokenFunc = func(ctx context.Context, deviceCode string, interval time.Duration) (*TokenResponse, error) </span><span class="cov8" title="1">{
                // Simulate polling with the provided responses
                for _, resp := range responses </span><span class="cov8" title="1">{
                        // Check context cancellation
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, ctx.Err()</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">switch v := resp.(type) </span>{
                        case *TokenResponse:<span class="cov8" title="1">
                                // Success - return the token
                                return v, nil</span>
                        case *TokenError:<span class="cov8" title="1">
                                // Handle different error types
                                if v.IsAuthorizationPending() </span><span class="cov8" title="1">{
                                        // Continue to next response (simulating continued polling)
                                        time.Sleep(10 * time.Millisecond) // Small delay to simulate polling
                                        continue</span>
                                }
                                <span class="cov8" title="1">if v.IsSlowDown() </span><span class="cov8" title="1">{
                                        // Continue but with longer delay
                                        time.Sleep(20 * time.Millisecond)
                                        continue</span>
                                }
                                // Other errors terminate polling
                                <span class="cov8" title="1">return nil, v</span>
                        case error:<span class="cov8" title="1">
                                return nil, v</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("unexpected response type: %T", v)</span>
                        }
                }

                // If we get here, we ran out of responses while still pending
                <span class="cov0" title="0">return nil, fmt.Errorf("polling incomplete: still pending after all responses")</span>
        }
        <span class="cov8" title="1">return b</span>
}

// WithRefreshToken configures the refresh token response
func (b *MockBuilder) WithRefreshToken(resp *TokenResponse, err error) *MockBuilder <span class="cov8" title="1">{
        b.provider.RefreshTokenFunc = func(ctx context.Context, refreshToken string) (*TokenResponse, error) </span><span class="cov8" title="1">{
                return resp, err
        }</span>
        <span class="cov8" title="1">return b</span>
}

// WithStoredCredentials configures the stored credentials
func (b *MockBuilder) WithStoredCredentials(creds *Credentials) *MockBuilder <span class="cov8" title="1">{
        b.store = NewMockStore(creds, nil)
        return b
}</span>

// WithStoreError configures a store error
func (b *MockBuilder) WithStoreError(err error) *MockBuilder <span class="cov8" title="1">{
        b.store = NewMockStore(nil, err)
        return b
}</span>

// Build creates a Manager with the configured mocks
func (b *MockBuilder) Build() (*Manager, *MockOAuthProvider, *MockStore) <span class="cov8" title="1">{
        // Use NewManagerWithMocks to ensure browser is mocked
        config := &amp;LoginConfig{
                NoBrowser: true, // Always disable browser in tests
        }
        manager := NewManagerWithMocks(b.store, b.provider, b.browser, config)
        return manager, b.provider, b.store
}</span>

// TestHelpers provides utility functions for tests
type TestHelpers struct{}

// NewTestHelpers creates test helpers
func NewTestHelpers() *TestHelpers <span class="cov8" title="1">{
        return &amp;TestHelpers{}
}</span>

// timePtr returns a pointer to a time value
func timePtr(t time.Time) *time.Time <span class="cov8" title="1">{
        return &amp;t
}</span>

// ExpiredCredentials creates expired test credentials
func (h *TestHelpers) ExpiredCredentials() *Credentials <span class="cov8" title="1">{
        return &amp;Credentials{
                AuthKitDomain: "test.auth",
                AccessToken:   "expired-token",
                RefreshToken:  "refresh-token",
                ExpiresAt:     timePtr(time.Now().Add(-time.Hour)),
        }
}</span>

// ValidCredentials creates valid test credentials
func (h *TestHelpers) ValidCredentials() *Credentials <span class="cov8" title="1">{
        return &amp;Credentials{
                AuthKitDomain: "test.auth",
                AccessToken:   "valid-token",
                RefreshToken:  "refresh-token",
                ExpiresAt:     timePtr(time.Now().Add(time.Hour)),
        }
}</span>

// DeviceAuthResponse creates a test device auth response
func (h *TestHelpers) DeviceAuthResponse() *DeviceAuthResponse <span class="cov8" title="1">{
        return &amp;DeviceAuthResponse{
                DeviceCode:              "device-123",
                UserCode:                "USER-123",
                VerificationURI:         "https://auth.example.com/device",
                VerificationURIComplete: "https://auth.example.com/device?code=USER-123",
                ExpiresIn:               600,
                Interval:                5,
        }
}</span>

// TokenResponse creates a test token response
func (h *TestHelpers) TokenResponse() *TokenResponse <span class="cov8" title="1">{
        return &amp;TokenResponse{
                AccessToken:  "access-token",
                RefreshToken: "refresh-token",
                ExpiresIn:    3600,
                TokenType:    "Bearer",
        }
}</span>

// AuthorizationPendingError creates an authorization pending error
func (h *TestHelpers) AuthorizationPendingError() *TokenError <span class="cov8" title="1">{
        return &amp;TokenError{
                ErrorCode: "authorization_pending",
        }
}</span>

// SlowDownError creates a slow down error
func (h *TestHelpers) SlowDownError() *TokenError <span class="cov8" title="1">{
        return &amp;TokenError{
                ErrorCode: "slow_down",
        }
}</span>

// ExpiredTokenError creates an expired token error
func (h *TestHelpers) ExpiredTokenError() *TokenError <span class="cov8" title="1">{
        return &amp;TokenError{
                ErrorCode:        "expired_token",
                ErrorDescription: "The device code has expired",
        }
}</span>

// AccessDeniedError creates an access denied error
func (h *TestHelpers) AccessDeniedError() *TokenError <span class="cov8" title="1">{
        return &amp;TokenError{
                ErrorCode:        "access_denied",
                ErrorDescription: "The user denied the request",
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"
)

// OAuthClient handles OAuth device flow authentication
type OAuthClient struct {
        httpClient    HTTPClient
        authKitDomain string
        clientID      string
}

// Ensure OAuthClient implements OAuthProvider
var _ OAuthProvider = (*OAuthClient)(nil)

// NewOAuthClient creates a new OAuth client
func NewOAuthClient(authKitDomain, clientID string) *OAuthClient <span class="cov8" title="1">{
        if authKitDomain == "" </span><span class="cov8" title="1">{
                authKitDomain = DefaultAuthKitDomain
        }</span>
        <span class="cov8" title="1">if clientID == "" </span><span class="cov8" title="1">{
                clientID = DefaultClientID
        }</span>

        <span class="cov8" title="1">return &amp;OAuthClient{
                httpClient:    &amp;http.Client{Timeout: 30 * time.Second},
                authKitDomain: authKitDomain,
                clientID:      clientID,
        }</span>
}

// StartDeviceFlow initiates the OAuth device flow
func (c *OAuthClient) StartDeviceFlow(ctx context.Context) (*DeviceAuthResponse, error) <span class="cov8" title="1">{
        endpoint := fmt.Sprintf("https://%s/oauth2/device_authorization", c.authKitDomain)

        data := url.Values{
                "client_id": {c.clientID},
                "scope":     {"openid profile email offline_access"},
        }

        req, err := http.NewRequestWithContext(ctx, "POST", endpoint, bytes.NewBufferString(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to request device authorization: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("device authorization failed (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">var authResp DeviceAuthResponse
        if err := json.Unmarshal(body, &amp;authResp); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        // Set default interval if not provided
        <span class="cov8" title="1">if authResp.Interval == 0 </span><span class="cov8" title="1">{
                authResp.Interval = 5
        }</span>

        <span class="cov8" title="1">return &amp;authResp, nil</span>
}

// PollForToken polls the token endpoint until authentication completes
func (c *OAuthClient) PollForToken(ctx context.Context, deviceCode string, interval time.Duration) (*TokenResponse, error) <span class="cov8" title="1">{
        endpoint := fmt.Sprintf("https://%s/oauth2/token", c.authKitDomain)

        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        deadline := time.Now().Add(LoginTimeout)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil, ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if time.Now().After(deadline) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("login timeout exceeded")
                        }</span>

                        <span class="cov8" title="1">token, err := c.requestToken(ctx, endpoint, deviceCode)
                        if err != nil </span><span class="cov8" title="1">{
                                // Check if it's a token error
                                if tokenErr, ok := err.(*TokenError); ok </span><span class="cov8" title="1">{
                                        if tokenErr.IsAuthorizationPending() </span><span class="cov8" title="1">{
                                                // Continue polling
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tokenErr.IsSlowDown() </span><span class="cov8" title="1">{
                                                // Increase interval
                                                ticker.Reset(interval * 2)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tokenErr.IsExpired() </span><span class="cov8" title="1">{
                                                return nil, fmt.Errorf("device code expired, please try again")
                                        }</span>
                                }
                                <span class="cov8" title="1">return nil, err</span>
                        }

                        <span class="cov8" title="1">return token, nil</span>
                }
        }
}

// requestToken makes a single token request
func (c *OAuthClient) requestToken(ctx context.Context, endpoint, deviceCode string) (*TokenResponse, error) <span class="cov8" title="1">{
        data := url.Values{
                "grant_type":  {"urn:ietf:params:oauth:grant-type:device_code"},
                "device_code": {deviceCode},
                "client_id":   {c.clientID},
        }

        req, err := http.NewRequestWithContext(ctx, "POST", endpoint, bytes.NewBufferString(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to request token: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        // Check for error response
        <span class="cov8" title="1">if resp.StatusCode == http.StatusBadRequest </span><span class="cov8" title="1">{
                var tokenErr TokenError
                if err := json.Unmarshal(body, &amp;tokenErr); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse error response: %w", err)
                }</span>
                <span class="cov8" title="1">return nil, &amp;tokenErr</span>
        }

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token request failed (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">var tokenResp TokenResponse
        if err := json.Unmarshal(body, &amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;tokenResp, nil</span>
}

// RefreshToken refreshes an expired access token
func (c *OAuthClient) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) <span class="cov8" title="1">{
        endpoint := fmt.Sprintf("https://%s/oauth2/token", c.authKitDomain)

        data := url.Values{
                "grant_type":    {"refresh_token"},
                "refresh_token": {refreshToken},
                "client_id":     {c.clientID},
        }

        req, err := http.NewRequestWithContext(ctx, "POST", endpoint, bytes.NewBufferString(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to refresh token: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("token refresh failed (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">var tokenResp TokenResponse
        if err := json.Unmarshal(body, &amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;tokenResp, nil</span>
}

// Error implements the error interface for TokenError
func (e *TokenError) Error() string <span class="cov8" title="1">{
        if e.ErrorDescription != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %s", e.ErrorCode, e.ErrorDescription)
        }</span>
        <span class="cov8" title="1">return e.ErrorCode</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "encoding/json"
        "fmt"

        "github.com/zalando/go-keyring"
)

// CredentialStore provides secure storage for authentication credentials
type CredentialStore interface {
        // Load retrieves stored credentials
        Load() (*Credentials, error)
        // Save stores credentials securely
        Save(creds *Credentials) error
        // Delete removes stored credentials
        Delete() error
        // Exists checks if credentials are stored
        Exists() bool
}

// KeyringStore implements CredentialStore using OS keyring
type KeyringStore struct{}

// NewKeyringStore creates a new keyring-based credential store
func NewKeyringStore() (*KeyringStore, error) <span class="cov8" title="1">{
        // The zalando keyring library handles backend selection automatically
        return &amp;KeyringStore{}, nil
}</span>

// Load retrieves stored credentials from the keyring
func (s *KeyringStore) Load() (*Credentials, error) <span class="cov8" title="1">{
        data, err := keyring.Get(KeyringService, KeyringUsername)
        if err != nil </span><span class="cov8" title="1">{
                if err == keyring.ErrNotFound </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("not logged in")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load credentials: %w", err)</span>
        }

        <span class="cov8" title="1">var creds Credentials
        if err := json.Unmarshal([]byte(data), &amp;creds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse credentials: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;creds, nil</span>
}

// Save stores credentials in the keyring
func (s *KeyringStore) Save(creds *Credentials) error <span class="cov8" title="1">{
        if creds == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot save nil credentials")
        }</span>

        <span class="cov8" title="1">data, err := json.Marshal(creds)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal credentials: %w", err)
        }</span>

        <span class="cov8" title="1">if err := keyring.Set(KeyringService, KeyringUsername, string(data)); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save credentials: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete removes stored credentials from the keyring
func (s *KeyringStore) Delete() error <span class="cov8" title="1">{
        err := keyring.Delete(KeyringService, KeyringUsername)
        if err != nil &amp;&amp; err != keyring.ErrNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete credentials: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Exists checks if credentials are stored
func (s *KeyringStore) Exists() bool <span class="cov8" title="1">{
        _, err := keyring.Get(KeyringService, KeyringUsername)
        return err == nil
}</span>

// fileKeyringPrompt provides a password for the file-based keyring fallback
func fileKeyringPrompt(prompt string) (string, error) <span class="cov8" title="1">{
        // In production, this would prompt the user
        // For now, use a static key derived from the service name
        // This is only used as a fallback when OS keyring is unavailable
        return "ftl-cli-keyring-encryption-key", nil
}</span>

// MockStore implements CredentialStore for testing
type MockStore struct {
        creds *Credentials
        err   error
}

// NewMockStore creates a mock credential store for testing
func NewMockStore(creds *Credentials, err error) *MockStore <span class="cov8" title="1">{
        return &amp;MockStore{creds: creds, err: err}
}</span>

// Load returns the mock credentials
func (m *MockStore) Load() (*Credentials, error) <span class="cov8" title="1">{
        if m.err != nil </span><span class="cov8" title="1">{
                return nil, m.err
        }</span>
        <span class="cov8" title="1">return m.creds, nil</span>
}

// Save stores the mock credentials
func (m *MockStore) Save(creds *Credentials) error <span class="cov8" title="1">{
        if m.err != nil </span><span class="cov8" title="1">{
                return m.err
        }</span>
        <span class="cov8" title="1">m.creds = creds
        return nil</span>
}

// Delete clears the mock credentials
func (m *MockStore) Delete() error <span class="cov8" title="1">{
        if m.err != nil </span><span class="cov8" title="1">{
                return m.err
        }</span>
        <span class="cov8" title="1">m.creds = nil
        return nil</span>
}

// Exists checks if mock credentials exist
func (m *MockStore) Exists() bool <span class="cov8" title="1">{
        return m.creds != nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "time"
)

// Credentials represents stored authentication credentials
type Credentials struct {
        // AuthKit domain used for authentication
        AuthKitDomain string `json:"authkit_domain"`
        // OAuth access token
        AccessToken string `json:"access_token"`
        // OAuth refresh token for renewing access
        RefreshToken string `json:"refresh_token,omitempty"`
        // Token expiration time
        ExpiresAt *time.Time `json:"expires_at,omitempty"`
        // Client ID used for authentication
        ClientID string `json:"client_id,omitempty"`
}

// IsExpired checks if the access token has expired
func (c *Credentials) IsExpired() bool <span class="cov8" title="1">{
        if c.ExpiresAt == nil </span><span class="cov8" title="1">{
                return false // No expiry means token doesn't expire
        }</span>
        <span class="cov8" title="1">return time.Now().After(*c.ExpiresAt)</span>
}

// TimeUntilExpiry returns the duration until token expiry
func (c *Credentials) TimeUntilExpiry() time.Duration <span class="cov8" title="1">{
        if c.ExpiresAt == nil </span><span class="cov8" title="1">{
                return time.Duration(0) // No expiry
        }</span>
        <span class="cov8" title="1">return time.Until(*c.ExpiresAt)</span>
}

// AuthStatus represents the current authentication status
type AuthStatus struct {
        LoggedIn     bool
        Credentials  *Credentials
        Error        error
        NeedsRefresh bool
}

// DeviceAuthResponse represents the response from device authorization endpoint
type DeviceAuthResponse struct {
        DeviceCode              string `json:"device_code"`
        UserCode                string `json:"user_code"`
        VerificationURI         string `json:"verification_uri"`
        VerificationURIComplete string `json:"verification_uri_complete"`
        ExpiresIn               int    `json:"expires_in"`
        Interval                int    `json:"interval,omitempty"`
}

// TokenResponse represents the response from token endpoint
type TokenResponse struct {
        AccessToken  string `json:"access_token"`
        TokenType    string `json:"token_type"`
        ExpiresIn    int    `json:"expires_in,omitempty"`
        RefreshToken string `json:"refresh_token,omitempty"`
        IDToken      string `json:"id_token,omitempty"`
}

// TokenError represents an error response from token endpoint
type TokenError struct {
        ErrorCode        string `json:"error"`
        ErrorDescription string `json:"error_description,omitempty"`
}

// IsAuthorizationPending checks if the error indicates pending authorization
func (e *TokenError) IsAuthorizationPending() bool <span class="cov8" title="1">{
        return e.ErrorCode == "authorization_pending"
}</span>

// IsSlowDown checks if we should slow down polling
func (e *TokenError) IsSlowDown() bool <span class="cov8" title="1">{
        return e.ErrorCode == "slow_down"
}</span>

// IsExpired checks if the device code has expired
func (e *TokenError) IsExpired() bool <span class="cov8" title="1">{
        return e.ErrorCode == "expired_token"
}</span>

// LoginConfig contains configuration for the login process
type LoginConfig struct {
        // Don't open browser automatically
        NoBrowser bool
        // Override AuthKit domain (for testing)
        AuthKitDomain string
        // Override OAuth client ID (for testing)
        ClientID string
        // Force re-authentication even if already logged in
        Force bool
}

// Constants for OAuth configuration
const (
        // Default OAuth client ID for FTL authentication
        DefaultClientID = "client_01K2ADMPRAFT9X83PFVJBQ6T49"
        // Default AuthKit domain for authentication
        DefaultAuthKitDomain = "divine-lion-50-staging.authkit.app"
        // Maximum time to wait for login completion
        LoginTimeout = 30 * time.Minute
        // Keyring service name
        KeyringService = "ftl-cli"
        // Keyring username
        KeyringUsername = "default"
)
</pre>
		
		<pre class="file" id="file8" style="display: none">package cli

import (
        "fmt"
        "strings"

        "github.com/AlecAivazis/survey/v2"
        "github.com/spf13/cobra"

        "github.com/fastertools/ftl-cli/internal/scaffold"
)

// AddOptions holds options for the add command
type AddOptions struct {
        Name     string
        Language string
}

// newAddCmd creates the add command
func newAddCmd() *cobra.Command <span class="cov8" title="1">{
        opts := &amp;AddOptions{}

        cmd := &amp;cobra.Command{
                Use:   "add [name]",
                Short: "Add a new component to your FTL project",
                Long: `Add a new component to your FTL project.

This command scaffolds a new MCP tool component in your chosen language,
including all necessary files, build configuration, and example code.

Supported languages:
  - rust       Rust with ftl-sdk
  - typescript TypeScript with ftl-sdk and Zod
  - python     Python with ftl-sdk and Pydantic
  - go         Go with ftl-sdk-go

Examples:
  # Interactive mode
  ftl add

  # With component name
  ftl add my-tool

  # With name and language
  ftl add my-tool --language rust`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                opts.Name = args[0]
                        }</span>
                        <span class="cov0" title="0">return runAdd(opts)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;opts.Language, "language", "l", "", "programming language (rust, typescript, python, go)")

        return cmd</span>
}

func runAdd(opts *AddOptions) error <span class="cov8" title="1">{
        // Create scaffolder
        scaffolder, err := scaffold.NewScaffolder()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize scaffolder: %w", err)
        }</span>

        // Get component name if not provided
        <span class="cov8" title="1">if opts.Name == "" </span><span class="cov0" title="0">{
                prompt := &amp;survey.Input{
                        Message: "Component name:",
                        Help:    "The name of your component (lowercase, hyphens allowed)",
                }
                if err := survey.AskOne(prompt, &amp;opts.Name, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Validate component name
        <span class="cov8" title="1">if err := scaffold.ValidateComponentName(opts.Name); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get language if not provided
        <span class="cov8" title="1">if opts.Language == "" </span><span class="cov0" title="0">{
                languageOptions := []string{
                        "rust       - High-performance systems language",
                        "typescript - Type-safe JavaScript",
                        "python     - Versatile scripting language",
                        "go         - Simple and efficient",
                }

                prompt := &amp;survey.Select{
                        Message: "Select programming language:",
                        Options: languageOptions,
                        Default: languageOptions[0],
                }

                var choice string
                if err := survey.AskOne(prompt, &amp;choice); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Extract language from choice
                <span class="cov0" title="0">opts.Language = strings.Fields(choice)[0]</span>
        }

        // Validate language
        <span class="cov8" title="1">validLanguages := scaffolder.ListLanguages()
        found := false
        for _, lang := range validLanguages </span><span class="cov8" title="1">{
                if lang == opts.Language </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid language '%s': must be one of %v", opts.Language, validLanguages)
        }</span>

        <span class="cov8" title="1">Info("Creating %s component '%s'", opts.Language, opts.Name)

        // Generate the component
        if err := scaffolder.GenerateComponent(opts.Name, opts.Language); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate component: %w", err)
        }</span>

        // Print success message
        <span class="cov8" title="1">printSuccessMessage(opts.Name, opts.Language)

        return nil</span>
}

func printSuccessMessage(name, language string) <span class="cov8" title="1">{
        // Determine main file based on language
        var mainFile string
        switch language </span>{
        case "rust":<span class="cov8" title="1">
                mainFile = fmt.Sprintf("%s/src/lib.rs", name)</span>
        case "typescript":<span class="cov8" title="1">
                mainFile = fmt.Sprintf("%s/src/index.ts", name)</span>
        case "python":<span class="cov8" title="1">
                mainFile = fmt.Sprintf("%s/src/main.py", name)</span>
        case "go":<span class="cov8" title="1">
                mainFile = fmt.Sprintf("%s/main.go", name)</span>
        }

        <span class="cov8" title="1">Success("Component '%s' created successfully!", name)
        fmt.Println()
        fmt.Println("📁 Component structure:")
        fmt.Printf("  %s/\n", name)
        fmt.Printf("  ├── %s\n", getMainFileName(language))
        fmt.Printf("  ├── Makefile\n")
        fmt.Printf("  └── %s\n", getConfigFileName(language))
        fmt.Println()
        fmt.Printf("💡 Edit %s to implement your tool logic\n", mainFile)
        fmt.Println()
        fmt.Println("🔨 Next steps:")
        fmt.Println("  1. cd", name)
        fmt.Println("  2. Edit the source files to implement your tools")
        fmt.Println("  3. Run 'make build' to compile")
        fmt.Println("  4. Return to project root and run 'ftl build'")
        fmt.Println("  5. Run 'ftl up' to start the MCP server")
        fmt.Println()
        fmt.Println("📚 Learn more about the FTL SDK for", language+":")
        fmt.Printf("  https://github.com/fastertools/ftl-sdk-%s\n", getSdkSuffix(language))</span>
}

func getMainFileName(language string) string <span class="cov8" title="1">{
        switch language </span>{
        case "rust":<span class="cov8" title="1">
                return "src/lib.rs"</span>
        case "typescript":<span class="cov8" title="1">
                return "src/index.ts"</span>
        case "python":<span class="cov8" title="1">
                return "src/main.py"</span>
        case "go":<span class="cov8" title="1">
                return "main.go"</span>
        default:<span class="cov8" title="1">
                return "main"</span>
        }
}

func getConfigFileName(language string) string <span class="cov8" title="1">{
        switch language </span>{
        case "rust":<span class="cov8" title="1">
                return "Cargo.toml"</span>
        case "typescript":<span class="cov8" title="1">
                return "package.json"</span>
        case "python":<span class="cov8" title="1">
                return "pyproject.toml"</span>
        case "go":<span class="cov8" title="1">
                return "go.mod"</span>
        default:<span class="cov8" title="1">
                return "config"</span>
        }
}

func getSdkSuffix(language string) string <span class="cov8" title="1">{
        switch language </span>{
        case "rust":<span class="cov8" title="1">
                return "rust"</span>
        case "typescript":<span class="cov8" title="1">
                return "js"</span>
        case "python":<span class="cov8" title="1">
                return "python"</span>
        case "go":<span class="cov8" title="1">
                return "go"</span>
        default:<span class="cov8" title="1">
                return language</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cli

import (
        "context"
        "fmt"
        "time"

        "github.com/fastertools/ftl-cli/internal/auth"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

func newAuthCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "auth",
                Short: "Manage authentication",
                Long:  `Manage authentication for FTL platform and registries.`,
        }

        // Add subcommands
        cmd.AddCommand(
                newAuthLoginCmd(),
                newAuthLogoutCmd(),
                newAuthStatusCmd(),
        )

        return cmd
}</span>

func newAuthLoginCmd() *cobra.Command <span class="cov8" title="1">{
        var noBrowser bool
        var force bool
        var authKitDomain string

        cmd := &amp;cobra.Command{
                Use:   "login",
                Short: "Login to FTL platform",
                Long:  `Authenticate with FTL platform using OAuth device flow.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Create credential store
                        store, err := auth.NewKeyringStore()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to initialize credential store: %w", err)
                        }</span>

                        // Create auth manager
                        <span class="cov0" title="0">config := &amp;auth.LoginConfig{
                                NoBrowser:     noBrowser,
                                Force:         force,
                                AuthKitDomain: authKitDomain,
                        }
                        if authKitDomain == "" </span><span class="cov0" title="0">{
                                config.AuthKitDomain = auth.DefaultAuthKitDomain
                        }</span>

                        <span class="cov0" title="0">manager := auth.NewManager(store, config)

                        // Print login header
                        fmt.Printf("→ Logging in to FTL Engine (%s)\n\n", config.AuthKitDomain)

                        // Perform login
                        ctx, cancel := context.WithTimeout(context.Background(), auth.LoginTimeout)
                        defer cancel()

                        // Check if already logged in
                        if !force </span><span class="cov0" title="0">{
                                if status := manager.Status(); status.LoggedIn &amp;&amp; !status.NeedsRefresh </span><span class="cov0" title="0">{
                                        color.Green("✓ Already logged in")
                                        return nil
                                }</span>
                        }

                        // Start device flow
                        <span class="cov0" title="0">deviceAuth, err := manager.StartDeviceFlow(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to start authentication: %w", err)
                        }</span>

                        // Display instructions
                        <span class="cov0" title="0">fmt.Println("🌐 To complete login, visit:")
                        color.Cyan("   %s", deviceAuth.VerificationURIComplete)
                        fmt.Println()
                        fmt.Println("📋 Or manually enter code:")
                        color.Yellow("   %s", deviceAuth.UserCode)
                        fmt.Println()

                        if !noBrowser </span><span class="cov0" title="0">{
                                fmt.Println("🚀 Opening browser...")
                        }</span>

                        // Complete login
                        <span class="cov0" title="0">creds, err := manager.CompleteDeviceFlow(ctx, deviceAuth)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("login failed: %w", err)
                        }</span>

                        // Success
                        <span class="cov0" title="0">fmt.Println()
                        color.Green("✅ Successfully logged in!")

                        if creds.ExpiresAt != nil </span><span class="cov0" title="0">{
                                duration := time.Until(*creds.ExpiresAt)
                                fmt.Printf("   Access token valid for %dh %dm\n",
                                        int(duration.Hours()),
                                        int(duration.Minutes())%60)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;noBrowser, "no-browser", false, "Don't open browser automatically")
        cmd.Flags().BoolVar(&amp;force, "force", false, "Force re-authentication even if already logged in")
        cmd.Flags().StringVar(&amp;authKitDomain, "auth-domain", "", "Override AuthKit domain (for testing)")

        return cmd</span>
}

func newAuthLogoutCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "logout",
                Short: "Logout from FTL platform",
                Long:  `Remove stored authentication credentials.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Create credential store
                        store, err := auth.NewKeyringStore()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to initialize credential store: %w", err)
                        }</span>

                        // Create auth manager
                        <span class="cov0" title="0">manager := auth.NewManager(store, nil)

                        // Perform logout
                        if err := manager.Logout(); err != nil </span><span class="cov0" title="0">{
                                // Check if not logged in
                                if err.Error() == "not logged in" </span><span class="cov0" title="0">{
                                        color.Yellow("⚠️  Not logged in")
                                        return nil
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("logout failed: %w", err)</span>
                        }

                        <span class="cov0" title="0">color.Green("✅ Successfully logged out")
                        return nil</span>
                },
        }
}

func newAuthStatusCmd() *cobra.Command <span class="cov8" title="1">{
        var showToken bool

        cmd := &amp;cobra.Command{
                Use:   "status",
                Short: "Show authentication status",
                Long:  `Display current authentication status and token information.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Create credential store
                        store, err := auth.NewKeyringStore()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to initialize credential store: %w", err)
                        }</span>

                        // Create auth manager
                        <span class="cov0" title="0">manager := auth.NewManager(store, nil)

                        // Get status
                        status := manager.Status()

                        // Display status
                        color.Cyan("→ Authentication Status\n")
                        fmt.Println()

                        if !status.LoggedIn </span><span class="cov0" title="0">{
                                fmt.Println("🔐 Not logged in")
                                fmt.Println()
                                fmt.Printf("Run %s to authenticate\n", color.CyanString("ftl auth login"))
                                return nil
                        }</span>

                        // Show logged in status
                        <span class="cov0" title="0">color.Green("✅ Logged in")
                        fmt.Println()

                        if status.Credentials != nil </span><span class="cov0" title="0">{
                                creds := status.Credentials

                                // Show domain
                                fmt.Printf("AuthKit Domain: %s\n", color.CyanString(creds.AuthKitDomain))

                                // Show token status
                                if creds.ExpiresAt != nil </span><span class="cov0" title="0">{
                                        if creds.IsExpired() </span><span class="cov0" title="0">{
                                                color.Yellow("Access Token: ⚠️  Expired")
                                                if creds.RefreshToken != "" </span><span class="cov0" title="0">{
                                                        fmt.Println("              (will auto-refresh on next use)")
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                duration := time.Until(*creds.ExpiresAt)
                                                hours := int(duration.Hours())
                                                minutes := int(duration.Minutes()) % 60

                                                fmt.Printf("Access Token: Valid for %s\n",
                                                        color.GreenString("%dh %dm", hours, minutes))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        color.Green("Access Token: Valid")
                                }</span>

                                // Show refresh token status
                                <span class="cov0" title="0">if creds.RefreshToken != "" </span><span class="cov0" title="0">{
                                        color.Green("Refresh Token: Available")
                                }</span>

                                // Show actual token if requested
                                <span class="cov0" title="0">if showToken </span><span class="cov0" title="0">{
                                        fmt.Println()
                                        fmt.Println("Access Token:")
                                        fmt.Println(creds.AccessToken)
                                }</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;showToken, "show-token", false, "Display the actual access token")
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"

        "github.com/fastertools/ftl-cli/internal/synthesis"
        "github.com/fastertools/ftl-cli/pkg/spin"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

func newBuildCmd() *cobra.Command <span class="cov8" title="1">{
        var skipSynth bool
        var configFile string

        cmd := &amp;cobra.Command{
                Use:   "build",
                Short: "Build the FTL application",
                Long:  `Build compiles the FTL application and its components.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        ctx := context.Background()

                        // Color helpers
                        blue := color.New(color.FgBlue).SprintFunc()
                        green := color.New(color.FgGreen).SprintFunc()
                        yellow := color.New(color.FgYellow).SprintFunc()

                        // Ensure spin is installed
                        if err := spin.EnsureInstalled(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Auto-detect config file if not specified
                        <span class="cov8" title="1">if configFile == "" </span><span class="cov8" title="1">{
                                // Try to detect the config format
                                if _, err := os.Stat("ftl.yaml"); err == nil </span><span class="cov8" title="1">{
                                        configFile = "ftl.yaml"
                                }</span> else<span class="cov8" title="1"> if _, err := os.Stat("ftl.json"); err == nil </span><span class="cov8" title="1">{
                                        configFile = "ftl.json"
                                }</span> else<span class="cov8" title="1"> if _, err := os.Stat("app.cue"); err == nil </span><span class="cov8" title="1">{
                                        configFile = "app.cue"
                                }</span> else<span class="cov8" title="1"> if _, err := os.Stat("main.go"); err == nil </span><span class="cov8" title="1">{
                                        configFile = "main.go"
                                }</span>
                        }

                        // Check if config file exists
                        <span class="cov8" title="1">if configFile != "" &amp;&amp; !skipSynth </span><span class="cov8" title="1">{
                                if _, err := os.Stat(configFile); err == nil </span><span class="cov8" title="1">{
                                        fmt.Printf("%s Synthesizing spin.toml from %s\n", blue("→"), configFile)

                                        // Use unified synthesis helper
                                        manifest, err := synthesis.SynthesizeFromConfig(configFile)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("synthesis failed: %w", err)
                                        }</span>

                                        // Write spin.toml
                                        <span class="cov8" title="1">if err := os.WriteFile("spin.toml", []byte(manifest), 0644); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to write spin.toml: %w", err)
                                        }</span>

                                        <span class="cov8" title="1">fmt.Printf("%s Generated spin.toml\n", green("✓"))</span>
                                }
                        } else<span class="cov8" title="1"> if configFile == "" &amp;&amp; !skipSynth </span><span class="cov8" title="1">{
                                // No config file found, check for spin.toml
                                if _, err := os.Stat("spin.toml"); os.IsNotExist(err) </span><span class="cov8" title="1">{
                                        return fmt.Errorf("no ftl.yaml, ftl.json, app.cue, or spin.toml found. Run 'ftl init' first")
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("%s No FTL config found, using existing spin.toml\n", yellow("ℹ"))</span>
                        } else<span class="cov8" title="1"> if skipSynth </span><span class="cov8" title="1">{
                                // When skipping synthesis, just check if spin.toml exists
                                if _, err := os.Stat("spin.toml"); os.IsNotExist(err) </span><span class="cov8" title="1">{
                                        return fmt.Errorf("no spin.toml found. Run 'ftl synth' or 'ftl build' without --skip-synth first")
                                }</span>
                                <span class="cov8" title="1">fmt.Printf("%s Using existing spin.toml\n", yellow("ℹ"))</span>
                        }

                        <span class="cov8" title="1">fmt.Printf("%s Building FTL application...\n", blue("→"))

                        // Use spin build
                        if err := spin.Build(ctx); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to build: %w", err)
                        }</span>

                        <span class="cov8" title="1">fmt.Printf("%s Build completed successfully\n", green("✓"))
                        return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;skipSynth, "skip-synth", false, "Skip synthesis of spin.toml from FTL config")
        cmd.Flags().StringVarP(&amp;configFile, "config", "c", "", "Configuration file to synthesize (auto-detects if not specified)")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cli

import (
        "fmt"
        "os"

        "github.com/AlecAivazis/survey/v2"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"

        "github.com/fastertools/ftl-cli/pkg/types"
)

func newComponentCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "component",
                Short: "Manage FTL components",
                Long:  `Manage FTL components including adding, removing, and listing components.`,
        }

        // Add subcommands
        cmd.AddCommand(
                newComponentAddCmd(),
                newComponentListCmd(),
                newComponentRemoveCmd(),
        )

        return cmd
}</span>

func newComponentListCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "list",
                Short: "List all components",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return listComponents()
                }</span>,
        }
}

func listComponents() error <span class="cov0" title="0">{
        // Load manifest
        manifest, err := loadComponentManifest("ftl.yaml")
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("ftl.yaml not found. Run 'ftl init' first")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if len(manifest.Components) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No components found.")
                fmt.Println()
                fmt.Println("Add a component with:")
                color.Cyan("  ftl component add")
                return nil
        }</span>

        // Print header
        <span class="cov0" title="0">color.Cyan("Components:")
        fmt.Println()

        // List components
        for _, comp := range manifest.Components </span><span class="cov0" title="0">{
                fmt.Printf("  • %s\n", comp.ID)

                // Show source info
                if localPath, registrySource := types.ParseComponentSource(comp.Source); localPath != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    Source: %s\n", localPath)
                }</span> else<span class="cov0" title="0"> if registrySource != nil </span><span class="cov0" title="0">{
                        fmt.Printf("    Source: %s/%s:%s\n",
                                registrySource.Registry,
                                registrySource.Package,
                                registrySource.Version)
                }</span>

                // Show build info if present
                <span class="cov0" title="0">if comp.Build != nil &amp;&amp; comp.Build.Command != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    Build: %s\n", comp.Build.Command)
                }</span>

                // Show variables if present
                <span class="cov0" title="0">if len(comp.Variables) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("    Variables: %d configured\n", len(comp.Variables))
                }</span>

                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func newComponentRemoveCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "remove [name]",
                Short: "Remove a component",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        var name string
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                name = args[0]
                        }</span>
                        <span class="cov0" title="0">return removeComponent(name)</span>
                },
        }
}

func removeComponent(name string) error <span class="cov0" title="0">{
        // Load manifest
        manifest, err := loadComponentManifest("ftl.yaml")
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("ftl.yaml not found")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if len(manifest.Components) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no components to remove")
        }</span>

        // If no name provided, show interactive selection
        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                var options []string
                for _, comp := range manifest.Components </span><span class="cov0" title="0">{
                        options = append(options, comp.ID)
                }</span>

                <span class="cov0" title="0">prompt := &amp;survey.Select{
                        Message: "Select component to remove:",
                        Options: options,
                }
                if err := survey.AskOne(prompt, &amp;name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Find and remove component
        <span class="cov0" title="0">found := false
        newComponents := []types.Component{}
        for _, comp := range manifest.Components </span><span class="cov0" title="0">{
                if comp.ID == name </span><span class="cov0" title="0">{
                        found = true
                        continue</span>
                }
                <span class="cov0" title="0">newComponents = append(newComponents, comp)</span>
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return fmt.Errorf("component '%s' not found", name)
        }</span>

        // Confirm removal
        <span class="cov0" title="0">confirm := false
        prompt := &amp;survey.Confirm{
                Message: fmt.Sprintf("Remove component '%s'?", name),
                Default: false,
        }
        if err := survey.AskOne(prompt, &amp;confirm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !confirm </span><span class="cov0" title="0">{
                fmt.Println("Cancelled")
                return nil
        }</span>

        // Update manifest
        <span class="cov0" title="0">manifest.Components = newComponents

        // Save manifest
        if err := saveComponentManifest("ftl.yaml", manifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save manifest: %w", err)
        }</span>

        <span class="cov0" title="0">color.Green("✓ Component '%s' removed", name)
        return nil</span>
}

func loadComponentManifest(path string) (*types.Manifest, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var manifest types.Manifest
        if err := yaml.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse manifest: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;manifest, nil</span>
}

func saveComponentManifest(path string, manifest *types.Manifest) error <span class="cov0" title="0">{
        data, err := yaml.Marshal(manifest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal manifest: %w", err)
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cli

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/AlecAivazis/survey/v2"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"

        "github.com/fastertools/ftl-cli/pkg/types"
)

// AddComponentOptions holds options for adding a component
type AddComponentOptions struct {
        Name        string
        Source      string
        Registry    string
        Description string
        Template    string
        Build       string
}

func newComponentAddCmd() *cobra.Command <span class="cov8" title="1">{
        opts := &amp;AddComponentOptions{}

        cmd := &amp;cobra.Command{
                Use:   "add [name]",
                Short: "Add a component to the application",
                Long:  `Add a new component to your FTL application`,
                Args:  cobra.MaximumNArgs(1),
                Example: `  # Add a component interactively
  ftl component add

  # Add a component from a local path
  ftl component add my-component --source ./my-component

  # Add a component from a registry
  ftl component add my-component --registry ghcr.io/user:package:version

  # Add a component from a template
  ftl component add my-component --template go-http`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                opts.Name = args[0]
                        }</span>
                        <span class="cov0" title="0">return runComponentAdd(opts)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;opts.Source, "source", "s", "", "Path to component source")
        cmd.Flags().StringVarP(&amp;opts.Registry, "registry", "r", "", "Registry source (format: registry/package:version)")
        cmd.Flags().StringVarP(&amp;opts.Description, "description", "d", "", "Component description")
        cmd.Flags().StringVarP(&amp;opts.Template, "template", "t", "", "Use a template (go-http, rust-wasm, js-http, python-http)")
        cmd.Flags().StringVarP(&amp;opts.Build, "build", "b", "", "Build command")

        return cmd</span>
}

func runComponentAdd(opts *AddComponentOptions) error <span class="cov8" title="1">{
        // Load existing manifest
        manifest, err := loadManifest("ftl.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load ftl.yaml: %w", err)
        }</span>

        // Get component name if not provided
        <span class="cov8" title="1">if opts.Name == "" </span><span class="cov0" title="0">{
                prompt := &amp;survey.Input{
                        Message: "Component name:",
                }
                if err := survey.AskOne(prompt, &amp;opts.Name, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Validate name doesn't already exist
        <span class="cov8" title="1">for _, comp := range manifest.Components </span><span class="cov0" title="0">{
                if comp.ID == opts.Name </span><span class="cov0" title="0">{
                        return fmt.Errorf("component '%s' already exists", opts.Name)
                }</span>
        }

        // Determine source type
        <span class="cov8" title="1">var component types.Component
        if opts.Template != "" </span><span class="cov8" title="1">{
                component = createFromTemplate(opts)
        }</span> else<span class="cov8" title="1"> if opts.Registry != "" </span><span class="cov8" title="1">{
                component = createFromRegistry(opts)
        }</span> else<span class="cov8" title="1"> if opts.Source != "" </span><span class="cov8" title="1">{
                component = createFromLocal(opts)
        }</span> else<span class="cov0" title="0"> {
                // Interactive mode
                component, err = createInteractive(opts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Add to manifest
        <span class="cov8" title="1">manifest.Components = append(manifest.Components, component)

        // Save manifest
        if err := saveManifest("ftl.yaml", manifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save manifest: %w", err)
        }</span>

        <span class="cov8" title="1">color.Green("✓ Component '%s' added successfully", opts.Name)
        fmt.Println()
        color.Blue("→ Next steps:")
        fmt.Println("  1. Run 'ftl synth' to generate spin.toml")
        fmt.Println("  2. Run 'ftl up' to start development")

        return nil</span>
}

func createFromTemplate(opts *AddComponentOptions) types.Component <span class="cov8" title="1">{
        comp := types.Component{
                ID: opts.Name,
        }

        // Set source based on template
        templateDir := fmt.Sprintf("components/%s", opts.Name)
        comp.Source = templateDir

        // Set build command based on template type
        switch opts.Template </span>{
        case "go-http":<span class="cov8" title="1">
                comp.Build = &amp;types.Build{
                        Command: "tinygo build -target=wasip2 -o " + opts.Name + ".wasm main.go",
                        Watch:   []string{"**/*.go", "go.mod"},
                }</span>
        case "rust-wasm":<span class="cov0" title="0">
                comp.Build = &amp;types.Build{
                        Command: "cargo build --target wasm32-wasip2 --release",
                        Workdir: templateDir,
                        Watch:   []string{"src/**/*.rs", "Cargo.toml"},
                }</span>
        case "js-http":<span class="cov0" title="0">
                comp.Build = &amp;types.Build{
                        Command: "npm run build",
                        Workdir: templateDir,
                        Watch:   []string{"src/**/*.js", "package.json"},
                }</span>
        case "python-http":<span class="cov0" title="0">
                comp.Build = &amp;types.Build{
                        Command: "componentize-py -w spin-http componentize -o " + opts.Name + ".wasm app",
                        Workdir: templateDir,
                        Watch:   []string{"**/*.py"},
                }</span>
        }

        // Create the template directory and files
        <span class="cov8" title="1">createTemplateFiles(templateDir, opts.Template, opts.Name)

        return comp</span>
}

func createFromRegistry(opts *AddComponentOptions) types.Component <span class="cov8" title="1">{
        // Parse registry string (format: registry/package:version)
        parts := strings.Split(opts.Registry, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                color.Yellow("⚠ Invalid registry format. Using as-is.")
                return types.Component{
                        ID:     opts.Name,
                        Source: opts.Registry,
                }
        }</span>

        <span class="cov0" title="0">registry := parts[0]
        remainder := parts[1]

        // Split package:version
        packageParts := strings.Split(remainder, ":")
        if len(packageParts) != 2 </span><span class="cov0" title="0">{
                color.Yellow("⚠ Invalid package format. Using as-is.")
                return types.Component{
                        ID:     opts.Name,
                        Source: opts.Registry,
                }
        }</span>

        <span class="cov0" title="0">return types.Component{
                ID: opts.Name,
                Source: map[string]interface{}{
                        "registry": registry,
                        "package":  packageParts[0],
                        "version":  packageParts[1],
                },
        }</span>
}

func createFromLocal(opts *AddComponentOptions) types.Component <span class="cov8" title="1">{
        comp := types.Component{
                ID:     opts.Name,
                Source: opts.Source,
        }

        // Check if it needs build config
        info, err := os.Stat(opts.Source)
        if err == nil &amp;&amp; (info.IsDir() || !strings.HasSuffix(opts.Source, ".wasm")) </span><span class="cov0" title="0">{
                // It's source code, needs build
                if opts.Build != "" </span><span class="cov0" title="0">{
                        comp.Build = &amp;types.Build{
                                Command: opts.Build,
                        }
                }</span>
        }

        <span class="cov8" title="1">return comp</span>
}

func createInteractive(opts *AddComponentOptions) (types.Component, error) <span class="cov0" title="0">{
        // Ask for source type
        sourceType := ""
        sourcePrompt := &amp;survey.Select{
                Message: "Component source:",
                Options: []string{"Local path", "Registry", "Create from template"},
        }
        if err := survey.AskOne(sourcePrompt, &amp;sourceType); err != nil </span><span class="cov0" title="0">{
                return types.Component{}, err
        }</span>

        <span class="cov0" title="0">switch sourceType </span>{
        case "Local path":<span class="cov0" title="0">
                pathPrompt := &amp;survey.Input{
                        Message: "Path to component:",
                        Default: fmt.Sprintf("./components/%s", opts.Name),
                }
                if err := survey.AskOne(pathPrompt, &amp;opts.Source); err != nil </span><span class="cov0" title="0">{
                        return types.Component{}, err
                }</span>
                <span class="cov0" title="0">return createFromLocal(opts), nil</span>

        case "Registry":<span class="cov0" title="0">
                regPrompt := &amp;survey.Input{
                        Message: "Registry source (registry/package:version):",
                }
                if err := survey.AskOne(regPrompt, &amp;opts.Registry); err != nil </span><span class="cov0" title="0">{
                        return types.Component{}, err
                }</span>
                <span class="cov0" title="0">return createFromRegistry(opts), nil</span>

        case "Create from template":<span class="cov0" title="0">
                templatePrompt := &amp;survey.Select{
                        Message: "Select template:",
                        Options: []string{"go-http", "rust-wasm", "js-http", "python-http"},
                }
                if err := survey.AskOne(templatePrompt, &amp;opts.Template); err != nil </span><span class="cov0" title="0">{
                        return types.Component{}, err
                }</span>
                <span class="cov0" title="0">return createFromTemplate(opts), nil</span>
        }

        <span class="cov0" title="0">return types.Component{}, fmt.Errorf("invalid source type")</span>
}

func createTemplateFiles(dir, template, name string) <span class="cov8" title="1">{
        // Create directory
        os.MkdirAll(dir, 0755)

        switch template </span>{
        case "go-http":<span class="cov8" title="1">
                // Create main.go
                mainGo := fmt.Sprintf(`package main

import (
        "net/http"
        spinhttp "github.com/fermyon/spin-go-sdk/http"
)

func init() {
        spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {
                w.Header().Set("Content-Type", "text/plain")
                w.WriteHeader(http.StatusOK)
                w.Write([]byte("Hello from %s!"))
        })
}

func main() {}
`, name)
                os.WriteFile(filepath.Join(dir, "main.go"), []byte(mainGo), 0644)

                // Create go.mod
                goMod := fmt.Sprintf(`module github.com/example/%s

go 1.22

require github.com/fermyon/spin-go-sdk v0.2.0
`, name)
                os.WriteFile(filepath.Join(dir, "go.mod"), []byte(goMod), 0644)</span>

        case "rust-wasm":<span class="cov0" title="0">
                // Create Cargo.toml
                cargoToml := fmt.Sprintf(`[package]
name = "%s"
version = "0.1.0"
edition = "2021"

[dependencies]
spin-sdk = "3.0"

[lib]
crate-type = ["cdylib"]
`, name)
                os.WriteFile(filepath.Join(dir, "Cargo.toml"), []byte(cargoToml), 0644)

                // Create src/lib.rs
                os.MkdirAll(filepath.Join(dir, "src"), 0755)
                libRs := `use spin_sdk::http::{IntoResponse, Request, Response};

#[spin_sdk::http_component]
fn handle_request(_req: Request) -&gt; anyhow::Result&lt;impl IntoResponse&gt; {
    Ok(Response::builder()
        .status(200)
        .header("content-type", "text/plain")
        .body("Hello from Rust!")
        .build())
}
`
                os.WriteFile(filepath.Join(dir, "src", "lib.rs"), []byte(libRs), 0644)</span>

                // Add other templates as needed
        }
}

func loadManifest(path string) (*types.Manifest, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Create a new manifest if it doesn't exist
                        return &amp;types.Manifest{
                                Application: types.Application{
                                        Name:    "app",
                                        Version: "0.1.0",
                                },
                                Components: []types.Component{},
                                Access:     "public",
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">var manifest types.Manifest
        if err := yaml.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse manifest: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;manifest, nil</span>
}

func saveManifest(path string, manifest *types.Manifest) error <span class="cov8" title="1">{
        data, err := yaml.Marshal(manifest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal manifest: %w", err)
        }</span>
        <span class="cov8" title="1">return os.WriteFile(path, data, 0644)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"

        "github.com/AlecAivazis/survey/v2"
        "github.com/fatih/color"
        "github.com/google/uuid"
        "github.com/spf13/cobra"

        "github.com/fastertools/ftl-cli/internal/api"
        "github.com/fastertools/ftl-cli/internal/auth"
)

func newDeleteCmd() *cobra.Command <span class="cov8" title="1">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "delete &lt;app-id|app-name&gt;",
                Short: "Delete an FTL application",
                Long:  `Delete an FTL application from the platform.`,
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        return runDelete(ctx, args[0], force)
                }</span>,
        }

        <span class="cov8" title="1">cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Force deletion without confirmation")

        return cmd</span>
}

// Allow overriding for tests
var runDelete = runDeleteImpl

func runDeleteImpl(ctx context.Context, appIdentifier string, force bool) error <span class="cov0" title="0">{
        // Initialize auth manager
        store, err := auth.NewKeyringStore()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize credential store: %w", err)
        }</span>
        <span class="cov0" title="0">authManager := auth.NewManager(store, nil)

        // Check authentication
        if _, err := authManager.GetToken(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not logged in to FTL. Run 'ftl auth login' first")
        }</span>

        // Create API client
        <span class="cov0" title="0">apiClient, err := api.NewFTLClient(authManager, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create API client: %w", err)
        }</span>

        // Get app details first to show what will be deleted
        <span class="cov0" title="0">var app *api.App

        // Try to parse as UUID
        if _, err := uuid.Parse(appIdentifier); err == nil </span><span class="cov0" title="0">{
                // It's a UUID, get app directly
                app, err = apiClient.GetApp(ctx, appIdentifier)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get app: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Not a UUID, assume it's a name - list apps with name filter
                response, err := apiClient.ListApps(ctx, &amp;api.ListAppsParams{
                        Name: &amp;appIdentifier,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list apps: %w", err)
                }</span>

                <span class="cov0" title="0">if len(response.Apps) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("application '%s' not found", appIdentifier)
                }</span>

                // Get full details using the UUID
                <span class="cov0" title="0">appID := response.Apps[0].AppId.String()
                app, err = apiClient.GetApp(ctx, appID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get app details: %w", err)
                }</span>
        }

        // Display what will be deleted using shared DataWriter
        <span class="cov0" title="0">color.Yellow("Application to be deleted:")
        dw := NewDataWriter(colorOutput, "table")
        kvb := NewKeyValueBuilder("")
        kvb.Add("Name", app.AppName)
        kvb.Add("ID", app.AppId.String())
        if app.ProviderUrl != nil &amp;&amp; *app.ProviderUrl != "" </span><span class="cov0" title="0">{
                kvb.Add("URL", *app.ProviderUrl)
        }</span>
        <span class="cov0" title="0">if err := kvb.Write(dw); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to display app details: %w", err)
        }</span>

        // Ask for confirmation unless --force is used
        <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                // Check if we're in an interactive terminal
                if !isInteractive() </span><span class="cov0" title="0">{
                        return fmt.Errorf("deletion requires confirmation. Use --force to skip confirmation in non-interactive mode")
                }</span>

                <span class="cov0" title="0">color.New(color.FgRed, color.Bold).Println("⚠️  This action cannot be undone!")

                // Ask user to type the app name to confirm
                prompt := &amp;survey.Input{
                        Message: fmt.Sprintf("Type '%s' to confirm deletion:", app.AppName),
                }

                var confirmation string
                if err := survey.AskOne(prompt, &amp;confirmation); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get confirmation: %w", err)
                }</span>

                <span class="cov0" title="0">if confirmation != app.AppName </span><span class="cov0" title="0">{
                        color.Yellow("Deletion cancelled.")
                        return nil
                }</span>
        }

        // Perform deletion
        <span class="cov0" title="0">Info("Deleting application...")

        err = apiClient.DeleteApp(ctx, app.AppId.String())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete app: %w", err)
        }</span>

        <span class="cov0" title="0">Success("Application deleted successfully")

        return nil</span>
}

// isInteractive checks if we're running in an interactive terminal
func isInteractive() bool <span class="cov8" title="1">{
        fileInfo, err := os.Stdin.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check if stdin is a terminal (not a pipe or file)
        <span class="cov8" title="1">return fileInfo.Mode()&amp;os.ModeCharDevice != 0</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cli

import (
        "context"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/AlecAivazis/survey/v2"
        "github.com/briandowns/spinner"
        "github.com/fatih/color"
        "github.com/google/go-containerregistry/pkg/authn"
        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/google/go-containerregistry/pkg/v1/tarball"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"

        "github.com/fastertools/ftl-cli/internal/api"
        "github.com/fastertools/ftl-cli/internal/auth"
        "github.com/fastertools/ftl-cli/pkg/types"
)

// DeployOptions holds options for the deploy command
type DeployOptions struct {
        Environment   string
        ConfigFile    string
        DryRun        bool
        Yes           bool
        AccessControl string
        JWTIssuer     string
        JWTAudience   string
        AllowedRoles  []string
        Variables     map[string]string
}

func newDeployCmd() *cobra.Command <span class="cov8" title="1">{
        opts := &amp;DeployOptions{
                Variables: make(map[string]string),
        }

        cmd := &amp;cobra.Command{
                Use:   "deploy [flags]",
                Short: "Deploy the FTL application to the platform",
                Long: `Deploy the FTL application to the platform.

This command:
1. Reads your FTL configuration (ftl.yaml, ftl.json, or app.cue)
2. Builds local components
3. Creates/updates the app on FTL platform
4. Pushes built components to the registry
5. Sends the FTL config to the platform for deployment
6. Platform synthesizes Spin manifest and deploys

Example:
  ftl deploy
  ftl deploy --access-control private
  ftl deploy --jwt-issuer https://auth.example.com --jwt-audience api.example.com
  ftl deploy --dry-run`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        ctx := context.Background()
                        return runDeploy(ctx, opts)
                }</span>,
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;opts.Environment, "environment", "e", "production", "Deployment environment")
        cmd.Flags().StringVarP(&amp;opts.ConfigFile, "file", "f", "", "FTL configuration file (auto-detects if not specified)")
        cmd.Flags().BoolVar(&amp;opts.DryRun, "dry-run", false, "Validate configuration without deploying")
        cmd.Flags().BoolVarP(&amp;opts.Yes, "yes", "y", false, "Skip confirmation prompt")
        cmd.Flags().StringVar(&amp;opts.AccessControl, "access-control", "", "Access control mode (public, private, org, custom)")
        cmd.Flags().StringVar(&amp;opts.JWTIssuer, "jwt-issuer", "", "JWT issuer URL for authentication")
        cmd.Flags().StringVar(&amp;opts.JWTAudience, "jwt-audience", "", "JWT audience for authentication")
        cmd.Flags().StringSliceVar(&amp;opts.AllowedRoles, "allowed-roles", nil, "Allowed roles for org mode")
        cmd.Flags().StringToStringVar(&amp;opts.Variables, "var", nil, "Set variable (can be used multiple times)")

        return cmd</span>
}

func runDeploy(ctx context.Context, opts *DeployOptions) error <span class="cov8" title="1">{
        // Auto-detect config file if not specified
        if opts.ConfigFile == "" </span><span class="cov8" title="1">{
                for _, file := range []string{"ftl.yaml", "ftl.yml", "ftl.json", "app.cue"} </span><span class="cov8" title="1">{
                        if _, err := os.Stat(file); err == nil </span><span class="cov8" title="1">{
                                opts.ConfigFile = file
                                break</span>
                        }
                }
                <span class="cov8" title="1">if opts.ConfigFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("no FTL configuration file found (ftl.yaml, ftl.json, or app.cue)")
                }</span>
        }

        // First synthesize spin.toml from the FTL configuration
        <span class="cov8" title="1">Info("Synthesizing Spin manifest from %s", opts.ConfigFile)
        if err := runSynth(ctx, opts.ConfigFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to synthesize spin.toml: %w", err)
        }</span>
        <span class="cov8" title="1">Success("Generated spin.toml")

        // Load and parse configuration
        manifest, err := loadDeployManifest(opts.ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Apply command-line overrides
        <span class="cov8" title="1">if opts.AccessControl != "" </span><span class="cov0" title="0">{
                manifest.Access = opts.AccessControl
        }</span>
        <span class="cov8" title="1">if opts.JWTIssuer != "" </span><span class="cov0" title="0">{
                if manifest.Auth == nil </span><span class="cov0" title="0">{
                        manifest.Auth = &amp;types.Auth{}
                }</span>
                <span class="cov0" title="0">manifest.Auth.JWTIssuer = opts.JWTIssuer
                if opts.JWTAudience != "" </span><span class="cov0" title="0">{
                        manifest.Auth.JWTAudience = opts.JWTAudience
                }</span>
        }

        // Run spin build to build all local components
        <span class="cov8" title="1">if !opts.DryRun </span><span class="cov0" title="0">{
                Info("Building local components with 'spin build'")
                cmd := exec.CommandContext(ctx, "spin", "build")
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to build components: %w", err)
                }</span>
                <span class="cov0" title="0">Success("All local components built successfully")
                fmt.Println()</span>
        }

        // Initialize auth manager
        <span class="cov8" title="1">store, err := auth.NewKeyringStore()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize credential store: %w", err)
        }</span>
        <span class="cov8" title="1">authManager := auth.NewManager(store, nil)

        // Check authentication
        if _, err := authManager.GetToken(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not logged in to FTL. Run 'ftl auth login' first")
        }</span>

        // Create API client
        <span class="cov8" title="1">apiClient, err := api.NewFTLClient(authManager, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create API client: %w", err)
        }</span>

        // Check if app exists
        <span class="cov8" title="1">appName := manifest.Application.Name
        apps, err := apiClient.ListApps(ctx, &amp;api.ListAppsParams{
                Name: &amp;appName,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check existing apps: %w", err)
        }</span>

        <span class="cov8" title="1">var appID string
        appExists := len(apps.Apps) &gt; 0

        if appExists </span><span class="cov0" title="0">{
                appID = apps.Apps[0].AppId.String()
                if !opts.Yes &amp;&amp; !opts.DryRun </span><span class="cov0" title="0">{
                        Info("Found existing app '%s'", appName)
                        if !promptConfirm("Update existing app?", true) </span><span class="cov0" title="0">{
                                return fmt.Errorf("deployment cancelled")
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if !opts.Yes &amp;&amp; !opts.DryRun </span><span class="cov0" title="0">{
                        Info("Creating new app '%s'", appName)
                        if !promptConfirm("Continue?", true) </span><span class="cov0" title="0">{
                                return fmt.Errorf("deployment cancelled")
                        }</span>
                }
        }

        <span class="cov8" title="1">if opts.DryRun </span><span class="cov8" title="1">{
                displayDryRunSummary(manifest, appExists)
                return nil
        }</span>

        // Create app if it doesn't exist
        <span class="cov0" title="0">if !appExists </span><span class="cov0" title="0">{
                Info("Creating app on FTL platform...")

                accessControl := api.CreateAppRequestAccessControlPublic
                switch manifest.Access </span>{
                case "private":<span class="cov0" title="0">
                        accessControl = api.CreateAppRequestAccessControlPrivate</span>
                case "org":<span class="cov0" title="0">
                        accessControl = api.CreateAppRequestAccessControlOrg</span>
                case "custom":<span class="cov0" title="0">
                        accessControl = api.CreateAppRequestAccessControlCustom</span>
                }

                <span class="cov0" title="0">createReq := api.CreateAppRequest{
                        AppName:       appName,
                        AccessControl: &amp;accessControl,
                }

                createResp, err := apiClient.CreateApp(ctx, createReq)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create app: %w", err)
                }</span>
                <span class="cov0" title="0">appID = createResp.AppId.String()
                Success("App created with ID: %s", appID)</span>
        }

        // Get ECR credentials
        <span class="cov0" title="0">Info("Getting registry credentials...")
        // Extract component names to pass to ECR token creation
        componentNames := make([]string, 0, len(manifest.Components))
        for _, comp := range manifest.Components </span><span class="cov0" title="0">{
                componentNames = append(componentNames, comp.ID)
        }</span>
        <span class="cov0" title="0">ecrToken, err := apiClient.CreateECRToken(ctx, appID, componentNames)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get ECR token: %w", err)
        }</span>

        // Parse ECR credentials
        <span class="cov0" title="0">ecrAuth, err := parseECRToken(ecrToken.RegistryUri, ecrToken.AuthorizationToken)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse ECR token: %w", err)
        }</span>

        // Process components: pull registry components and push everything to ECR
        <span class="cov0" title="0">if ecrToken.PackageNamespace == nil || *ecrToken.PackageNamespace == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ECR token response missing required packageNamespace field")
        }</span>
        <span class="cov0" title="0">namespace := *ecrToken.PackageNamespace

        Info("Processing components...")
        processedManifest, err := processComponents(ctx, manifest, ecrAuth, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process components: %w", err)
        }</span>
        <span class="cov0" title="0">Success("All components processed and pushed to ECR")
        fmt.Println()

        // Create deployment request with the processed manifest
        Info("Creating deployment...")

        deploymentReq := createDeploymentRequest(processedManifest, opts)

        // Send deployment request
        deployment, err := apiClient.CreateDeployment(ctx, appID, deploymentReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create deployment: %w", err)
        }</span>

        // Poll for deployment status
        <span class="cov0" title="0">sp := spinner.New(spinner.CharSets[14], 100*time.Millisecond)
        sp.Suffix = " Waiting for deployment to start..."
        sp.Start()

        deployed, err := waitForDeployment(ctx, apiClient, appID, deployment.DeploymentId, sp)
        if err != nil </span><span class="cov0" title="0">{
                sp.Stop()
                return fmt.Errorf("deployment failed: %w", err)
        }</span>

        <span class="cov0" title="0">sp.Stop()
        Success("Deployment completed successfully!")

        if deployed.ProviderUrl != nil &amp;&amp; *deployed.ProviderUrl != "" </span><span class="cov0" title="0">{
                // Display MCP URLs for the deployed application
                displayMCPUrls(*deployed.ProviderUrl, processedManifest.Components)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// loadDeployManifest loads the FTL manifest configuration for deployment
func loadDeployManifest(configFile string) (*types.Manifest, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var manifest types.Manifest
        if err := yaml.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse manifest: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;manifest, nil</span>
}

// runSynth runs the synth command to generate spin.toml
func runSynth(ctx context.Context, configFile string) error <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "ftl", "synth")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()
}</span>

// ECRAuth holds parsed ECR authentication details
type ECRAuth struct {
        Registry string
        Username string
        Password string
}

// parseECRToken parses the ECR authorization token
func parseECRToken(registryURI, authToken string) (*ECRAuth, error) <span class="cov8" title="1">{
        decoded, err := base64.StdEncoding.DecodeString(authToken)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode ECR token: %w", err)
        }</span>

        <span class="cov8" title="1">parts := strings.SplitN(string(decoded), ":", 2)
        if len(parts) != 2 || parts[0] != "AWS" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid ECR token format")
        }</span>

        <span class="cov8" title="1">return &amp;ECRAuth{
                Registry: registryURI,
                Username: parts[0],
                Password: parts[1],
        }, nil</span>
}

// processComponents handles pulling registry components and pushing everything to ECR
func processComponents(ctx context.Context, manifest *types.Manifest, ecrAuth *ECRAuth, namespace string) (*types.Manifest, error) <span class="cov0" title="0">{
        // Create output manifest with ECR references
        processedManifest := &amp;types.Manifest{
                Application: manifest.Application,
                Access:      manifest.Access,
                Auth:        manifest.Auth,
                Variables:   manifest.Variables,
                Components:  make([]types.Component, 0, len(manifest.Components)),
        }

        // Create a WASMPuller for pulling registry components
        puller := NewWASMPuller()

        // Create a WASMPusher for pushing to ECR
        pusher := NewWASMPusher(ecrAuth)

        // Process each component
        for _, comp := range manifest.Components </span><span class="cov0" title="0">{
                var wasmPath string
                var err error

                // Check if it's a local or registry source
                if localPath, registrySource := types.ParseComponentSource(comp.Source); localPath != "" </span><span class="cov0" title="0">{
                        // Local component - find the built WASM file
                        wasmPath, err = findBuiltWASM(localPath, comp.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to find built WASM for %s: %w", comp.ID, err)
                        }</span>
                        <span class="cov0" title="0">Info("Found local component %s at %s", comp.ID, wasmPath)</span>
                } else<span class="cov0" title="0"> if registrySource != nil </span><span class="cov0" title="0">{
                        // Registry component - pull it
                        Info("Pulling component %s from %s", comp.ID, registrySource.Registry)
                        wasmPath, err = puller.Pull(ctx, registrySource)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to pull component %s: %w", comp.ID, err)
                        }</span>
                        <span class="cov0" title="0">Success("Pulled %s", comp.ID)</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("invalid source for component %s", comp.ID)
                }</span>

                // Push to ECR
                <span class="cov0" title="0">packageName := fmt.Sprintf("%s:%s", namespace, comp.ID)
                version := manifest.Application.Version

                Info("Pushing %s to ECR", comp.ID)
                if err := pusher.Push(ctx, wasmPath, packageName, version); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to push component %s: %w", comp.ID, err)
                }</span>
                <span class="cov0" title="0">Success("Pushed %s", comp.ID)

                // Create processed component with ECR reference
                processedComp := types.Component{
                        ID: comp.ID,
                        Source: map[string]interface{}{
                                "registry": ecrAuth.Registry,
                                "package":  packageName,
                                "version":  version,
                        },
                        Build:     comp.Build,
                        Variables: comp.Variables,
                }
                processedManifest.Components = append(processedManifest.Components, processedComp)</span>
        }

        <span class="cov0" title="0">return processedManifest, nil</span>
}

// findBuiltWASM locates the built WASM file for a local component
func findBuiltWASM(sourcePath, componentID string) (string, error) <span class="cov8" title="1">{
        // Check if sourcePath is already a .wasm file
        if strings.HasSuffix(sourcePath, ".wasm") </span><span class="cov8" title="1">{
                if _, err := os.Stat(sourcePath); err == nil </span><span class="cov8" title="1">{
                        return sourcePath, nil
                }</span>
        }

        // Look in common build output locations
        <span class="cov8" title="1">possiblePaths := []string{
                filepath.Join(sourcePath, componentID+".wasm"),
                filepath.Join(sourcePath, "target", "wasm32-wasip2", "release", componentID+".wasm"),
                filepath.Join(sourcePath, "target", "wasm32-wasi", "release", componentID+".wasm"),
                filepath.Join(sourcePath, "build", componentID+".wasm"),
                filepath.Join(sourcePath, "dist", componentID+".wasm"),
                componentID + ".wasm",
        }

        for _, path := range possiblePaths </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        return path, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("could not find built WASM file for component %s", componentID)</span>
}

// WASMPuller handles pulling WASM components from OCI registries
type WASMPuller struct {
        cacheDir string
        mu       sync.Mutex
}

// NewWASMPuller creates a new WASM component puller
func NewWASMPuller() *WASMPuller <span class="cov8" title="1">{
        home := os.Getenv("HOME")
        if home == "" </span><span class="cov0" title="0">{
                home = os.Getenv("USERPROFILE") // Windows fallback
        }</span>
        <span class="cov8" title="1">cacheDir := filepath.Join(home, ".cache", "ftl", "wasm")
        os.MkdirAll(cacheDir, 0755)

        return &amp;WASMPuller{
                cacheDir: cacheDir,
        }</span>
}

// Pull downloads a WASM component from a registry
func (p *WASMPuller) Pull(ctx context.Context, source *types.RegistrySource) (string, error) <span class="cov8" title="1">{
        // Construct the OCI reference
        ref := fmt.Sprintf("%s/%s:%s", source.Registry, source.Package, source.Version)

        // Parse the reference
        tag, err := name.ParseReference(ref)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid reference %s: %w", ref, err)
        }</span>

        // Pull the image
        <span class="cov8" title="1">img, err := remote.Image(tag, remote.WithAuthFromKeychain(authn.DefaultKeychain))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to pull %s: %w", ref, err)
        }</span>

        // Get the manifest to find the WASM layer
        <span class="cov8" title="1">manifest, err := img.Manifest()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get manifest: %w", err)
        }</span>

        // Find the WASM layer (usually the first/only layer)
        <span class="cov8" title="1">if len(manifest.Layers) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no layers found in image")
        }</span>

        // Get the first layer
        <span class="cov8" title="1">layers, err := img.Layers()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get layers: %w", err)
        }</span>

        <span class="cov8" title="1">if len(layers) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no layers available")
        }</span>

        <span class="cov8" title="1">layer := layers[0]

        // Get layer content
        reader, err := layer.Uncompressed()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get layer content: %w", err)
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        // Calculate hash for cache filename
        hash, err := layer.Digest()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get layer digest: %w", err)
        }</span>

        // Create cache file path
        <span class="cov8" title="1">cachePath := filepath.Join(p.cacheDir, hash.Hex+".wasm")

        // Check if already cached
        if _, err := os.Stat(cachePath); err == nil </span><span class="cov8" title="1">{
                Debug("Using cached WASM at %s", cachePath)
                return cachePath, nil
        }</span>

        // Write to cache
        <span class="cov8" title="1">p.mu.Lock()
        defer p.mu.Unlock()

        tmpFile := cachePath + ".tmp"
        file, err := os.Create(tmpFile)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create cache file: %w", err)
        }</span>

        <span class="cov8" title="1">_, err = io.Copy(file, reader)
        file.Close()
        if err != nil </span><span class="cov0" title="0">{
                os.Remove(tmpFile)
                return "", fmt.Errorf("failed to write WASM content: %w", err)
        }</span>

        // Atomic rename
        <span class="cov8" title="1">if err := os.Rename(tmpFile, cachePath); err != nil </span><span class="cov0" title="0">{
                os.Remove(tmpFile)
                return "", fmt.Errorf("failed to finalize cache file: %w", err)
        }</span>

        <span class="cov8" title="1">return cachePath, nil</span>
}

// WASMPusher handles pushing WASM components to ECR
type WASMPusher struct {
        auth *ECRAuth
}

// NewWASMPusher creates a new WASM component pusher
func NewWASMPusher(auth *ECRAuth) *WASMPusher <span class="cov8" title="1">{
        return &amp;WASMPusher{auth: auth}
}</span>

// Push uploads a WASM component to ECR
func (p *WASMPusher) Push(ctx context.Context, wasmPath, packageName, version string) error <span class="cov0" title="0">{
        // Read the WASM file
        wasmContent, err := os.ReadFile(wasmPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read WASM file: %w", err)
        }</span>

        // Calculate SHA256 for content addressability
        <span class="cov0" title="0">hash := sha256.Sum256(wasmContent)
        hashStr := hex.EncodeToString(hash[:])

        // Create a temporary tar file containing the WASM
        tmpDir, err := os.MkdirTemp("", "ftl-push-*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp dir: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tmpDir)

        // Write WASM to temp location
        tmpWASM := filepath.Join(tmpDir, "component.wasm")
        if err := os.WriteFile(tmpWASM, wasmContent, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write temp WASM: %w", err)
        }</span>

        // Create OCI image from the WASM file
        <span class="cov0" title="0">img, err := tarball.ImageFromPath(tmpWASM, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create OCI image: %w", err)
        }</span>

        // Construct the ECR reference
        <span class="cov0" title="0">ref := fmt.Sprintf("%s/%s:%s", p.auth.Registry, packageName, version)

        // Parse the reference
        tag, err := name.ParseReference(ref)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid reference %s: %w", ref, err)
        }</span>

        // Create authenticator
        <span class="cov0" title="0">authConfig := authn.AuthConfig{
                Username: p.auth.Username,
                Password: p.auth.Password,
        }
        authenticator := authn.FromConfig(authConfig)

        // Push the image
        if err := remote.Write(tag, img, remote.WithAuth(authenticator)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to push to ECR: %w", err)
        }</span>

        <span class="cov0" title="0">Debug("Pushed WASM to %s (sha256:%s)", ref, hashStr)
        return nil</span>
}

func createDeploymentRequest(manifest *types.Manifest, opts *DeployOptions) api.CreateDeploymentRequest <span class="cov8" title="1">{
        req := api.CreateDeploymentRequest{
                Variables: &amp;opts.Variables,
        }

        // Set the application details
        req.Application.Name = manifest.Application.Name
        req.Application.Version = &amp;manifest.Application.Version
        if manifest.Application.Description != "" </span><span class="cov8" title="1">{
                req.Application.Description = &amp;manifest.Application.Description
        }</span>

        // Set access control
        <span class="cov8" title="1">switch manifest.Access </span>{
        case "private":<span class="cov8" title="1">
                ac := api.CreateDeploymentRequestApplicationAccessPrivate
                req.Application.Access = &amp;ac</span>
        case "org":<span class="cov0" title="0">
                ac := api.CreateDeploymentRequestApplicationAccessOrg
                req.Application.Access = &amp;ac</span>
        case "custom":<span class="cov0" title="0">
                ac := api.CreateDeploymentRequestApplicationAccessCustom
                req.Application.Access = &amp;ac</span>
        default:<span class="cov0" title="0">
                ac := api.CreateDeploymentRequestApplicationAccessPublic
                req.Application.Access = &amp;ac</span>
        }

        // Set auth configuration if needed
        <span class="cov8" title="1">if manifest.Auth != nil &amp;&amp; (manifest.Access == "org" || manifest.Access == "custom") </span><span class="cov0" title="0">{
                req.Application.Auth = &amp;struct {
                        JwtAudience *string                                             `json:"jwt_audience,omitempty"`
                        JwtIssuer   *string                                             `json:"jwt_issuer,omitempty"`
                        OrgId       *string                                             `json:"org_id,omitempty"`
                        Provider    *api.CreateDeploymentRequestApplicationAuthProvider `json:"provider,omitempty"`
                }{}

                // Default to custom provider when JWT settings are present
                if manifest.Auth.JWTIssuer != "" </span><span class="cov0" title="0">{
                        provider := api.CreateDeploymentRequestApplicationAuthProviderCustom
                        req.Application.Auth.Provider = &amp;provider
                        req.Application.Auth.JwtIssuer = &amp;manifest.Auth.JWTIssuer
                }</span>
                <span class="cov0" title="0">if manifest.Auth.JWTAudience != "" </span><span class="cov0" title="0">{
                        req.Application.Auth.JwtAudience = &amp;manifest.Auth.JWTAudience
                }</span>
        }

        // Add components
        <span class="cov8" title="1">components := make([]struct {
                Id     string `json:"id"`
                Source struct {
                        Package  string `json:"package"`
                        Registry string `json:"registry"`
                        Version  string `json:"version"`
                } `json:"source"`
                Variables *map[string]string `json:"variables,omitempty"`
        }, 0, len(manifest.Components))

        for _, comp := range manifest.Components </span><span class="cov8" title="1">{
                deployComp := struct {
                        Id     string `json:"id"`
                        Source struct {
                                Package  string `json:"package"`
                                Registry string `json:"registry"`
                                Version  string `json:"version"`
                        } `json:"source"`
                        Variables *map[string]string `json:"variables,omitempty"`
                }{
                        Id: comp.ID,
                }

                // Parse component source - should be registry at this point
                if _, registrySource := types.ParseComponentSource(comp.Source); registrySource != nil </span><span class="cov8" title="1">{
                        deployComp.Source.Registry = registrySource.Registry
                        deployComp.Source.Package = registrySource.Package
                        deployComp.Source.Version = registrySource.Version
                }</span> else<span class="cov0" title="0"> {
                        // This shouldn't happen after processing
                        Error("Component %s has non-registry source after processing", comp.ID)
                        continue</span>
                }

                // Add component variables if any
                <span class="cov8" title="1">if len(comp.Variables) &gt; 0 </span><span class="cov8" title="1">{
                        deployComp.Variables = &amp;comp.Variables
                }</span>

                <span class="cov8" title="1">components = append(components, deployComp)</span>
        }

        <span class="cov8" title="1">if len(components) &gt; 0 </span><span class="cov8" title="1">{
                req.Application.Components = &amp;components
        }</span>

        // Add application variables if any
        <span class="cov8" title="1">if len(manifest.Variables) &gt; 0 </span><span class="cov8" title="1">{
                req.Application.Variables = &amp;manifest.Variables
        }</span>

        // Set environment based on options
        <span class="cov8" title="1">switch opts.Environment </span>{
        case "development":<span class="cov0" title="0">
                env := api.Development
                req.Environment = &amp;env</span>
        case "staging":<span class="cov0" title="0">
                env := api.Staging
                req.Environment = &amp;env</span>
        case "production":<span class="cov8" title="1">
                env := api.Production
                req.Environment = &amp;env</span>
        default:<span class="cov0" title="0">
                // Default to production if not specified
                env := api.Production
                req.Environment = &amp;env</span>
        }

        <span class="cov8" title="1">return req</span>
}

func waitForDeployment(ctx context.Context, client *api.FTLClient, appID string, deploymentID string, sp *spinner.Spinner) (*api.App, error) <span class="cov0" title="0">{
        maxAttempts := 36 // 3 minutes with 5-second intervals

        for i := 0; i &lt; maxAttempts; i++ </span><span class="cov0" title="0">{
                app, err := client.GetApp(ctx, appID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get app status: %w", err)
                }</span>

                // Check the latest deployment status if available
                <span class="cov0" title="0">if app.LatestDeployment != nil </span><span class="cov0" title="0">{
                        // Check if this is our deployment
                        if app.LatestDeployment.DeploymentId == deploymentID </span><span class="cov0" title="0">{
                                switch app.LatestDeployment.Status </span>{
                                case api.AppLatestDeploymentStatusDeployed:<span class="cov0" title="0">
                                        // Deployment succeeded
                                        return app, nil</span>
                                case api.AppLatestDeploymentStatusFailed:<span class="cov0" title="0">
                                        // Deployment failed
                                        errMsg := "deployment failed"
                                        if app.LatestDeployment.StatusMessage != nil &amp;&amp; *app.LatestDeployment.StatusMessage != "" </span><span class="cov0" title="0">{
                                                errMsg = *app.LatestDeployment.StatusMessage
                                        }</span>
                                        <span class="cov0" title="0">return nil, fmt.Errorf("%s", errMsg)</span>
                                case api.AppLatestDeploymentStatusPending, api.AppLatestDeploymentStatusDeploying:<span class="cov0" title="0">
                                        // Still in progress
                                        sp.Suffix = fmt.Sprintf(" Deployment in progress... (%s)", app.LatestDeployment.Status)</span>
                                default:<span class="cov0" title="0">
                                        // Unknown status, continue polling
                                        sp.Suffix = fmt.Sprintf(" Deployment in progress... (%s)", app.LatestDeployment.Status)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // This is a different deployment, might be a race condition
                                // Continue polling to see if our deployment shows up
                                sp.Suffix = fmt.Sprintf(" Waiting for deployment to start... (%s, %s, %s)", app.LatestDeployment.DeploymentId, deploymentID, app.LatestDeployment.Status)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // No deployment info yet, check app status as fallback
                        switch app.Status </span>{
                        case api.AppStatusACTIVE:<span class="cov0" title="0">
                                // App is active but no deployment info, consider it success
                                return app, nil</span>
                        case api.AppStatusFAILED:<span class="cov0" title="0">
                                errMsg := "app failed"
                                if app.ProviderError != nil </span><span class="cov0" title="0">{
                                        errMsg = *app.ProviderError
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("%s", errMsg)</span>
                        case api.AppStatusDELETED, api.AppStatusDELETING:<span class="cov0" title="0">
                                return nil, fmt.Errorf("app was deleted during deployment")</span>
                        default:<span class="cov0" title="0">
                                // Still pending or creating
                                sp.Suffix = fmt.Sprintf(" Waiting for deployment... (app: %s)", app.Status)</span>
                        }
                }

                <span class="cov0" title="0">time.Sleep(5 * time.Second)</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("deployment timeout after 3 minutes")</span>
}

func displayDryRunSummary(manifest *types.Manifest, appExists bool) <span class="cov8" title="1">{
        fmt.Println()
        fmt.Println("🔍 DRY RUN MODE - No changes will be made")
        fmt.Println()

        color.Cyan("Application Configuration:")
        fmt.Printf("  Name: %s\n", manifest.Application.Name)
        fmt.Printf("  Version: %s\n", manifest.Application.Version)
        if manifest.Application.Description != "" </span><span class="cov8" title="1">{
                fmt.Printf("  Description: %s\n", manifest.Application.Description)
        }</span>
        <span class="cov8" title="1">fmt.Printf("  Access Control: %s\n", manifest.Access)

        if manifest.Auth != nil </span><span class="cov0" title="0">{
                if manifest.Auth.JWTIssuer != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  Auth Provider: Custom\n")
                        fmt.Printf("  JWT Issuer: %s\n", manifest.Auth.JWTIssuer)
                        if manifest.Auth.JWTAudience != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  JWT Audience: %s\n", manifest.Auth.JWTAudience)
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Println()
        color.Cyan("Components:")
        for _, comp := range manifest.Components </span><span class="cov8" title="1">{
                fmt.Printf("  • %s\n", comp.ID)

                // Show source type
                if localPath, registrySource := types.ParseComponentSource(comp.Source); localPath != "" </span><span class="cov8" title="1">{
                        fmt.Printf("    Source: %s (local)\n", localPath)
                        if comp.Build != nil &amp;&amp; comp.Build.Command != "" </span><span class="cov8" title="1">{
                                fmt.Printf("    Build: %s\n", comp.Build.Command)
                        }</span>
                } else<span class="cov8" title="1"> if registrySource != nil </span><span class="cov8" title="1">{
                        fmt.Printf("    Source: %s (registry)\n", registrySource.Registry)
                        if registrySource.Package != "" </span><span class="cov8" title="1">{
                                fmt.Printf("    Package: %s\n", registrySource.Package)
                        }</span>
                        <span class="cov8" title="1">if registrySource.Version != "" </span><span class="cov8" title="1">{
                                fmt.Printf("    Version: %s\n", registrySource.Version)
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Println()
        color.Cyan("Actions that would be performed:")

        fmt.Printf("  ✓ Synthesize spin.toml from configuration\n")
        fmt.Printf("  ✓ Build local components with 'spin build'\n")

        if appExists </span><span class="cov8" title="1">{
                fmt.Printf("  ✓ Update existing app\n")
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("  ✓ Create new app\n")
        }</span>

        <span class="cov8" title="1">fmt.Printf("  ✓ Pull registry components and push all to ECR\n")
        fmt.Printf("  ✓ Create deployment with processed manifest\n")
        fmt.Printf("  ✓ Platform will deploy from ECR\n")

        fmt.Println()
        fmt.Println("To perform the actual deployment, run without --dry-run")</span>
}

func promptConfirm(message string, defaultYes bool) bool <span class="cov0" title="0">{
        prompt := &amp;survey.Confirm{
                Message: message,
                Default: defaultYes,
        }

        var result bool
        if err := survey.AskOne(prompt, &amp;result); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return result</span>
}

// displayMCPUrls displays a table showing MCP URLs for the application and its components
func displayMCPUrls(baseURL string, components []types.Component) <span class="cov8" title="1">{
        // Ensure the base URL ends with /mcp
        mcpBaseURL := strings.TrimRight(baseURL, "/") + "/mcp"

        // Create data writer for table output
        dw := NewDataWriter(colorOutput, "table")

        // Build table with headers
        tb := NewTableBuilder("COMPONENT", "URL")

        // Add the main application MCP URL
        tb.AddRow("*all", mcpBaseURL)

        // Add component-specific MCP URLs
        for _, comp := range components </span><span class="cov8" title="1">{
                componentURL := fmt.Sprintf("%s/x/%s", mcpBaseURL, comp.ID)
                tb.AddRow(comp.ID, componentURL)
        }</span>

        // Write the table (with empty line before it)
        <span class="cov8" title="1">fmt.Println()
        if err := tb.Write(dw); err != nil </span><span class="cov0" title="0">{
                // Fallback to simple display if table fails
                fmt.Printf("URL: %s\n", mcpBaseURL)
                for _, comp := range components </span><span class="cov0" title="0">{
                        fmt.Printf("%s: %s/x/%s\n", comp.ID, mcpBaseURL, comp.ID)
                }</span>
        }

        // Add summary line after table
        <span class="cov8" title="1">fmt.Fprintf(colorOutput, "Connect to MCP clients with the URLs above.\n")</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">//go:build !production
// +build !production

package cli

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
)

// ExecCommand is a variable that can be mocked in tests
var ExecCommand = exec.Command

// MockExecCommand represents a mocked external command
type MockExecCommand struct {
        Command      string
        Args         []string
        ReturnOutput string
        ReturnError  error
        ReturnCode   int
}

// MockCommandExecutor manages mocked commands
type MockCommandExecutor struct {
        Commands map[string]*MockExecCommand
        History  []string
}

// NewMockCommandExecutor creates a new mock executor
func NewMockCommandExecutor() *MockCommandExecutor <span class="cov0" title="0">{
        return &amp;MockCommandExecutor{
                Commands: make(map[string]*MockExecCommand),
                History:  []string{},
        }
}</span>

// RegisterCommand registers a mock command
func (m *MockCommandExecutor) RegisterCommand(cmd string, mock *MockExecCommand) <span class="cov0" title="0">{
        m.Commands[cmd] = mock
}</span>

// Execute simulates command execution
func (m *MockCommandExecutor) Execute(name string, args ...string) ([]byte, error) <span class="cov0" title="0">{
        cmdKey := name + " " + strings.Join(args, " ")
        m.History = append(m.History, cmdKey)

        if mock, ok := m.Commands[name]; ok </span><span class="cov0" title="0">{
                if mock.ReturnError != nil </span><span class="cov0" title="0">{
                        return nil, mock.ReturnError
                }</span>
                <span class="cov0" title="0">return []byte(mock.ReturnOutput), nil</span>
        }

        // Default behavior for unmocked commands
        <span class="cov0" title="0">return []byte(""), nil</span>
}

// GetHistory returns command execution history
func (m *MockCommandExecutor) GetHistory() []string <span class="cov0" title="0">{
        return m.History
}</span>

// ResetHistory clears the command history
func (m *MockCommandExecutor) ResetHistory() <span class="cov0" title="0">{
        m.History = []string{}
}</span>

// MockExecCommandHelper is used to create fake commands for testing
func MockExecCommandHelper(command string, args ...string) *exec.Cmd <span class="cov0" title="0">{
        cs := []string{"-test.run=TestHelperProcess", "--", command}
        cs = append(cs, args...)
        cmd := exec.Command(os.Args[0], cs...)
        cmd.Env = []string{"GO_WANT_HELPER_PROCESS=1"}
        return cmd
}</span>

// TestHelperProcess is not a real test. It's used to mock exec.Command
func TestHelperProcess() <span class="cov0" title="0">{
        if os.Getenv("GO_WANT_HELPER_PROCESS") != "1" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">args := os.Args
        for i, arg := range args </span><span class="cov0" title="0">{
                if arg == "--" </span><span class="cov0" title="0">{
                        args = args[i+1:]
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "No command specified")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cmd := args[0]
        cmdArgs := args[1:]

        // Mock different commands
        switch cmd </span>{
        case "spin":<span class="cov0" title="0">
                handleSpinCommand(cmdArgs)</span>
        case "docker":<span class="cov0" title="0">
                handleDockerCommand(cmdArgs)</span>
        case "make":<span class="cov0" title="0">
                handleMakeCommand(cmdArgs)</span>
        case "go":<span class="cov0" title="0">
                handleGoCommand(cmdArgs)</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown command: %s", cmd)
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">os.Exit(0)</span>
}

func handleSpinCommand(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                fmt.Println("spin version 2.0.0")
                return
        }</span>

        <span class="cov0" title="0">switch args[0] </span>{
        case "build":<span class="cov0" title="0">
                fmt.Println("Building application...")
                fmt.Println("✓ Built successfully")</span>
        case "up":<span class="cov0" title="0">
                fmt.Println("Starting application...")
                fmt.Println("Available on http://localhost:3000")</span>
        case "deploy":<span class="cov0" title="0">
                fmt.Println("Deploying application...")
                fmt.Println("✓ Deployed successfully")</span>
        case "registry":<span class="cov0" title="0">
                if len(args) &gt; 1 &amp;&amp; args[1] == "push" </span><span class="cov0" title="0">{
                        fmt.Println("Pushing to registry...")
                        fmt.Println("✓ Pushed successfully")
                }</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown spin command: %s\n", args[0])
                os.Exit(1)</span>
        }
}

func handleDockerCommand(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Docker version 24.0.0")
                return
        }</span>

        <span class="cov0" title="0">switch args[0] </span>{
        case "build":<span class="cov0" title="0">
                fmt.Println("Building Docker image...")
                fmt.Println("✓ Image built successfully")</span>
        case "run":<span class="cov0" title="0">
                fmt.Println("Running container...")</span>
        case "push":<span class="cov0" title="0">
                fmt.Println("Pushing image...")
                fmt.Println("✓ Pushed successfully")</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown docker command: %s\n", args[0])</span>
        }
}

func handleMakeCommand(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                args = []string{"all"}
        }</span>

        <span class="cov0" title="0">target := args[0]
        fmt.Printf("make: Entering directory\n")
        fmt.Printf("Building target '%s'...\n", target)
        fmt.Printf("✓ Build complete\n")</span>
}

func handleGoCommand(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                fmt.Println("go version go1.21.0")
                return
        }</span>

        <span class="cov0" title="0">switch args[0] </span>{
        case "run":<span class="cov0" title="0">
                // Simulate Go CDK synthesis
                fmt.Println(`spin_manifest_version = 2
[application]
name = "test-app"
version = "0.1.0"`)</span>
        case "build":<span class="cov0" title="0">
                fmt.Println("Building Go application...")</span>
        case "test":<span class="cov0" title="0">
                fmt.Println("PASS")
                fmt.Println("ok          test-package        0.001s")</span>
        case "mod":<span class="cov0" title="0">
                if len(args) &gt; 1 &amp;&amp; args[1] == "tidy" </span><span class="cov0" title="0">{
                        fmt.Println("go: downloading modules...")
                }</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown go command: %s\n", args[0])</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cli

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/AlecAivazis/survey/v2"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"

        "github.com/fastertools/ftl-cli/pkg/types"
)

// InitOptions holds options for the init command
type InitOptions struct {
        Name          string
        Description   string
        Template      string
        Format        string // Configuration format: yaml, go, cue, json
        NoInteractive bool
        Force         bool
}

// newInitCmd creates the init command
func newInitCmd() *cobra.Command <span class="cov8" title="1">{
        opts := &amp;InitOptions{}

        cmd := &amp;cobra.Command{
                Use:   "init [name]",
                Short: "Initialize a new FTL project",
                Long: `Initialize a new FTL project with the specified name.

This command creates a new FTL project directory with:
- ftl.yaml configuration file
- Basic project structure
- Example components (optional)`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                opts.Name = args[0]
                        }</span>
                        <span class="cov0" title="0">return runInit(opts)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;opts.Description, "description", "d", "", "project description")
        cmd.Flags().StringVarP(&amp;opts.Template, "template", "t", "mcp", "project template (mcp, basic, empty)")
        cmd.Flags().StringVar(&amp;opts.Format, "format", "yaml", "configuration format (yaml, go, cue, json)")
        cmd.Flags().BoolVar(&amp;opts.NoInteractive, "no-interactive", false, "disable interactive prompts")
        cmd.Flags().BoolVarP(&amp;opts.Force, "force", "f", false, "overwrite existing files")

        return cmd</span>
}

func runInit(opts *InitOptions) error <span class="cov8" title="1">{
        // Validate or prompt for name
        if opts.Name == "" </span><span class="cov0" title="0">{
                if opts.NoInteractive </span><span class="cov0" title="0">{
                        return fmt.Errorf("project name is required")
                }</span>
                <span class="cov0" title="0">if err := promptForName(opts); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Prompt for format if not specified and in interactive mode
        <span class="cov8" title="1">if !opts.NoInteractive &amp;&amp; opts.Format == "" </span><span class="cov0" title="0">{
                if err := promptForFormat(opts); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Create project directory
        <span class="cov8" title="1">projectDir := opts.Name
        if !opts.Force </span><span class="cov8" title="1">{
                if _, err := os.Stat(projectDir); err == nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("directory %s already exists (use --force to overwrite)", projectDir)
                }</span>
        }

        <span class="cov8" title="1">if err := os.MkdirAll(projectDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create project directory: %w", err)
        }</span>

        <span class="cov8" title="1">Info("Initializing FTL project '%s' with %s format", opts.Name, opts.Format)

        // Create configuration based on format
        switch opts.Format </span>{
        case "yaml":<span class="cov8" title="1">
                if err := createYAMLConfig(projectDir, opts); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create ftl.yaml: %w", err)
                }</span>
                <span class="cov8" title="1">Success("Created ftl.yaml")</span>
        case "go":<span class="cov8" title="1">
                if err := createGoConfig(projectDir, opts); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create main.go: %w", err)
                }</span>
                <span class="cov8" title="1">Success("Created main.go")</span>
        case "cue":<span class="cov8" title="1">
                if err := createCUEConfig(projectDir, opts); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create app.cue: %w", err)
                }</span>
                <span class="cov8" title="1">Success("Created app.cue")</span>
        case "json":<span class="cov8" title="1">
                if err := createJSONConfig(projectDir, opts); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create ftl.json: %w", err)
                }</span>
                <span class="cov8" title="1">Success("Created ftl.json")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported format: %s", opts.Format)</span>
        }

        // Create .gitignore
        <span class="cov8" title="1">if err := createGitignore(projectDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .gitignore: %w", err)
        }</span>
        <span class="cov8" title="1">Success("Created .gitignore")

        // Print next steps based on format
        fmt.Println()
        Info("Next steps:")
        fmt.Println("  1. cd", opts.Name)
        switch opts.Format </span>{
        case "go":<span class="cov8" title="1">
                fmt.Println("  2. Edit main.go to add your components")
                fmt.Println("  3. go run main.go &gt; spin.toml")
                fmt.Println("  4. spin up")</span>
        case "cue":<span class="cov8" title="1">
                fmt.Println("  2. Edit app.cue to add your components")
                fmt.Println("  3. ftl synth app.cue")
                fmt.Println("  4. spin up")</span>
        default:<span class="cov8" title="1">
                fmt.Printf("  2. Edit %s to add your components\n",
                        map[string]string{"yaml": "ftl.yaml", "json": "ftl.json"}[opts.Format])
                fmt.Println("  3. ftl build")
                fmt.Println("  4. ftl up")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func promptForName(opts *InitOptions) error <span class="cov0" title="0">{
        prompt := &amp;survey.Input{
                Message: "Project name:",
                Help:    "The name of your FTL project (lowercase, alphanumeric, hyphens)",
        }
        return survey.AskOne(prompt, &amp;opts.Name, survey.WithValidator(survey.Required))
}</span>

func promptForFormat(opts *InitOptions) error <span class="cov0" title="0">{
        prompt := &amp;survey.Select{
                Message: "Configuration format:",
                Options: []string{
                        "yaml - Simple declarative YAML configuration",
                        "go - Programmatic Go code with FTL SDK",
                        "cue - Advanced CUE configuration language",
                        "json - JSON configuration",
                },
                Default: "yaml - Simple declarative YAML configuration",
        }

        var choice string
        if err := survey.AskOne(prompt, &amp;choice); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract format from choice
        <span class="cov0" title="0">switch choice </span>{
        case "yaml - Simple declarative YAML configuration":<span class="cov0" title="0">
                opts.Format = "yaml"</span>
        case "go - Programmatic Go code with FTL SDK":<span class="cov0" title="0">
                opts.Format = "go"</span>
        case "cue - Advanced CUE configuration language":<span class="cov0" title="0">
                opts.Format = "cue"</span>
        case "json - JSON configuration":<span class="cov0" title="0">
                opts.Format = "json"</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func createYAMLConfig(dir string, opts *InitOptions) error <span class="cov8" title="1">{
        description := opts.Description
        if description == "" </span><span class="cov8" title="1">{
                description = fmt.Sprintf("%s - An FTL application", opts.Name)
        }</span>

        <span class="cov8" title="1">manifest := &amp;types.Manifest{
                Application: types.Application{
                        Name:        opts.Name,
                        Version:     "0.1.0",
                        Description: description,
                },
                Components: []types.Component{},
                Access:     "public",
        }

        configPath := filepath.Join(dir, "ftl.yaml")
        data, err := yaml.Marshal(manifest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>
        <span class="cov8" title="1">return os.WriteFile(configPath, data, 0644)</span>
}

// createSpinComposeConfig is no longer needed as we create ftl.yaml in createFTLConfig

func createGitignore(dir string) error <span class="cov8" title="1">{
        content := `.spin/
spin.toml
*.wasm
.ftl/
.env
.env.local
target/
dist/
node_modules/
__pycache__/
*.pyc
.DS_Store
`
        gitignorePath := filepath.Join(dir, ".gitignore")
        return os.WriteFile(gitignorePath, []byte(content), 0644)
}</span>

// createGoConfig creates a Go-based configuration
func createGoConfig(dir string, opts *InitOptions) error <span class="cov8" title="1">{
        description := opts.Description
        if description == "" </span><span class="cov8" title="1">{
                description = fmt.Sprintf("%s - An FTL application", opts.Name)
        }</span>

        // Create a main.go file with FTL CDK
        <span class="cov8" title="1">content := fmt.Sprintf(`package main

import (
        "fmt"
        "log"

        "github.com/fastertools/ftl-cli/internal/synthesis"
)

func main() {
        // Create your FTL application using the CDK
        cdk := synthesis.NewCDK()
        app := cdk.NewApp("%s").
                SetDescription("%s").
                SetVersion("0.1.0")

        // Add your components here
        // Example:
        // app.AddComponent("my-component").
        //     FromLocal("./build/component.wasm").
        //     WithBuild("cargo build --release").
        //     WithEnv("LOG_LEVEL", "info").
        //     Build()

        // Enable authentication (optional)
        // app.EnableWorkOSAuth("org_123456")

        // Build and synthesize to spin.toml
        builtCDK := app.Build()
        manifest, err := builtCDK.Synthesize()
        if err != nil {
                log.Fatalf("Failed to synthesize: %%v", err)
        }

        // Output the manifest
        fmt.Print(manifest)
}
`, opts.Name, description)

        // Write main.go
        mainPath := filepath.Join(dir, "main.go")
        if err := os.WriteFile(mainPath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create go.mod
        <span class="cov8" title="1">goMod := fmt.Sprintf(`module %s

go 1.21

require github.com/fastertools/ftl-cli/go/ftl v0.1.0

// For local development, uncomment and adjust the path:
// replace github.com/fastertools/ftl-cli/go/ftl =&gt; ../path/to/ftl
`, opts.Name)

        goModPath := filepath.Join(dir, "go.mod")
        return os.WriteFile(goModPath, []byte(goMod), 0644)</span>
}

// createCUEConfig creates a CUE-based configuration
func createCUEConfig(dir string, opts *InitOptions) error <span class="cov8" title="1">{
        description := opts.Description
        if description == "" </span><span class="cov8" title="1">{
                description = fmt.Sprintf("%s - An FTL application", opts.Name)
        }</span>

        // Create app.cue with FTL patterns
        <span class="cov8" title="1">content := fmt.Sprintf(`package app

import "github.com/fastertools/ftl-cli/patterns"

// Define your FTL application
app: #FTLApplication &amp; {
        name:        "%s"
        version:     "0.1.0"
        description: "%s"
        
        // Add your components here
        components: [
                // {
                //     id: "my-component"
                //     source: "./build/component.wasm"
                //     build: {
                //         command: "cargo build --release"
                //         watch: ["src/**/*.rs", "Cargo.toml"]
                //     }
                //     variables: {
                //         LOG_LEVEL: "info"
                //     }
                // },
        ]
        
        // Configure access (public or private)
        access: "public"
        
        // Configure authentication (optional)
        // auth: {
        //     provider: "workos"
        //     org_id: "org_123456"
        // }
}
`, opts.Name, description)

        cuePath := filepath.Join(dir, "app.cue")
        return os.WriteFile(cuePath, []byte(content), 0644)</span>
}

// createJSONConfig creates a JSON-based configuration
func createJSONConfig(dir string, opts *InitOptions) error <span class="cov8" title="1">{
        description := opts.Description
        if description == "" </span><span class="cov8" title="1">{
                description = fmt.Sprintf("%s - An FTL application", opts.Name)
        }</span>

        // Create ftl.json
        <span class="cov8" title="1">content := fmt.Sprintf(`{
  "application": {
    "name": "%s",
    "version": "0.1.0",
    "description": "%s"
  },
  "components": [
    
  ],
  "triggers": [
    
  ]
}
`, opts.Name, description)

        jsonPath := filepath.Join(dir, "ftl.json")
        return os.WriteFile(jsonPath, []byte(content), 0644)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cli

import (
        "context"
        "fmt"
        "strings"

        openapi_types "github.com/oapi-codegen/runtime/types"
        "github.com/spf13/cobra"

        "github.com/fastertools/ftl-cli/internal/api"
        "github.com/fastertools/ftl-cli/internal/auth"
)

func newListCmd() *cobra.Command <span class="cov8" title="1">{
        var format string
        var detailed bool

        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List all FTL applications",
                Long:  `List all FTL applications deployed on the platform.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        return runList(ctx, format, detailed)
                }</span>,
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;format, "output", "o", "table", "Output format (table, json)")
        cmd.Flags().BoolVarP(&amp;detailed, "detailed", "d", false, "Show additional details (app ID, deployment info)")

        return cmd</span>
}

// Allow overriding for tests
var runList = runListImpl

func runListImpl(ctx context.Context, format string, detailed bool) error <span class="cov0" title="0">{
        // Initialize auth manager
        store, err := auth.NewKeyringStore()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize credential store: %w", err)
        }</span>
        <span class="cov0" title="0">authManager := auth.NewManager(store, nil)

        // Check authentication
        if _, err := authManager.GetToken(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not logged in to FTL. Run 'ftl auth login' first")
        }</span>

        // Create API client
        <span class="cov0" title="0">apiClient, err := api.NewFTLClient(authManager, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create API client: %w", err)
        }</span>

        // List all apps - use empty params instead of nil
        // (some backends may filter differently with nil vs empty params)
        <span class="cov0" title="0">Debug("Calling ListApps with empty params")
        response, err := apiClient.ListApps(ctx, &amp;api.ListAppsParams{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list apps: %w", err)
        }</span>

        <span class="cov0" title="0">Debug("ListApps returned %d apps", len(response.Apps))
        if len(response.Apps) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(colorOutput, "No applications found.")
                return nil
        }</span>

        // Use shared DataWriter for consistent output
        <span class="cov0" title="0">dw := NewDataWriter(colorOutput, format)

        switch format </span>{
        case "json":<span class="cov0" title="0">
                return dw.WriteStruct(response.Apps)</span>
        case "table":<span class="cov0" title="0">
                return displayAppsTable(response.Apps, detailed, dw)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid output format: %s (use 'table' or 'json')", format)</span>
        }
}

func displayAppsTable(apps []struct {
        AccessControl *api.ListAppsResponseBodyAppsAccessControl `json:"accessControl,omitempty"`
        AllowedRoles  *[]string                                  `json:"allowedRoles,omitempty"`
        AppId         openapi_types.UUID                         `json:"appId"`
        AppName       string                                     `json:"appName"`
        CreatedAt     string                                     `json:"createdAt"`
        CustomAuth    *struct {
                Audience string `json:"audience"`
                Issuer   string `json:"issuer"`
        } `json:"customAuth,omitempty"`
        LatestDeployment *struct {
                CreatedAt          *float32                                           `json:"createdAt,omitempty"`
                DeployedAt         *float32                                           `json:"deployedAt,omitempty"`
                DeploymentDuration *float32                                           `json:"deploymentDuration,omitempty"`
                DeploymentId       string                                             `json:"deploymentId"`
                Environment        *string                                            `json:"environment,omitempty"`
                Status             api.ListAppsResponseBodyAppsLatestDeploymentStatus `json:"status"`
                StatusMessage      *string                                            `json:"statusMessage,omitempty"`
        } `json:"latestDeployment"`
        OrgId         *string                            `json:"orgId,omitempty"`
        ProviderError *string                            `json:"providerError,omitempty"`
        ProviderUrl   *string                            `json:"providerUrl,omitempty"`
        Status        api.ListAppsResponseBodyAppsStatus `json:"status"`
        UpdatedAt     string                             `json:"updatedAt"`
}, detailed bool, dw *DataWriter) error <span class="cov8" title="1">{
        // Build headers
        var headers []string
        if detailed </span><span class="cov8" title="1">{
                headers = []string{"NAME", "ID", "STATUS", "ACCESS", "URL", "DEPLOYMENT", "ENVIRONMENT", "CREATED"}
        }</span> else<span class="cov8" title="1"> {
                headers = []string{"NAME", "STATUS", "ACCESS", "URL", "CREATED"}
        }</span>

        // Build table
        <span class="cov8" title="1">tb := NewTableBuilder(headers...)

        for _, app := range apps </span><span class="cov8" title="1">{
                url := "-"
                if app.ProviderUrl != nil &amp;&amp; *app.ProviderUrl != "" </span><span class="cov8" title="1">{
                        url = *app.ProviderUrl
                }</span>

                // Format access control
                <span class="cov8" title="1">access := "public"
                if app.AccessControl != nil </span><span class="cov0" title="0">{
                        access = strings.ToLower(string(*app.AccessControl))
                }</span>

                // If failed, show error in URL column
                <span class="cov8" title="1">if app.Status == api.ListAppsResponseBodyAppsStatusFAILED </span><span class="cov8" title="1">{
                        if app.ProviderError != nil &amp;&amp; *app.ProviderError != "" </span><span class="cov0" title="0">{
                                // Truncate long errors for table display
                                errMsg := *app.ProviderError
                                if len(errMsg) &gt; 40 </span><span class="cov0" title="0">{
                                        errMsg = errMsg[:37] + "..."
                                }</span>
                                <span class="cov0" title="0">url = errMsg</span>
                        }
                }

                // Format timestamp (just date for list view)
                <span class="cov8" title="1">created := app.CreatedAt
                if len(created) &gt; 10 </span><span class="cov8" title="1">{
                        created = created[:10] // Just YYYY-MM-DD
                }</span>

                // Add row based on detailed mode
                <span class="cov8" title="1">if detailed </span><span class="cov8" title="1">{
                        // Get deployment info if available
                        deploymentId := "-"
                        environment := "-"
                        if app.LatestDeployment != nil </span><span class="cov8" title="1">{
                                deploymentId = app.LatestDeployment.DeploymentId
                                if app.LatestDeployment.Environment != nil </span><span class="cov8" title="1">{
                                        environment = *app.LatestDeployment.Environment
                                }</span>
                        }
                        <span class="cov8" title="1">tb.AddRow(app.AppName, app.AppId.String(), string(app.Status), access, url, deploymentId, environment, created)</span>
                } else<span class="cov8" title="1"> {
                        tb.AddRow(app.AppName, string(app.Status), access, url, created)
                }</span>
        }

        // Write the table
        <span class="cov8" title="1">if err := tb.Write(dw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">count := len(apps)
        plural := ""
        if count != 1 </span><span class="cov8" title="1">{
                plural = "s"
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(colorOutput, "Total: %d application%s\n", count, plural)

        return nil</span>
}

// displayAppsJSON is no longer needed - using shared DataWriter
</pre>
		
		<pre class="file" id="file18" style="display: none">package cli

import (
        "encoding/json"
        "fmt"
        "io"
        "text/tabwriter"
)

// OutputFormat represents the output format type
type OutputFormat string

const (
        OutputFormatTable OutputFormat = "table"
        OutputFormatJSON  OutputFormat = "json"
)

// DataWriter handles formatted output of structured data
type DataWriter struct {
        output io.Writer
        format OutputFormat
}

// NewDataWriter creates a new DataWriter
func NewDataWriter(output io.Writer, format string) *DataWriter <span class="cov8" title="1">{
        of := OutputFormatTable
        if format == "json" </span><span class="cov8" title="1">{
                of = OutputFormatJSON
        }</span>
        <span class="cov8" title="1">return &amp;DataWriter{
                output: output,
                format: of,
        }</span>
}

// WriteKeyValue writes key-value pairs in the specified format
func (dw *DataWriter) WriteKeyValue(title string, data map[string]interface{}) error <span class="cov8" title="1">{
        switch dw.format </span>{
        case OutputFormatJSON:<span class="cov0" title="0">
                return dw.writeJSON(data)</span>
        case OutputFormatTable:<span class="cov8" title="1">
                return dw.writeKeyValueTable(title, data)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", dw.format)</span>
        }
}

// WriteTable writes tabular data with headers
func (dw *DataWriter) WriteTable(headers []string, rows [][]string) error <span class="cov8" title="1">{
        switch dw.format </span>{
        case OutputFormatJSON:<span class="cov0" title="0">
                // Convert to array of objects for JSON
                var jsonData []map[string]string
                for _, row := range rows </span><span class="cov0" title="0">{
                        obj := make(map[string]string)
                        for i, header := range headers </span><span class="cov0" title="0">{
                                if i &lt; len(row) </span><span class="cov0" title="0">{
                                        obj[header] = row[i]
                                }</span>
                        }
                        <span class="cov0" title="0">jsonData = append(jsonData, obj)</span>
                }
                <span class="cov0" title="0">return dw.writeJSON(jsonData)</span>
        case OutputFormatTable:<span class="cov8" title="1">
                return dw.writeTabularData(headers, rows)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", dw.format)</span>
        }
}

// WriteStruct writes a struct in the specified format
func (dw *DataWriter) WriteStruct(data interface{}) error <span class="cov8" title="1">{
        switch dw.format </span>{
        case OutputFormatJSON:<span class="cov8" title="1">
                return dw.writeJSON(data)</span>
        case OutputFormatTable:<span class="cov0" title="0">
                // For table format, we need to convert struct to key-value pairs
                // This is a simplified version - could be enhanced with reflection
                return fmt.Errorf("table format not supported for arbitrary structs - use WriteKeyValue or WriteTable")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", dw.format)</span>
        }
}

// writeJSON writes data as JSON
func (dw *DataWriter) writeJSON(data interface{}) error <span class="cov8" title="1">{
        encoder := json.NewEncoder(dw.output)
        encoder.SetIndent("", "  ")
        return encoder.Encode(data)
}</span>

// writeKeyValueTable writes key-value pairs as an aligned table
func (dw *DataWriter) writeKeyValueTable(title string, data map[string]interface{}) error <span class="cov8" title="1">{
        if title != "" </span><span class="cov8" title="1">{
                fmt.Fprintln(dw.output)
                fmt.Fprintln(dw.output, title)
        }</span>

        // Use tabwriter for consistent alignment
        <span class="cov8" title="1">w := tabwriter.NewWriter(dw.output, 0, 0, 2, ' ', 0)

        // Create ordered list of keys for consistent output
        orderedKeys := []string{"Name", "ID", "Status", "URL", "Error", "Access", "OrgID", "Created", "Updated"}

        // Print known keys in order first
        for _, key := range orderedKeys </span><span class="cov8" title="1">{
                if value, exists := data[key]; exists &amp;&amp; value != nil &amp;&amp; value != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "  %s:\t%v\t\n", key, value)
                }</span>
        }

        // Print any remaining keys
        <span class="cov8" title="1">for key, value := range data </span><span class="cov8" title="1">{
                found := false
                for _, orderedKey := range orderedKeys </span><span class="cov8" title="1">{
                        if key == orderedKey </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found &amp;&amp; value != nil &amp;&amp; value != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "  %s:\t%v\t\n", key, value)
                }</span>
        }

        <span class="cov8" title="1">w.Flush()
        fmt.Fprintln(dw.output)
        return nil</span>
}

// writeTabularData writes headers and rows as a table
func (dw *DataWriter) writeTabularData(headers []string, rows [][]string) error <span class="cov8" title="1">{
        fmt.Fprintln(dw.output)

        // Use tabwriter for consistent alignment
        w := tabwriter.NewWriter(dw.output, 0, 0, 2, ' ', 0)

        // Write headers
        for i, header := range headers </span><span class="cov8" title="1">{
                fmt.Fprint(w, header)
                if i &lt; len(headers)-1 </span><span class="cov8" title="1">{
                        fmt.Fprint(w, "\t")
                }</span>
        }
        <span class="cov8" title="1">fmt.Fprintln(w, "\t") // Trailing tab for proper termination

        // Write rows
        for _, row := range rows </span><span class="cov8" title="1">{
                for i, cell := range row </span><span class="cov8" title="1">{
                        fmt.Fprint(w, cell)
                        if i &lt; len(row)-1 </span><span class="cov8" title="1">{
                                fmt.Fprint(w, "\t")
                        }</span>
                }
                <span class="cov8" title="1">fmt.Fprintln(w, "\t")</span> // Trailing tab for proper termination
        }

        <span class="cov8" title="1">w.Flush()
        fmt.Fprintln(dw.output)
        return nil</span>
}

// TableBuilder helps build table data incrementally
type TableBuilder struct {
        headers []string
        rows    [][]string
}

// NewTableBuilder creates a new TableBuilder
func NewTableBuilder(headers ...string) *TableBuilder <span class="cov8" title="1">{
        return &amp;TableBuilder{
                headers: headers,
                rows:    [][]string{},
        }
}</span>

// AddRow adds a row to the table
func (tb *TableBuilder) AddRow(values ...string) *TableBuilder <span class="cov8" title="1">{
        tb.rows = append(tb.rows, values)
        return tb
}</span>

// Write outputs the table using the DataWriter
func (tb *TableBuilder) Write(dw *DataWriter) error <span class="cov8" title="1">{
        return dw.WriteTable(tb.headers, tb.rows)
}</span>

// KeyValueBuilder helps build key-value data
type KeyValueBuilder struct {
        title string
        data  map[string]interface{}
}

// NewKeyValueBuilder creates a new KeyValueBuilder
func NewKeyValueBuilder(title string) *KeyValueBuilder <span class="cov8" title="1">{
        return &amp;KeyValueBuilder{
                title: title,
                data:  make(map[string]interface{}),
        }
}</span>

// Add adds a key-value pair
func (kvb *KeyValueBuilder) Add(key string, value interface{}) *KeyValueBuilder <span class="cov8" title="1">{
        kvb.data[key] = value
        return kvb
}</span>

// AddIf conditionally adds a key-value pair
func (kvb *KeyValueBuilder) AddIf(condition bool, key string, value interface{}) *KeyValueBuilder <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                kvb.data[key] = value
        }</span>
        <span class="cov0" title="0">return kvb</span>
}

// Write outputs the key-value data using the DataWriter
func (kvb *KeyValueBuilder) Write(dw *DataWriter) error <span class="cov8" title="1">{
        return dw.WriteKeyValue(kvb.title, kvb.data)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package cli

import (
        "context"
        "fmt"

        "github.com/fastertools/ftl-cli/pkg/spin"
        "github.com/spf13/cobra"
)

func newRegistryCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "registry",
                Short: "Manage registry operations",
                Long:  `Manage registry operations including push, pull, and list.`,
        }

        // Add subcommands
        cmd.AddCommand(
                newRegistryPushCmd(),
                newRegistryPullCmd(),
                newRegistryListCmd(),
        )

        return cmd
}</span>

func newRegistryPushCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "push [reference]",
                Short: "Push application to registry",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        reference := args[0]

                        fmt.Printf("Pushing to registry: %s\n", reference)

                        // Use spin registry push
                        if err := spin.Registry(ctx, "push", reference); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to push to registry: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Println("Push completed successfully")
                        return nil</span>
                },
        }
}

func newRegistryPullCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "pull [reference]",
                Short: "Pull application from registry",
                Long: `Pull a Spin application from a registry.

Example:
  ftl registry pull ghcr.io/myorg/myapp:v1.0.0`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        reference := args[0]

                        fmt.Printf("Pulling from registry: %s\n", reference)

                        // Use spin registry pull
                        if err := spin.Registry(ctx, "pull", reference); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to pull from registry: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Println("Pull completed successfully")
                        return nil</span>
                },
        }
}

func newRegistryListCmd() *cobra.Command <span class="cov8" title="1">{
        var registry string

        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List applications in registry",
                Long: `List available Spin applications in a registry.

Example:
  ftl registry list --registry ghcr.io/myorg`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if registry == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("--registry flag is required")
                        }</span>

                        <span class="cov0" title="0">ctx := context.Background()
                        fmt.Printf("Listing applications in registry: %s\n", registry)

                        // Use spin registry list (if available) or catalog
                        if err := spin.Registry(ctx, "catalog", "list", registry); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to list registry contents: %w", err)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;registry, "registry", "r", "", "Registry URL to list")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package cli

import (
        "fmt"
        "io"
        "os"

        "github.com/fatih/color"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        // Version information
        version   = "dev"
        commit    = "unknown"
        buildDate = "unknown"

        // Configuration
        cfgFile string
        verbose bool
        noColor bool

        // Colors
        successColor = color.New(color.FgGreen, color.Bold)
        errorColor   = color.New(color.FgRed, color.Bold)
        infoColor    = color.New(color.FgCyan)
        warnColor    = color.New(color.FgYellow)

        // For testing - allows redirecting output
        colorOutput io.Writer = os.Stdout
)

// rootCmd represents the base command
var rootCmd = &amp;cobra.Command{
        Use:   "ftl",
        Short: "FTL - Faster Tools for AI agents",
        Long: `FTL is a comprehensive toolkit for building, composing, and deploying 
AI tools on WebAssembly. It provides everything you need to create secure,
high-performance MCP servers that can run anywhere.`,
        PersistentPreRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if noColor </span><span class="cov0" title="0">{
                        color.NoColor = true
                }</span>
        },
        Version: fmt.Sprintf("%s (commit: %s, built: %s)", version, commit, buildDate),
}

// Execute runs the root command
func Execute() error <span class="cov8" title="1">{
        return rootCmd.Execute()
}</span>

// SetVersion sets the version information
func SetVersion(v, c, b string) <span class="cov8" title="1">{
        version = v
        commit = c
        buildDate = b
        rootCmd.Version = fmt.Sprintf("%s (commit: %s, built: %s)", version, commit, buildDate)
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Global flags
        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is ./ftl.yaml)")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "verbose output")
        rootCmd.PersistentFlags().BoolVar(&amp;noColor, "no-color", false, "disable colored output")

        // Bind flags to viper
        _ = viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose"))
        _ = viper.BindPFlag("no-color", rootCmd.PersistentFlags().Lookup("no-color"))

        // Add commands
        rootCmd.AddCommand(
                newInitCmd(),
                newAddCmd(),
                newBuildCmd(),
                newTestCmd(),
                newComponentCmd(),
                newDeployCmd(),
                newAuthCmd(),
                newUpCmd(),
                newRegistryCmd(),
                newSynthCmd(),
                newListCmd(),
                newStatusCmd(),
                newDeleteCmd(),
        )
}</span>

// initConfig reads in config file and ENV variables if set
func initConfig() <span class="cov8" title="1">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov8" title="1"> {
                viper.AddConfigPath(".")
                viper.SetConfigType("yaml")
                viper.SetConfigName("ftl")
        }</span>

        <span class="cov8" title="1">viper.SetEnvPrefix("FTL")
        viper.AutomaticEnv()

        // Read config file if it exists
        if err := viper.ReadInConfig(); err == nil </span><span class="cov8" title="1">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, infoColor.Sprint("Using config file:"), viper.ConfigFileUsed())
                }</span>
        }
}

// Helper functions for consistent output

// Success prints a success message
func Success(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Println(successColor.Sprintf("✓ "+format, args...))
}</span>

// Error prints an error message
func Error(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintln(os.Stderr, errorColor.Sprintf("✗ "+format, args...))
}</span>

// Info prints an info message
func Info(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Println(infoColor.Sprintf("ℹ "+format, args...))
}</span>

// Warn prints a warning message
func Warn(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintln(os.Stderr, warnColor.Sprintf("⚠ "+format, args...))
}</span>

// Debug prints a debug message if verbose mode is enabled
func Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        if IsVerbose() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, color.New(color.FgMagenta).Sprintf("» "+format, args...))
        }</span>
}

// Fatal prints an error and exits
func Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        Error(format, args...)
        os.Exit(1)
}</span>

// PrintStep prints a step in a process
func PrintStep(step int, total int, message string) <span class="cov8" title="1">{
        fmt.Printf("[%d/%d] %s\n", step, total, message)
}</span>

// IsVerbose returns true if verbose mode is enabled
func IsVerbose() bool <span class="cov8" title="1">{
        return viper.GetBool("verbose")
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package cli

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/uuid"
        "github.com/spf13/cobra"

        "github.com/fastertools/ftl-cli/internal/api"
        "github.com/fastertools/ftl-cli/internal/auth"
)

func newStatusCmd() *cobra.Command <span class="cov8" title="1">{
        var format string

        cmd := &amp;cobra.Command{
                Use:   "status &lt;app-id|app-name&gt;",
                Short: "Get status of an FTL application",
                Long:  `Get detailed status information for a specific FTL application.`,
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        return runStatus(ctx, args[0], format)
                }</span>,
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;format, "output", "o", "table", "Output format (table, json)")

        return cmd</span>
}

// Allow overriding for tests
var runStatus = runStatusImpl

func runStatusImpl(ctx context.Context, appIdentifier string, format string) error <span class="cov0" title="0">{
        // Initialize auth manager
        store, err := auth.NewKeyringStore()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize credential store: %w", err)
        }</span>
        <span class="cov0" title="0">authManager := auth.NewManager(store, nil)

        // Check authentication
        if _, err := authManager.GetToken(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not logged in to FTL. Run 'ftl auth login' first")
        }</span>

        // Create API client
        <span class="cov0" title="0">apiClient, err := api.NewFTLClient(authManager, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create API client: %w", err)
        }</span>

        // Determine if identifier is UUID or name
        <span class="cov0" title="0">var app *api.App

        // Try to parse as UUID
        if _, err := uuid.Parse(appIdentifier); err == nil </span><span class="cov0" title="0">{
                // It's a UUID, get app directly
                app, err = apiClient.GetApp(ctx, appIdentifier)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get app: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Not a UUID, assume it's a name - list apps with name filter
                response, err := apiClient.ListApps(ctx, &amp;api.ListAppsParams{
                        Name: &amp;appIdentifier,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list apps: %w", err)
                }</span>

                <span class="cov0" title="0">if len(response.Apps) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("application '%s' not found", appIdentifier)
                }</span>

                // Get full details using the UUID
                <span class="cov0" title="0">appID := response.Apps[0].AppId.String()
                app, err = apiClient.GetApp(ctx, appID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get app details: %w", err)
                }</span>
        }

        // Use shared DataWriter for consistent output
        <span class="cov0" title="0">dw := NewDataWriter(colorOutput, format)

        switch format </span>{
        case "json":<span class="cov0" title="0">
                return dw.WriteStruct(app)</span>
        case "table":<span class="cov0" title="0">
                return displayAppStatusTable(app)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid output format: %s (use 'table' or 'json')", format)</span>
        }
}

func displayAppStatusTable(app *api.App) error <span class="cov8" title="1">{
        dw := NewDataWriter(colorOutput, "table")
        kvb := NewKeyValueBuilder("Application Details")

        // Add basic fields
        kvb.Add("Name", app.AppName)
        kvb.Add("ID", app.AppId.String())
        kvb.Add("Status", app.Status)

        // Add optional fields
        if app.ProviderUrl != nil &amp;&amp; *app.ProviderUrl != "" </span><span class="cov8" title="1">{
                kvb.Add("URL", *app.ProviderUrl)
        }</span>

        <span class="cov8" title="1">if app.ProviderError != nil &amp;&amp; *app.ProviderError != "" </span><span class="cov8" title="1">{
                kvb.Add("Error", *app.ProviderError)
        }</span>

        // Timestamps
        <span class="cov8" title="1">kvb.Add("Created", app.CreatedAt)
        kvb.Add("Updated", app.UpdatedAt)

        // Access control
        if app.AccessControl != nil </span><span class="cov8" title="1">{
                access := strings.ToLower(string(*app.AccessControl))
                kvb.Add("Access", access)

                // Show additional auth details based on access type
                if *app.AccessControl == api.AppAccessControlOrg &amp;&amp; app.OrgId != nil </span><span class="cov0" title="0">{
                        kvb.Add("OrgID", *app.OrgId)
                }</span>

                <span class="cov8" title="1">if *app.AccessControl == api.AppAccessControlOrg &amp;&amp; app.AllowedRoles != nil &amp;&amp; len(*app.AllowedRoles) &gt; 0 </span><span class="cov0" title="0">{
                        kvb.Add("AllowedRoles", strings.Join(*app.AllowedRoles, ", "))
                }</span>

                <span class="cov8" title="1">if *app.AccessControl == api.AppAccessControlCustom &amp;&amp; app.CustomAuth != nil </span><span class="cov0" title="0">{
                        kvb.Add("JWTIssuer", app.CustomAuth.Issuer)
                        kvb.Add("JWTAudience", app.CustomAuth.Audience)
                }</span>
        }

        <span class="cov8" title="1">return kvb.Write(dw)</span>
}

// displayAppStatusJSON is no longer needed - using shared DataWriter
</pre>
		
		<pre class="file" id="file22" style="display: none">package cli

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/fastertools/ftl-cli/internal/synthesis"
        "github.com/spf13/cobra"
)

// synthCmd represents the synth command
func newSynthCmd() *cobra.Command <span class="cov8" title="1">{
        var outputFile string

        cmd := &amp;cobra.Command{
                Use:   "synth [file]",
                Short: "Synthesize a spin.toml from FTL configuration",
                Long: `Synthesize a spin.toml manifest from an FTL configuration file.

Supports Go, YAML, JSON, and CUE input formats.

Examples:
  # Auto-detect config file (looks for ftl.yaml, ftl.json, etc.)
  ftl synth

  # Synthesize from specific file
  ftl synth platform.yaml

  # Write to file
  ftl synth platform.yaml -o spin.toml

  # Synthesize from stdin (YAML/JSON only)
  cat platform.yaml | ftl synth -`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        var input []byte
                        var filename string
                        var err error

                        // Determine input source
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                // No args - look for default config files
                                filename, err = findConfigFile()
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">input, err = os.ReadFile(filename)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to read file %s: %w", filename, err)
                                }</span>
                                // Set args so synthesizeFromInput knows the filename
                                <span class="cov0" title="0">args = []string{filename}</span>
                        } else<span class="cov0" title="0"> if args[0] == "-" </span><span class="cov0" title="0">{
                                // Read from stdin explicitly
                                input, err = io.ReadAll(os.Stdin)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to read from stdin: %w", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Read from specified file
                                filename = args[0]
                                input, err = os.ReadFile(filename)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to read file: %w", err)
                                }</span>
                        }

                        // Detect format and synthesize
                        <span class="cov0" title="0">manifest, err := synthesizeFromInput(input, args)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("synthesis failed: %w", err)
                        }</span>

                        // Output result
                        <span class="cov0" title="0">if outputFile != "" </span><span class="cov0" title="0">{
                                err = os.WriteFile(outputFile, []byte(manifest), 0644)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to write output file: %w", err)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("Generated %s\n", outputFile)</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Print(manifest)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;outputFile, "output", "o", "", "Output file (default: stdout)")

        return cmd</span>
}

// synthesizeFromInput detects the format and synthesizes accordingly
func synthesizeFromInput(input []byte, args []string) (string, error) <span class="cov8" title="1">{
        // Detect format based on file extension or content
        var format string
        var filename string
        if len(args) &gt; 0 &amp;&amp; args[0] != "-" </span><span class="cov0" title="0">{
                filename = args[0]
                ext := strings.ToLower(filepath.Ext(filename))
                switch ext </span>{
                case ".go":<span class="cov0" title="0">
                        format = "go"</span>
                case ".yaml", ".yml":<span class="cov0" title="0">
                        format = "yaml"</span>
                case ".json":<span class="cov0" title="0">
                        format = "json"</span>
                case ".cue":<span class="cov0" title="0">
                        format = "cue"</span>
                default:<span class="cov0" title="0">
                        format = detectFormat(input)</span>
                }
        } else<span class="cov8" title="1"> {
                format = detectFormat(input)
        }</span>

        <span class="cov8" title="1">switch format </span>{
        case "go":<span class="cov0" title="0">
                return synthesizeFromGo(filename)</span>
        case "yaml":<span class="cov8" title="1">
                return synthesizeFromYAML(input)</span>
        case "json":<span class="cov8" title="1">
                return synthesizeFromJSON(input)</span>
        case "cue":<span class="cov0" title="0">
                return synthesizeFromCUE(input)</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unable to detect input format")</span>
        }
}

// detectFormat tries to detect the format from content
func detectFormat(input []byte) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(string(input))
        if strings.HasPrefix(trimmed, "{") </span><span class="cov8" title="1">{
                return "json"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(trimmed, "package ") </span><span class="cov8" title="1">{
                return "cue"
        }</span>
        // Default to YAML
        <span class="cov8" title="1">return "yaml"</span>
}

// synthesizeFromYAML converts YAML to spin.toml
func synthesizeFromYAML(input []byte) (string, error) <span class="cov8" title="1">{
        // Use CUE-first synthesizer for direct YAML processing
        synth := synthesis.NewSynthesizer()
        return synth.SynthesizeYAML(input)
}</span>

// synthesizeFromJSON converts JSON to spin.toml
func synthesizeFromJSON(input []byte) (string, error) <span class="cov8" title="1">{
        // Use CUE-first synthesizer for direct JSON processing
        synth := synthesis.NewSynthesizer()
        return synth.SynthesizeJSON(input)
}</span>

// synthesizeFromGo runs a Go file and captures its output
func synthesizeFromGo(filename string) (string, error) <span class="cov0" title="0">{
        // Get absolute path to ensure the file can be found
        absPath, err := filepath.Abs(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        // Check if file exists
        <span class="cov0" title="0">if _, err := os.Stat(absPath); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file not found: %w", err)
        }</span>

        // Run the Go file and capture its output
        <span class="cov0" title="0">cmd := exec.Command("go", "run", absPath)

        // Set the working directory to the file's directory
        // This ensures relative imports work correctly
        cmd.Dir = filepath.Dir(absPath)

        // Capture stdout
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // Try to get error details if available
                if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to run Go file: %w\nstderr: %s", err, exitErr.Stderr)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to run Go file: %w", err)</span>
        }

        // The Go program should output the manifest to stdout
        <span class="cov0" title="0">manifest := string(output)

        // Basic validation - check if it looks like a manifest
        if !strings.Contains(manifest, "spin_manifest_version") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Go program did not output a valid spin.toml manifest")
        }</span>

        <span class="cov0" title="0">return manifest, nil</span>
}

// synthesizeFromCUE converts CUE to spin.toml
func synthesizeFromCUE(input []byte) (string, error) <span class="cov8" title="1">{
        // Use CUE-first synthesizer
        synth := synthesis.NewSynthesizer()
        return synth.SynthesizeCUE(string(input))
}</span>

// findConfigFile looks for FTL configuration files in priority order
func findConfigFile() (string, error) <span class="cov0" title="0">{
        // Define the search order for config files
        configFiles := []string{
                "ftl.yaml",
                "ftl.yml",
                "ftl.json",
                "main.go",     // Common Go entry point
                "platform.go", // Alternative Go name
                "ftl.cue",
                "app.cue", // Alternative CUE name
        }

        // Check each file in order
        for _, file := range configFiles </span><span class="cov0" title="0">{
                if _, err := os.Stat(file); err == nil </span><span class="cov0" title="0">{
                        // File exists
                        fmt.Fprintf(os.Stderr, "Using config file: %s\n", file)
                        return file, nil
                }</span>
        }

        // No config file found
        <span class="cov0" title="0">return "", fmt.Errorf("no FTL configuration file found. Looked for: %v\n\nCreate one of these files or specify a file explicitly", configFiles)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package cli

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
)

func newTestCmd() *cobra.Command <span class="cov8" title="1">{
        var coverage bool
        var verbose bool

        cmd := &amp;cobra.Command{
                Use:   "test [path]",
                Short: "Run tests for the FTL application",
                Long: `Run tests for the FTL application and its components.

Runs 'go test' on the specified path or current directory.

Examples:
  ftl test             # Run tests in current directory
  ftl test ./...       # Run all tests recursively
  ftl test -c          # Run with coverage
  ftl test -v ./pkg    # Run with verbose output`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        path := "./..."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                path = args[0]
                        }</span>

                        // Build go test command
                        <span class="cov8" title="1">testArgs := []string{"test"}

                        if verbose </span><span class="cov8" title="1">{
                                testArgs = append(testArgs, "-v")
                        }</span>

                        <span class="cov8" title="1">if coverage </span><span class="cov8" title="1">{
                                testArgs = append(testArgs, "-cover")
                        }</span>

                        <span class="cov8" title="1">testArgs = append(testArgs, path)

                        // Check if we're in a Go module
                        if _, err := os.Stat("go.mod"); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("no go.mod found in current directory")
                        }</span>

                        <span class="cov8" title="1">fmt.Printf("Running: go %s\n", strings.Join(testArgs, " "))

                        // Execute go test
                        testCmd := exec.Command("go", testArgs...)
                        testCmd.Stdout = os.Stdout
                        testCmd.Stderr = os.Stderr
                        testCmd.Dir, _ = filepath.Abs(".")

                        return testCmd.Run()</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVarP(&amp;coverage, "coverage", "c", false, "Run tests with coverage")
        cmd.Flags().BoolVarP(&amp;verbose, "verbose", "v", false, "Verbose test output")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package cli

import (
        "bytes"
        "io"
        "os"
        "testing"

        "github.com/AlecAivazis/survey/v2"
        "github.com/spf13/cobra"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
)

// TestCommandExecution helps test cobra command execution
type TestCommandExecution struct {
        Command      *cobra.Command
        Args         []string
        ExpectError  bool
        ExpectOutput []string
        Setup        func(t *testing.T) string
        Cleanup      func(string)
        Validate     func(t *testing.T, output string, err error)
}

// ExecuteCommandTest runs a command test with proper setup/teardown
func ExecuteCommandTest(t *testing.T, test TestCommandExecution) <span class="cov0" title="0">{
        // Setup
        var tmpDir string
        if test.Setup != nil </span><span class="cov0" title="0">{
                tmpDir = test.Setup(t)
                if test.Cleanup != nil </span><span class="cov0" title="0">{
                        defer test.Cleanup(tmpDir)
                }</span>
        }

        // Capture output
        <span class="cov0" title="0">var stdout, stderr bytes.Buffer
        test.Command.SetOut(&amp;stdout)
        test.Command.SetErr(&amp;stderr)
        test.Command.SetArgs(test.Args)

        // Execute
        err := test.Command.Execute()

        // Check error expectation
        if test.ExpectError </span><span class="cov0" title="0">{
                assert.Error(t, err)
        }</span> else<span class="cov0" title="0"> {
                assert.NoError(t, err)
        }</span>

        // Check output expectations
        <span class="cov0" title="0">output := stdout.String() + stderr.String()
        for _, expected := range test.ExpectOutput </span><span class="cov0" title="0">{
                assert.Contains(t, output, expected)
        }</span>

        // Custom validation
        <span class="cov0" title="0">if test.Validate != nil </span><span class="cov0" title="0">{
                test.Validate(t, output, err)
        }</span>
}

// CaptureOutput captures stdout/stderr during function execution
func CaptureOutput(t *testing.T, fn func()) string <span class="cov8" title="1">{
        t.Helper()

        oldStdout := os.Stdout
        oldStderr := os.Stderr
        r, w, err := os.Pipe()
        require.NoError(t, err)

        os.Stdout = w
        os.Stderr = w

        fn()

        w.Close()
        os.Stdout = oldStdout
        os.Stderr = oldStderr

        out, err := io.ReadAll(r)
        require.NoError(t, err)

        return string(out)
}</span>

// MockSurveyAskOne mocks survey.AskOne for testing interactive prompts
func MockSurveyAskOne(response interface{}) func(p survey.Prompt, response interface{}, opts ...survey.AskOpt) error <span class="cov0" title="0">{
        return func(p survey.Prompt, resp interface{}, opts ...survey.AskOpt) error </span><span class="cov0" title="0">{
                switch v := resp.(type) </span>{
                case *string:<span class="cov0" title="0">
                        *v = response.(string)</span>
                case *bool:<span class="cov0" title="0">
                        *v = response.(bool)</span>
                case *int:<span class="cov0" title="0">
                        *v = response.(int)</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}

// MockSurveyAsk mocks survey.Ask for testing multiple prompts
func MockSurveyAsk(responses map[string]interface{}) func(qs []*survey.Question, response interface{}, opts ...survey.AskOpt) error <span class="cov0" title="0">{
        return func(qs []*survey.Question, response interface{}, opts ...survey.AskOpt) error </span><span class="cov0" title="0">{
                // Use reflection to set fields based on question names
                // This is simplified - in real implementation would use reflection
                return nil
        }</span>
}

// CreateTestProject creates a temporary test project structure
func CreateTestProject(t *testing.T, format string) string <span class="cov0" title="0">{
        tmpDir := t.TempDir()

        switch format </span>{
        case "yaml":<span class="cov0" title="0">
                content := `application:
  name: test-app
  version: "0.1.0"
components: []
triggers: []`
                err := os.WriteFile(tmpDir+"/ftl.yaml", []byte(content), 0644)
                require.NoError(t, err)</span>

        case "json":<span class="cov0" title="0">
                content := `{
  "application": {
    "name": "test-app",
    "version": "0.1.0"
  },
  "components": [],
  "triggers": []
}`
                err := os.WriteFile(tmpDir+"/ftl.json", []byte(content), 0644)
                require.NoError(t, err)</span>

        case "cue":<span class="cov0" title="0">
                content := `package app

application: {
        name: "test-app"
        version: "0.1.0"
}
components: []`
                err := os.WriteFile(tmpDir+"/app.cue", []byte(content), 0644)
                require.NoError(t, err)</span>

        case "go":<span class="cov0" title="0">
                mainContent := `package main

import (
        "fmt"
        "github.com/fastertools/ftl-cli/internal/synthesis"
)

func main() {
        cdk := synthesis.NewCDK()
        app := cdk.NewApp("test-app")
        manifest, _ := app.Build().Synthesize()
        fmt.Print(manifest)
}`
                err := os.WriteFile(tmpDir+"/main.go", []byte(mainContent), 0644)
                require.NoError(t, err)

                modContent := `module test-app

go 1.21

require github.com/fastertools/ftl-cli/go/ftl v0.0.0`
                err = os.WriteFile(tmpDir+"/go.mod", []byte(modContent), 0644)
                require.NoError(t, err)</span>
        }

        // Create .gitignore
        <span class="cov0" title="0">gitignoreContent := `.spin/
spin.toml
*.wasm`
        err := os.WriteFile(tmpDir+"/.gitignore", []byte(gitignoreContent), 0644)
        require.NoError(t, err)

        return tmpDir</span>
}

// CreateTestComponent creates a test component directory structure
func CreateTestComponent(t *testing.T, dir, name, language string) <span class="cov0" title="0">{
        componentDir := dir + "/" + name
        err := os.MkdirAll(componentDir, 0755)
        require.NoError(t, err)

        switch language </span>{
        case "rust":<span class="cov0" title="0">
                err = os.MkdirAll(componentDir+"/src", 0755)
                require.NoError(t, err)
                err = os.WriteFile(componentDir+"/src/lib.rs", []byte("// Rust component"), 0644)
                require.NoError(t, err)
                err = os.WriteFile(componentDir+"/Cargo.toml", []byte("[package]\nname = \""+name+"\""), 0644)
                require.NoError(t, err)</span>

        case "typescript":<span class="cov0" title="0">
                err = os.MkdirAll(componentDir+"/src", 0755)
                require.NoError(t, err)
                err = os.WriteFile(componentDir+"/src/index.ts", []byte("// TypeScript component"), 0644)
                require.NoError(t, err)
                err = os.WriteFile(componentDir+"/package.json", []byte(`{"name": "`+name+`"}`), 0644)
                require.NoError(t, err)</span>

        case "python":<span class="cov0" title="0">
                err = os.MkdirAll(componentDir+"/src", 0755)
                require.NoError(t, err)
                err = os.WriteFile(componentDir+"/src/main.py", []byte("# Python component"), 0644)
                require.NoError(t, err)
                err = os.WriteFile(componentDir+"/pyproject.toml", []byte("[project]\nname = \""+name+"\""), 0644)
                require.NoError(t, err)</span>

        case "go":<span class="cov0" title="0">
                err = os.WriteFile(componentDir+"/main.go", []byte("package main\n// Go component"), 0644)
                require.NoError(t, err)
                err = os.WriteFile(componentDir+"/go.mod", []byte("module "+name), 0644)
                require.NoError(t, err)</span>
        }

        // Create Makefile
        <span class="cov0" title="0">makefileContent := `build:
        @echo "Building ` + name + `"

test:
        @echo "Testing ` + name + `"`
        err = os.WriteFile(componentDir+"/Makefile", []byte(makefileContent), 0644)
        require.NoError(t, err)</span>
}

// TestConfig holds test configuration for commands
type TestConfig struct {
        WorkDir      string
        ConfigFormat string
        Components   []TestComponent
}

type TestComponent struct {
        Name     string
        Language string
        Source   string
}

// SetupTestEnvironment creates a complete test environment
func SetupTestEnvironment(t *testing.T, config TestConfig) string <span class="cov0" title="0">{
        if config.WorkDir == "" </span><span class="cov0" title="0">{
                config.WorkDir = t.TempDir()
        }</span>

        // Save current directory
        <span class="cov0" title="0">oldWd, err := os.Getwd()
        require.NoError(t, err)

        // Change to test directory
        err = os.Chdir(config.WorkDir)
        require.NoError(t, err)

        // Restore on cleanup
        t.Cleanup(func() </span><span class="cov0" title="0">{
                _ = os.Chdir(oldWd)
        }</span>)

        // Create project structure
        <span class="cov0" title="0">if config.ConfigFormat != "" </span><span class="cov0" title="0">{
                CreateTestProject(t, config.ConfigFormat)
        }</span>

        // Create components
        <span class="cov0" title="0">for _, comp := range config.Components </span><span class="cov0" title="0">{
                CreateTestComponent(t, config.WorkDir, comp.Name, comp.Language)
        }</span>

        <span class="cov0" title="0">return config.WorkDir</span>
}

// AssertCommandOutput checks that command output contains expected strings
func AssertCommandOutput(t *testing.T, cmd *cobra.Command, args []string, expected ...string) <span class="cov0" title="0">{
        var buf bytes.Buffer
        cmd.SetOut(&amp;buf)
        cmd.SetErr(&amp;buf)
        cmd.SetArgs(args)

        err := cmd.Execute()
        require.NoError(t, err)

        output := buf.String()
        for _, exp := range expected </span><span class="cov0" title="0">{
                assert.Contains(t, output, exp)
        }</span>
}

// AssertCommandError checks that command fails with expected error
func AssertCommandError(t *testing.T, cmd *cobra.Command, args []string, expectedErr string) <span class="cov0" title="0">{
        var buf bytes.Buffer
        cmd.SetOut(&amp;buf)
        cmd.SetErr(&amp;buf)
        cmd.SetArgs(args)

        err := cmd.Execute()
        require.Error(t, err)
        assert.Contains(t, err.Error(), expectedErr)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"

        "github.com/fastertools/ftl-cli/internal/synthesis"
        "github.com/fastertools/ftl-cli/pkg/spin"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

func newUpCmd() *cobra.Command <span class="cov8" title="1">{
        var build bool
        var watch bool
        var skipSynth bool
        var configFile string

        cmd := &amp;cobra.Command{
                Use:   "up",
                Short: "Run the FTL application locally",
                Long:  `Run the FTL application locally with hot reload support.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        ctx := context.Background()

                        // Color helpers
                        blue := color.New(color.FgBlue).SprintFunc()
                        green := color.New(color.FgGreen).SprintFunc()
                        yellow := color.New(color.FgYellow).SprintFunc()

                        // Ensure spin is installed
                        if err := spin.EnsureInstalled(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Auto-detect config file if not specified
                        <span class="cov8" title="1">if configFile == "" </span><span class="cov8" title="1">{
                                // Try to detect the config format
                                if _, err := os.Stat("ftl.yaml"); err == nil </span><span class="cov8" title="1">{
                                        configFile = "ftl.yaml"
                                }</span> else<span class="cov8" title="1"> if _, err := os.Stat("ftl.json"); err == nil </span><span class="cov0" title="0">{
                                        configFile = "ftl.json"
                                }</span> else<span class="cov8" title="1"> if _, err := os.Stat("app.cue"); err == nil </span><span class="cov0" title="0">{
                                        configFile = "app.cue"
                                }</span> else<span class="cov8" title="1"> if _, err := os.Stat("main.go"); err == nil </span><span class="cov0" title="0">{
                                        configFile = "main.go"
                                }</span>
                        }

                        // Check if config file exists and synthesize
                        <span class="cov8" title="1">if configFile != "" &amp;&amp; !skipSynth </span><span class="cov0" title="0">{
                                if _, err := os.Stat(configFile); err == nil </span><span class="cov0" title="0">{
                                        fmt.Printf("%s Synthesizing spin.toml from %s\n", blue("→"), configFile)

                                        // Use unified synthesis helper
                                        manifest, err := synthesis.SynthesizeFromConfig(configFile)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("synthesis failed: %w", err)
                                        }</span>

                                        // Write spin.toml
                                        <span class="cov0" title="0">if err := os.WriteFile("spin.toml", []byte(manifest), 0644); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to write spin.toml: %w", err)
                                        }</span>

                                        <span class="cov0" title="0">fmt.Printf("%s Generated spin.toml\n", green("✓"))</span>
                                }
                        } else<span class="cov8" title="1"> if configFile == "" &amp;&amp; !skipSynth </span><span class="cov8" title="1">{
                                // No config file found, check for spin.toml
                                if _, err := os.Stat("spin.toml"); os.IsNotExist(err) </span><span class="cov8" title="1">{
                                        return fmt.Errorf("no ftl.yaml, ftl.json, app.cue, or spin.toml found. Run 'ftl init' first")
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("%s No FTL config found, using existing spin.toml\n", yellow("ℹ"))</span>
                        }

                        // Build if requested
                        <span class="cov8" title="1">if build </span><span class="cov0" title="0">{
                                fmt.Printf("%s Building application first...\n", blue("→"))
                                if err := spin.Build(ctx); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to build: %w", err)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("%s Build completed\n", green("✓"))</span>
                        }

                        <span class="cov8" title="1">fmt.Printf("%s Starting FTL application...\n", blue("→"))

                        // Run with watch if requested
                        if watch </span><span class="cov8" title="1">{
                                fmt.Printf("%s Starting with watch mode...\n", yellow("ℹ"))
                                if err := spin.Watch(ctx); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed to start with watch: %w", err)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Run normally
                                if err := spin.Up(ctx); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed to start: %w", err)
                                }</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVarP(&amp;build, "build", "b", false, "Build before running")
        cmd.Flags().BoolVarP(&amp;watch, "watch", "w", false, "Watch for changes and reload")
        cmd.Flags().BoolVar(&amp;skipSynth, "skip-synth", false, "Skip synthesis of spin.toml from FTL config")
        cmd.Flags().StringVarP(&amp;configFile, "config", "c", "", "Configuration file to synthesize (auto-detects if not specified)")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package ftl

import (
        "encoding/json"
        "fmt"
)

// DeploymentRequest represents a deployment request to the FTL platform
// This is the contract between CLI and platform backend
type DeploymentRequest struct {
        // The FTL application configuration
        Application *Application `json:"application"`

        // Environment-specific variables
        Variables map[string]string `json:"variables,omitempty"`

        // Environment name (e.g., production, staging)
        Environment string `json:"environment,omitempty"`

        // Access control override (if different from app config)
        AccessControl *AccessMode `json:"access_control,omitempty"`

        // Custom auth configuration (for custom access mode)
        CustomAuth *CustomAuthConfig `json:"custom_auth,omitempty"`

        // Allowed roles for org access mode
        AllowedRoles []string `json:"allowed_roles,omitempty"`
}

// CustomAuthConfig represents custom authentication configuration
type CustomAuthConfig struct {
        Issuer   string   `json:"issuer"`
        Audience []string `json:"audience"`
}

// DeploymentResponse represents the response from a deployment request
type DeploymentResponse struct {
        DeploymentID string `json:"deployment_id"`
        AppID        string `json:"app_id"`
        AppName      string `json:"app_name"`
        Status       string `json:"status"`
        Message      string `json:"message,omitempty"`
}

// ComponentStatus represents the status of a component in the deployment
type ComponentStatus struct {
        ID       string `json:"id"`
        Status   string `json:"status"`
        Registry string `json:"registry,omitempty"`
        Package  string `json:"package,omitempty"`
        Version  string `json:"version,omitempty"`
        Error    string `json:"error,omitempty"`
}

// DeploymentStatus represents the overall deployment status
type DeploymentStatus struct {
        DeploymentID string            `json:"deployment_id"`
        Status       string            `json:"status"`
        ProviderURL  string            `json:"provider_url,omitempty"`
        Components   []ComponentStatus `json:"components"`
        Error        string            `json:"error,omitempty"`
        UpdatedAt    string            `json:"updated_at"`
}

// PrepareDeployment prepares a deployment request from an FTL application
func PrepareDeployment(app *Application, opts DeploymentOptions) (*DeploymentRequest, error) <span class="cov0" title="0">{
        // Validate the application
        if err := app.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid application: %w", err)
        }</span>

        // Ensure all local components have been pushed to registry
        <span class="cov0" title="0">for _, comp := range app.Components </span><span class="cov0" title="0">{
                if comp.Source.IsLocal() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("component %s has local source, must be pushed to registry first", comp.ID)
                }</span>
        }

        <span class="cov0" title="0">req := &amp;DeploymentRequest{
                Application: app,
                Variables:   opts.Variables,
                Environment: opts.Environment,
        }

        // Apply access control override if specified
        if opts.AccessControl != "" </span><span class="cov0" title="0">{
                mode := AccessMode(opts.AccessControl)
                req.AccessControl = &amp;mode
        }</span>

        // Add custom auth if needed
        <span class="cov0" title="0">if app.Access == AccessCustom || (req.AccessControl != nil &amp;&amp; *req.AccessControl == AccessCustom) </span><span class="cov0" title="0">{
                if app.Auth.Provider == AuthProviderCustom </span><span class="cov0" title="0">{
                        req.CustomAuth = &amp;CustomAuthConfig{
                                Issuer:   app.Auth.JWTIssuer,
                                Audience: []string{app.Auth.JWTAudience},
                        }
                }</span>
        }

        // Add allowed roles for org mode
        <span class="cov0" title="0">if (app.Access == AccessOrg || (req.AccessControl != nil &amp;&amp; *req.AccessControl == AccessOrg)) &amp;&amp; len(opts.AllowedRoles) &gt; 0 </span><span class="cov0" title="0">{
                req.AllowedRoles = opts.AllowedRoles
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// DeploymentOptions contains options for deployment
type DeploymentOptions struct {
        Environment   string
        Variables     map[string]string
        AccessControl string
        AllowedRoles  []string
}

// ProcessDeploymentRequest processes a deployment request on the platform side
// This is what the backend Lambda would use
func ProcessDeploymentRequest(req *DeploymentRequest) (*SpinManifest, error) <span class="cov0" title="0">{
        // Apply any overrides from the deployment request
        app := req.Application

        if req.AccessControl != nil </span><span class="cov0" title="0">{
                app.Access = *req.AccessControl
        }</span>

        // Set defaults
        <span class="cov0" title="0">app.SetDefaults()

        // Validate
        if err := app.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid application in deployment request: %w", err)
        }</span>

        // Synthesize the Spin manifest
        <span class="cov0" title="0">synth := NewSynthesizer()
        manifest, err := synth.SynthesizeToSpin(app)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to synthesize manifest: %w", err)
        }</span>

        // Apply deployment variables to the manifest
        <span class="cov0" title="0">if len(req.Variables) &gt; 0 </span><span class="cov0" title="0">{
                if manifest.Variables == nil </span><span class="cov0" title="0">{
                        manifest.Variables = make(map[string]SpinVariable)
                }</span>

                <span class="cov0" title="0">for key, value := range req.Variables </span><span class="cov0" title="0">{
                        manifest.Variables[key] = SpinVariable{
                                Default: value,
                        }
                }</span>
        }

        <span class="cov0" title="0">return manifest, nil</span>
}

// MarshalJSON implements custom JSON marshalling for DeploymentRequest
func (d *DeploymentRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        // We want to ensure the Application is properly serialized
        type Alias DeploymentRequest
        return json.Marshal(&amp;struct {
                *Alias
        }{
                Alias: (*Alias)(d),
        })
}</span>

// UnmarshalJSON implements custom JSON unmarshalling for DeploymentRequest
func (d *DeploymentRequest) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type Alias DeploymentRequest
        aux := &amp;struct {
                *Alias
        }{
                Alias: (*Alias)(d),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package ftl

import (
        "encoding/base64"
        "fmt"
        "strings"
)

// ECRAuth represents parsed ECR authentication credentials
type ECRAuth struct {
        Registry string
        Username string
        Password string
}

// ParseECRToken decodes an ECR authorization token into usable credentials
// This is useful for Docker login and other ECR authentication needs
func ParseECRToken(registryURI string, authToken string) (*ECRAuth, error) <span class="cov0" title="0">{
        // Decode the base64 authorization token
        decoded, err := base64.StdEncoding.DecodeString(authToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode ECR token: %w", err)
        }</span>

        // Extract username and password (format is "AWS:password")
        <span class="cov0" title="0">parts := strings.SplitN(string(decoded), ":", 2)
        if len(parts) != 2 || parts[0] != "AWS" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ECR token format")
        }</span>

        // Clean up registry URI (remove protocol if present)
        <span class="cov0" title="0">registry := strings.TrimPrefix(registryURI, "https://")
        registry = strings.TrimPrefix(registry, "http://")

        return &amp;ECRAuth{
                Registry: registry,
                Username: parts[0],
                Password: parts[1],
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package ftl

import (
        "bytes"
        _ "embed"
        "encoding/json"
        "fmt"
        "strings"

        "cuelang.org/go/cue"
        "cuelang.org/go/cue/cuecontext"
        cuejson "cuelang.org/go/encoding/json"
        "cuelang.org/go/encoding/toml"
        "gopkg.in/yaml.v3"
)

// Embed the CUE patterns directly in the package
//
//go:embed patterns.cue
var cuePatterns string

// SpinManifest represents the synthesized Spin manifest
type SpinManifest struct {
        SpinManifestVersion int                      `json:"spin_manifest_version" toml:"spin_manifest_version"`
        Application         SpinApplication          `json:"application" toml:"application"`
        Component           map[string]SpinComponent `json:"component" toml:"component"`
        Trigger             SpinTrigger              `json:"trigger" toml:"trigger"`
        Variables           map[string]SpinVariable  `json:"variables,omitempty" toml:"variables,omitempty"`
}

// SpinApplication represents the application section of a Spin manifest
type SpinApplication struct {
        Name        string `json:"name" toml:"name"`
        Version     string `json:"version,omitempty" toml:"version,omitempty"`
        Description string `json:"description,omitempty" toml:"description,omitempty"`
}

// SpinComponent represents a component in the Spin manifest
type SpinComponent struct {
        Source               interface{}       `json:"source" toml:"source"`
        Build                *BuildConfig      `json:"build,omitempty" toml:"build,omitempty"`
        Variables            map[string]string `json:"variables,omitempty" toml:"variables,omitempty"`
        AllowedOutboundHosts []string          `json:"allowed_outbound_hosts,omitempty" toml:"allowed_outbound_hosts,omitempty"`
}

// SpinTrigger represents the trigger configuration
type SpinTrigger struct {
        HTTP []SpinHTTPTrigger `json:"http" toml:"http"`
}

// SpinHTTPTrigger represents an HTTP trigger
type SpinHTTPTrigger struct {
        Route     interface{} `json:"route" toml:"route"`
        Component string      `json:"component" toml:"component"`
}

// SpinVariable represents a Spin variable
type SpinVariable struct {
        Default  string `json:"default,omitempty" toml:"default,omitempty"`
        Required bool   `json:"required,omitempty" toml:"required,omitempty"`
        Secret   bool   `json:"secret,omitempty" toml:"secret,omitempty"`
}

// Synthesizer handles the transformation of FTL applications to Spin manifests
type Synthesizer struct {
        ctx *cue.Context
}

// NewSynthesizer creates a new synthesizer
func NewSynthesizer() *Synthesizer <span class="cov8" title="1">{
        return &amp;Synthesizer{
                ctx: cuecontext.New(),
        }
}</span>

// SynthesizeToSpin transforms an FTL application to a Spin manifest
func (s *Synthesizer) SynthesizeToSpin(app *Application) (*SpinManifest, error) <span class="cov8" title="1">{
        // Set defaults
        app.SetDefaults()

        // Validate
        if err := app.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid application: %w", err)
        }</span>

        // Convert to CUE value and synthesize
        <span class="cov8" title="1">appJSON, err := json.Marshal(app)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal application: %w", err)
        }</span>

        // Create the synthesis program
        <span class="cov8" title="1">program := fmt.Sprintf(`
%s

inputApp: _

// Apply transformation
_transform: #TransformToSpin &amp; {
        input: inputApp
}

// Extract the final manifest
manifest: _transform.output
`, cuePatterns)

        // Compile the program
        value := s.ctx.CompileString(program)
        if value.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to compile CUE: %w", value.Err())
        }</span>

        // Parse the application JSON into CUE
        <span class="cov8" title="1">decoder := cuejson.NewDecoder(nil, "app.json", bytes.NewReader(appJSON))
        expr, err := decoder.Extract()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract JSON: %w", err)
        }</span>

        <span class="cov8" title="1">appValue := s.ctx.BuildExpr(expr)
        if appValue.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build CUE from JSON: %w", appValue.Err())
        }</span>

        // Fill in the input application
        <span class="cov8" title="1">value = value.FillPath(cue.ParsePath("inputApp"), appValue)
        if value.Err() != nil </span><span class="cov0" title="0">{
                // Provide more helpful error messages for common issues
                errStr := value.Err().Error()
                if strings.Contains(errStr, "empty disjunction") </span><span class="cov0" title="0">{
                        if strings.Contains(errStr, "access") </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid access mode '%s': must be one of 'public', 'private', 'org', or 'custom'", app.Access)
                        }</span>
                        <span class="cov0" title="0">if strings.Contains(errStr, "provider") </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid auth provider '%s': must be 'workos' or 'custom'", app.Auth.Provider)
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("synthesis failed: %w", value.Err())</span>
        }

        // Extract the manifest
        <span class="cov8" title="1">manifestValue := value.LookupPath(cue.ParsePath("manifest"))
        if manifestValue.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract manifest: %w", manifestValue.Err())
        }</span>

        // Convert to SpinManifest struct
        <span class="cov8" title="1">var manifest SpinManifest
        if err := manifestValue.Decode(&amp;manifest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode manifest: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;manifest, nil</span>
}

// SynthesizeToTOML transforms an FTL application to a Spin TOML manifest string
func (s *Synthesizer) SynthesizeToTOML(app *Application) (string, error) <span class="cov0" title="0">{
        // Set defaults and validate
        app.SetDefaults()
        if err := app.Validate(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid application: %w", err)
        }</span>

        // Convert to CUE value and synthesize
        <span class="cov0" title="0">appJSON, err := json.Marshal(app)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal application: %w", err)
        }</span>

        // Create the synthesis program
        <span class="cov0" title="0">program := fmt.Sprintf(`
%s

inputApp: _

// Apply transformation
_transform: #TransformToSpin &amp; {
        input: inputApp
}

// Extract the final manifest
manifest: _transform.output
`, cuePatterns)

        // Compile the program
        value := s.ctx.CompileString(program)
        if value.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to compile CUE: %w", value.Err())
        }</span>

        // Parse the application JSON into CUE
        <span class="cov0" title="0">decoder := cuejson.NewDecoder(nil, "app.json", bytes.NewReader(appJSON))
        expr, err := decoder.Extract()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to extract JSON: %w", err)
        }</span>

        <span class="cov0" title="0">appValue := s.ctx.BuildExpr(expr)
        if appValue.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to build CUE from JSON: %w", appValue.Err())
        }</span>

        // Fill in the input application
        <span class="cov0" title="0">value = value.FillPath(cue.ParsePath("inputApp"), appValue)
        if value.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to fill input app: %w", value.Err())
        }</span>

        // Extract the manifest
        <span class="cov0" title="0">manifestValue := value.LookupPath(cue.ParsePath("manifest"))
        if manifestValue.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to extract manifest: %w", manifestValue.Err())
        }</span>

        // Encode to TOML
        <span class="cov0" title="0">var buf bytes.Buffer
        encoder := toml.NewEncoder(&amp;buf)
        if err := encoder.Encode(manifestValue); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode to TOML: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.String(), nil</span>
}

// SynthesizeFromYAML takes YAML input and produces a Spin manifest
func (s *Synthesizer) SynthesizeFromYAML(yamlData []byte) (*SpinManifest, error) <span class="cov0" title="0">{
        var app Application
        if err := yaml.Unmarshal(yamlData, &amp;app); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SynthesizeToSpin(&amp;app)</span>
}

// SynthesizeFromJSON takes JSON input and produces a Spin manifest
func (s *Synthesizer) SynthesizeFromJSON(jsonData []byte) (*SpinManifest, error) <span class="cov0" title="0">{
        var app Application
        if err := json.Unmarshal(jsonData, &amp;app); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SynthesizeToSpin(&amp;app)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package ftl provides shared types and utilities for FTL applications
// This package is used by both the CLI and the platform backend to ensure consistency
package ftl

import (
        "encoding/json"
        "fmt"

        "gopkg.in/yaml.v3"
)

// Application represents the FTL application configuration
// This is the canonical schema that both CLI and platform use
type Application struct {
        Name        string            `json:"name" yaml:"name" cue:"name!"`
        Version     string            `json:"version,omitempty" yaml:"version,omitempty" cue:"version"`
        Description string            `json:"description,omitempty" yaml:"description,omitempty" cue:"description"`
        Components  []Component       `json:"components,omitempty" yaml:"components,omitempty" cue:"components"`
        Access      AccessMode        `json:"access,omitempty" yaml:"access,omitempty" cue:"access"`
        Auth        AuthConfig        `json:"auth,omitempty" yaml:"auth,omitempty" cue:"auth"`
        Variables   map[string]string `json:"variables,omitempty" yaml:"variables,omitempty" cue:"variables?"`
}

// Component represents a component in the FTL application
type Component struct {
        ID        string            `json:"id" yaml:"id" cue:"id!"`
        Source    ComponentSource   `json:"source" yaml:"source" cue:"source!"`
        Build     *BuildConfig      `json:"build,omitempty" yaml:"build,omitempty" cue:"build"`
        Variables map[string]string `json:"variables,omitempty" yaml:"variables,omitempty" cue:"variables?"`
}

// ComponentSource can be either a local path (string) or a registry reference
type ComponentSource interface {
        IsLocal() bool
        GetPath() string
        GetRegistry() *RegistrySource
}

// LocalSource represents a local file path
type LocalSource string

func (l LocalSource) IsLocal() bool                <span class="cov8" title="1">{ return true }</span>
func (l LocalSource) GetPath() string              <span class="cov8" title="1">{ return string(l) }</span>
func (l LocalSource) GetRegistry() *RegistrySource <span class="cov0" title="0">{ return nil }</span>

// RegistrySource represents a component from a registry
type RegistrySource struct {
        Registry string `json:"registry" yaml:"registry" cue:"registry!"`
        Package  string `json:"package" yaml:"package" cue:"package!"`
        Version  string `json:"version" yaml:"version" cue:"version!"`
}

func (r *RegistrySource) IsLocal() bool                <span class="cov0" title="0">{ return false }</span>
func (r *RegistrySource) GetPath() string              <span class="cov0" title="0">{ return "" }</span>
func (r *RegistrySource) GetRegistry() *RegistrySource <span class="cov0" title="0">{ return r }</span>

// AsRegistry attempts to cast ComponentSource to RegistrySource
func AsRegistry(source ComponentSource) (*RegistrySource, bool) <span class="cov8" title="1">{
        if source == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">reg, ok := source.(*RegistrySource)
        return reg, ok</span>
}

// AsLocal attempts to cast ComponentSource to LocalSource
func AsLocal(source ComponentSource) (string, bool) <span class="cov8" title="1">{
        if source == nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov8" title="1">local, ok := source.(LocalSource)
        return string(local), ok</span>
}

// BuildConfig defines build configuration for a component
type BuildConfig struct {
        Command string   `json:"command" yaml:"command" cue:"command!"`
        Workdir string   `json:"workdir,omitempty" yaml:"workdir,omitempty" cue:"workdir?"`
        Watch   []string `json:"watch,omitempty" yaml:"watch,omitempty" cue:"watch?"`
}

// AccessMode defines the access control mode
type AccessMode string

const (
        AccessPublic  AccessMode = "public"
        AccessPrivate AccessMode = "private"
        AccessOrg     AccessMode = "org"
        AccessCustom  AccessMode = "custom"
)

// AuthConfig defines authentication configuration
type AuthConfig struct {
        Provider    AuthProvider `json:"provider" yaml:"provider" cue:"provider!"`
        OrgID       string       `json:"org_id,omitempty" yaml:"org_id,omitempty" cue:"org_id"`
        JWTIssuer   string       `json:"jwt_issuer,omitempty" yaml:"jwt_issuer,omitempty" cue:"jwt_issuer"`
        JWTAudience string       `json:"jwt_audience,omitempty" yaml:"jwt_audience,omitempty" cue:"jwt_audience"`
}

// AuthProvider defines the authentication provider type
type AuthProvider string

const (
        AuthProviderWorkOS AuthProvider = "workos"
        AuthProviderCustom AuthProvider = "custom"
)

// SetDefaults sets default values for the application
func (a *Application) SetDefaults() <span class="cov8" title="1">{
        if a.Version == "" </span><span class="cov0" title="0">{
                a.Version = "0.1.0"
        }</span>
        <span class="cov8" title="1">if a.Access == "" </span><span class="cov8" title="1">{
                a.Access = AccessPublic
        }</span>
        <span class="cov8" title="1">if a.Auth.Provider == "" </span><span class="cov8" title="1">{
                a.Auth.Provider = AuthProviderWorkOS
        }</span>
        <span class="cov8" title="1">if a.Auth.Provider == AuthProviderWorkOS &amp;&amp; a.Auth.JWTIssuer == "" </span><span class="cov8" title="1">{
                a.Auth.JWTIssuer = "https://api.workos.com"
        }</span>
}

// Validate validates the application configuration
func (a *Application) Validate() error <span class="cov8" title="1">{
        if a.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("application name is required")
        }</span>

        // Validate name format
        <span class="cov8" title="1">if !isValidName(a.Name) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid application name: must be lowercase alphanumeric with hyphens")
        }</span>

        // Validate components
        <span class="cov8" title="1">for _, comp := range a.Components </span><span class="cov0" title="0">{
                if err := comp.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid component %s: %w", comp.ID, err)
                }</span>
        }

        // Validate auth configuration based on access mode
        <span class="cov8" title="1">switch a.Access </span>{
        case AccessCustom:<span class="cov8" title="1">
                if a.Auth.Provider != AuthProviderCustom </span><span class="cov0" title="0">{
                        return fmt.Errorf("custom access requires custom auth provider")
                }</span>
                <span class="cov8" title="1">if a.Auth.JWTIssuer == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT issuer is required for custom auth")
                }</span>
                <span class="cov8" title="1">if a.Auth.JWTAudience == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT audience is required for custom auth")
                }</span>
        case AccessOrg:<span class="cov8" title="1">
                if a.Auth.Provider != AuthProviderWorkOS </span><span class="cov0" title="0">{
                        return fmt.Errorf("org access requires WorkOS auth provider")
                }</span>
                <span class="cov8" title="1">if a.Auth.OrgID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("org ID is required for org access mode")
                }</span>
        case AccessPrivate:<span class="cov8" title="1">
                // Private mode can use either WorkOS or custom auth
                if a.Auth.Provider == AuthProviderCustom </span><span class="cov0" title="0">{
                        if a.Auth.JWTIssuer == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("JWT issuer is required for custom auth")
                        }</span>
                }
        case AccessPublic:<span class="cov8" title="1"></span>
                // No auth required for public access
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid access mode: %s", a.Access)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Validate validates a component
func (c *Component) Validate() error <span class="cov0" title="0">{
        if c.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("component ID is required")
        }</span>

        <span class="cov0" title="0">if !isValidName(c.ID) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid component ID: must be lowercase alphanumeric with hyphens")
        }</span>

        <span class="cov0" title="0">if c.Source == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("component source is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// isValidName checks if a name is valid (lowercase alphanumeric with hyphens)
func isValidName(name string) bool <span class="cov8" title="1">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i, ch := range name </span><span class="cov8" title="1">{
                if i == 0 &amp;&amp; (ch &lt; 'a' || ch &gt; 'z') </span><span class="cov8" title="1">{
                        return false // Must start with lowercase letter
                }</span>
                <span class="cov8" title="1">if !((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= '0' &amp;&amp; ch &lt;= '9') || ch == '-') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// UnmarshalJSON implements custom JSON unmarshalling for Component
func (c *Component) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type Alias Component
        aux := &amp;struct {
                Source json.RawMessage `json:"source"`
                *Alias
        }{
                Alias: (*Alias)(c),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Try to unmarshal as string first (local source)
        <span class="cov0" title="0">var localPath string
        if err := json.Unmarshal(aux.Source, &amp;localPath); err == nil </span><span class="cov0" title="0">{
                c.Source = LocalSource(localPath)
                return nil
        }</span>

        // Try to unmarshal as registry source
        <span class="cov0" title="0">var regSource RegistrySource
        if err := json.Unmarshal(aux.Source, &amp;regSource); err == nil </span><span class="cov0" title="0">{
                c.Source = &amp;regSource
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("invalid component source format")</span>
}

// MarshalJSON implements custom JSON marshalling for Component
func (c Component) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type Alias Component

        var source interface{}
        if c.Source != nil </span><span class="cov0" title="0">{
                if c.Source.IsLocal() </span><span class="cov0" title="0">{
                        source = c.Source.GetPath()
                }</span> else<span class="cov0" title="0"> {
                        source = c.Source.GetRegistry()
                }</span>
        }

        <span class="cov0" title="0">return json.Marshal(&amp;struct {
                Source interface{} `json:"source"`
                *Alias
        }{
                Source: source,
                Alias:  (*Alias)(&amp;c),
        })</span>
}

// UnmarshalYAML implements custom YAML unmarshalling for Component
func (c *Component) UnmarshalYAML(value *yaml.Node) error <span class="cov0" title="0">{
        type Alias Component
        aux := &amp;struct {
                Source yaml.Node `yaml:"source"`
                *Alias
        }{
                Alias: (*Alias)(c),
        }

        if err := value.Decode(&amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Try to decode as string first (local source)
        <span class="cov0" title="0">var localPath string
        if err := aux.Source.Decode(&amp;localPath); err == nil </span><span class="cov0" title="0">{
                c.Source = LocalSource(localPath)
                return nil
        }</span>

        // Try to decode as registry source
        <span class="cov0" title="0">var regSource RegistrySource
        if err := aux.Source.Decode(&amp;regSource); err == nil </span><span class="cov0" title="0">{
                c.Source = &amp;regSource
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("invalid component source format")</span>
}

// MarshalYAML implements custom YAML marshalling for Component
func (c Component) MarshalYAML() (interface{}, error) <span class="cov0" title="0">{
        type Alias Component

        var source interface{}
        if c.Source != nil </span><span class="cov0" title="0">{
                if c.Source.IsLocal() </span><span class="cov0" title="0">{
                        source = c.Source.GetPath()
                }</span> else<span class="cov0" title="0"> {
                        source = c.Source.GetRegistry()
                }</span>
        }

        // Create a map representation
        <span class="cov0" title="0">result := make(map[string]interface{})
        result["id"] = c.ID
        result["source"] = source

        if c.Build != nil </span><span class="cov0" title="0">{
                result["build"] = c.Build
        }</span>

        <span class="cov0" title="0">if len(c.Variables) &gt; 0 </span><span class="cov0" title="0">{
                result["variables"] = c.Variables
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package scaffold

import (
        "bytes"
        _ "embed"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "cuelang.org/go/cue"
        "cuelang.org/go/cue/cuecontext"
        "gopkg.in/yaml.v3"

        "github.com/fastertools/ftl-cli/pkg/types"
)

//go:embed templates.cue
var templatesCUE string

// Scaffolder handles component generation using CUE templates
type Scaffolder struct {
        ctx       *cue.Context
        templates cue.Value
}

// NewScaffolder creates a new scaffolder with embedded templates
func NewScaffolder() (*Scaffolder, error) <span class="cov8" title="1">{
        ctx := cuecontext.New()

        // Compile the embedded CUE templates
        templates := ctx.CompileString(templatesCUE)
        if templates.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to compile templates: %w", templates.Err())
        }</span>

        <span class="cov8" title="1">return &amp;Scaffolder{
                ctx:       ctx,
                templates: templates,
        }, nil</span>
}

// GenerateComponent creates a new component from templates
func (s *Scaffolder) GenerateComponent(name, language string) error <span class="cov8" title="1">{
        // Validate inputs
        if err := s.validateInputs(name, language); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Create component instance from template
        <span class="cov8" title="1">component, err := s.createComponentInstance(name, language)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create component instance: %w", err)
        }</span>

        // Generate files
        <span class="cov8" title="1">if err := s.generateFiles(name, component); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate files: %w", err)
        }</span>

        // Update ftl.yaml
        <span class="cov8" title="1">if err := s.updateFTLConfig(name, component); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update ftl.yaml: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateInputs checks that the name and language are valid
func (s *Scaffolder) validateInputs(name, language string) error <span class="cov8" title="1">{
        // Validate component name
        nameValidator := s.ctx.CompileString(fmt.Sprintf(`
                import "regexp"
                name: %q
                valid: regexp.Match("^[a-z][a-z0-9-]*$", name)
        `, name))

        valid := nameValidator.LookupPath(cue.ParsePath("valid"))
        if v, _ := valid.Bool(); !v </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid component name '%s': must be lowercase with hyphens (e.g., my-tool)", name)
        }</span>

        // Validate language
        <span class="cov8" title="1">validLanguages := []string{"rust", "typescript", "python", "go"}
        found := false
        for _, lang := range validLanguages </span><span class="cov8" title="1">{
                if lang == language </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid language '%s': must be one of %v", language, validLanguages)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createComponentInstance creates a CUE value for the component
func (s *Scaffolder) createComponentInstance(name, language string) (cue.Value, error) <span class="cov8" title="1">{
        // Create the component configuration with the templates
        componentDef := fmt.Sprintf(`
                %s
                
                component: #Templates[%q] &amp; {
                        name: %q
                }
        `, templatesCUE, language, name)

        // Compile the full definition
        instance := s.ctx.CompileString(componentDef)
        unified := instance

        if err := unified.Err(); err != nil </span><span class="cov0" title="0">{
                return cue.Value{}, fmt.Errorf("failed to create component: %w", err)
        }</span>

        // Extract the component value
        <span class="cov8" title="1">component := unified.LookupPath(cue.ParsePath("component"))
        if !component.Exists() </span><span class="cov0" title="0">{
                return cue.Value{}, fmt.Errorf("component not found in template")
        }</span>

        <span class="cov8" title="1">return component, nil</span>
}

// generateFiles creates all the component files
func (s *Scaffolder) generateFiles(name string, component cue.Value) error <span class="cov8" title="1">{
        // Create component directory
        if err := os.MkdirAll(name, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Get language for special handling
        <span class="cov8" title="1">language, _ := component.LookupPath(cue.ParsePath("language")).String()

        // Prepare name variations for template substitution
        nameUnderscore := strings.ReplaceAll(name, "-", "_")

        // Extract files map
        files := component.LookupPath(cue.ParsePath("files"))
        if !files.Exists() </span><span class="cov0" title="0">{
                return fmt.Errorf("no files defined in template")
        }</span>

        // Iterate over files and create them
        <span class="cov8" title="1">iter, err := files.Fields()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to iterate files: %w", err)
        }</span>

        <span class="cov8" title="1">for iter.Next() </span><span class="cov8" title="1">{
                path := iter.Selector().Unquoted()
                content := iter.Value()

                // Get content as string
                contentStr, err := content.String()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get content for %s: %w", path, err)
                }</span>

                // Apply language-specific substitutions
                <span class="cov8" title="1">if language == "rust" </span><span class="cov8" title="1">{
                        // Rust specific: In Cargo.toml, package names must use underscores
                        if path == "Cargo.toml" </span><span class="cov8" title="1">{
                                contentStr = strings.ReplaceAll(contentStr, `name = "`+name+`"`, `name = "`+nameUnderscore+`"`)
                        }</span>
                        // In Makefile, the built WASM file uses underscores
                        <span class="cov8" title="1">if path == "Makefile" </span><span class="cov8" title="1">{
                                contentStr = strings.ReplaceAll(contentStr, "/"+name+".wasm", "/"+nameUnderscore+".wasm")
                                contentStr = strings.ReplaceAll(contentStr, " "+name+".wasm", " "+nameUnderscore+".wasm")
                        }</span>
                }

                // Create full path
                <span class="cov8" title="1">fullPath := filepath.Join(name, path)

                // Create directory if needed
                dir := filepath.Dir(fullPath)
                if dir != "." &amp;&amp; dir != name </span><span class="cov8" title="1">{
                        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", dir, err)
                        }</span>
                }

                // Write file
                <span class="cov8" title="1">if err := os.WriteFile(fullPath, []byte(contentStr), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write file %s: %w", fullPath, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// updateFTLConfig adds the new component to ftl.yaml or ftl.json
func (s *Scaffolder) updateFTLConfig(name string, component cue.Value) error <span class="cov8" title="1">{
        // Detect configuration format
        format, configPath, err := s.detectConfigFormat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Handle unsupported formats with helpful messages
        <span class="cov8" title="1">if format == "go" </span><span class="cov8" title="1">{
                // Extract build configuration for the helpful message
                language, _ := component.LookupPath(cue.ParsePath("language")).String()
                wasmPath := s.getWasmPath(name, language)

                return fmt.Errorf("Go-based configurations require manual component registration.\n"+
                        "Add this to your main.go:\n\n"+
                        "    app.AddComponent(\"%s\").\n"+
                        "        FromLocal(\"./%s\").\n"+
                        "        WithBuild(\"cd %s &amp;&amp; make build\").\n"+
                        "        Build()\n", name, wasmPath, name)
        }</span>

        <span class="cov8" title="1">if format == "cue" </span><span class="cov8" title="1">{
                return fmt.Errorf("CUE configurations require manual component registration.\n"+
                        "Add this to your app.cue components array:\n\n"+
                        "    {\n"+
                        "        id: \"%s\"\n"+
                        "        source: \"./%s/%s.wasm\"\n"+
                        "        build: {\n"+
                        "            command: \"make build\"\n"+
                        "            workdir: \"%s\"\n"+
                        "        }\n"+
                        "    }\n", name, name, name, name)
        }</span>

        // Read existing config
        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read %s: %w", configPath, err)
        }</span>

        <span class="cov8" title="1">var manifest types.Manifest

        // Parse based on format
        switch format </span>{
        case "yaml":<span class="cov8" title="1">
                if err := yaml.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse %s: %w", configPath, err)
                }</span>
        case "json":<span class="cov8" title="1">
                if err := json.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse %s: %w", configPath, err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported configuration format: %s", format)</span>
        }

        // Extract build configuration from component
        <span class="cov8" title="1">build := component.LookupPath(cue.ParsePath("build"))

        command, _ := build.LookupPath(cue.ParsePath("command")).String()

        // Extract watch patterns
        watchIter, _ := build.LookupPath(cue.ParsePath("watch")).List()
        var watchPatterns []string
        for watchIter.Next() </span><span class="cov8" title="1">{
                pattern, _ := watchIter.Value().String()
                watchPatterns = append(watchPatterns, pattern)
        }</span>

        // Extract language to determine WASM output path
        <span class="cov8" title="1">language, _ := component.LookupPath(cue.ParsePath("language")).String()
        wasmPath := s.getWasmPath(name, language)

        // Create new component config
        newComponent := types.Component{
                ID:     name,
                Source: wasmPath,
                Build: &amp;types.Build{
                        Command: command,
                        Workdir: name,
                        Watch:   watchPatterns,
                },
        }

        // Check for duplicate
        for _, comp := range manifest.Components </span><span class="cov8" title="1">{
                if comp.ID == name </span><span class="cov8" title="1">{
                        return fmt.Errorf("component '%s' already exists", name)
                }</span>
        }

        // Add component
        <span class="cov8" title="1">manifest.Components = append(manifest.Components, newComponent)

        // Write back based on format
        var output []byte
        switch format </span>{
        case "yaml":<span class="cov8" title="1">
                var buf bytes.Buffer
                encoder := yaml.NewEncoder(&amp;buf)
                encoder.SetIndent(2)
                if err := encoder.Encode(&amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode config: %w", err)
                }</span>
                <span class="cov8" title="1">output = buf.Bytes()</span>
        case "json":<span class="cov8" title="1">
                var err error
                output, err = json.MarshalIndent(&amp;manifest, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode config: %w", err)
                }</span>
                // Add trailing newline for consistency
                <span class="cov8" title="1">output = append(output, '\n')</span>
        }

        <span class="cov8" title="1">if err := os.WriteFile(configPath, output, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write %s: %w", configPath, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// detectConfigFormat detects which configuration format is being used
func (s *Scaffolder) detectConfigFormat() (string, string, error) <span class="cov8" title="1">{
        // Check for YAML first (most common)
        if _, err := os.Stat("ftl.yaml"); err == nil </span><span class="cov8" title="1">{
                return "yaml", "ftl.yaml", nil
        }</span>

        // Check for JSON
        <span class="cov8" title="1">if _, err := os.Stat("ftl.json"); err == nil </span><span class="cov8" title="1">{
                return "json", "ftl.json", nil
        }</span>

        // Check for CUE
        <span class="cov8" title="1">if _, err := os.Stat("app.cue"); err == nil </span><span class="cov8" title="1">{
                return "cue", "app.cue", nil
        }</span>

        // Check for Go
        <span class="cov8" title="1">if _, err := os.Stat("main.go"); err == nil </span><span class="cov8" title="1">{
                // Double-check it's actually an FTL Go config by looking for the CDK import
                data, err := os.ReadFile("main.go")
                if err == nil &amp;&amp; strings.Contains(string(data), "synthesis.NewCDK") </span><span class="cov8" title="1">{
                        return "go", "main.go", nil
                }</span>
        }

        <span class="cov8" title="1">return "", "", fmt.Errorf("no FTL configuration found - not in an FTL project directory.\n" +
                "Run 'ftl init' to create a new project")</span>
}

// getWasmPath returns the WASM output path for a component
func (s *Scaffolder) getWasmPath(name, language string) string <span class="cov8" title="1">{
        switch language </span>{
        case "rust":<span class="cov8" title="1">
                // Rust uses underscores in the binary name
                binaryName := strings.ReplaceAll(name, "-", "_")
                return filepath.Join(name, binaryName+".wasm")</span>
        case "typescript":<span class="cov8" title="1">
                return filepath.Join(name, "dist", name+".wasm")</span>
        case "python":<span class="cov8" title="1">
                return filepath.Join(name, "app.wasm")</span>
        case "go":<span class="cov8" title="1">
                return filepath.Join(name, "main.wasm")</span>
        default:<span class="cov8" title="1">
                return filepath.Join(name, name+".wasm")</span>
        }
}

// ListLanguages returns the available languages
func (s *Scaffolder) ListLanguages() []string <span class="cov8" title="1">{
        return []string{"rust", "typescript", "python", "go"}
}</span>

// ValidateComponentName checks if a component name is valid
func ValidateComponentName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("component name cannot be empty")
        }</span>

        // Check for valid characters (lowercase, numbers, hyphens)
        <span class="cov8" title="1">for i, c := range name </span><span class="cov8" title="1">{
                if !((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '-') </span><span class="cov8" title="1">{
                        return fmt.Errorf("component name must contain only lowercase letters, numbers, and hyphens")
                }</span>

                // First character must be a letter
                <span class="cov8" title="1">if i == 0 &amp;&amp; !(c &gt;= 'a' &amp;&amp; c &lt;= 'z') </span><span class="cov8" title="1">{
                        return fmt.Errorf("component name must start with a lowercase letter")
                }</span>
        }

        // Check for leading/trailing or double hyphens
        <span class="cov8" title="1">if strings.HasPrefix(name, "-") || strings.HasSuffix(name, "-") || strings.Contains(name, "--") </span><span class="cov8" title="1">{
                return fmt.Errorf("component name cannot start/end with or contain double hyphens")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package synthesis

import (
        "fmt"

        "cuelang.org/go/cue"
        "cuelang.org/go/cue/cuecontext"
)

// CDK provides a Go-based Cloud Development Kit for FTL/Spin applications.
// It follows idiomatic CUE patterns: build configuration in Go, validate and transform with CUE.
type CDK struct {
        ctx *cue.Context
        app *CDKApp
}

// NewCDK creates a new CDK instance
func NewCDK() *CDK <span class="cov8" title="1">{
        return &amp;CDK{
                ctx: cuecontext.New(),
        }
}</span>

// CDKApp represents an FTL application being built
type CDKApp struct {
        Name        string         `json:"name"`
        Version     string         `json:"version"`
        Description string         `json:"description,omitempty"`
        Components  []CDKComponent `json:"components,omitempty"`
        Access      string         `json:"access,omitempty"`
        Auth        *CDKAuth       `json:"auth,omitempty"`
}

// CDKComponent represents a Wasm component in the application
type CDKComponent struct {
        ID        string            `json:"id"`
        Source    interface{}       `json:"source"` // string for local, map for registry
        Build     *CDKBuildConfig   `json:"build,omitempty"`
        Variables map[string]string `json:"variables,omitempty"`
}

// CDKBuildConfig represents build configuration
type CDKBuildConfig struct {
        Command string   `json:"command"`
        WorkDir string   `json:"workdir,omitempty"`
        Watch   []string `json:"watch,omitempty"`
}

// CDKAuth represents authentication configuration for custom access mode
type CDKAuth struct {
        JWTIssuer         string   `json:"jwt_issuer"`
        JWTAudience       string   `json:"jwt_audience"`
        JWTRequiredScopes []string `json:"jwt_required_scopes,omitempty"`
}

// AppBuilder provides a fluent interface for building applications
type AppBuilder struct {
        cdk *CDK
        app *CDKApp
}

// NewApp creates a new application builder
func (cdk *CDK) NewApp(name string) *AppBuilder <span class="cov8" title="1">{
        app := &amp;CDKApp{
                Name:       name,
                Version:    "0.1.0",
                Access:     "public",
                Components: []CDKComponent{},
        }

        return &amp;AppBuilder{
                cdk: cdk,
                app: app,
        }
}</span>

// SetVersion sets the application version
func (ab *AppBuilder) SetVersion(version string) *AppBuilder <span class="cov8" title="1">{
        ab.app.Version = version
        return ab
}</span>

// SetDescription sets the application description
func (ab *AppBuilder) SetDescription(description string) *AppBuilder <span class="cov8" title="1">{
        ab.app.Description = description
        return ab
}</span>

// SetAccess sets the access level (public or private)
func (ab *AppBuilder) SetAccess(access string) *AppBuilder <span class="cov8" title="1">{
        ab.app.Access = access
        return ab
}</span>

// SetPrivateAccess enables FTL platform authentication (user-only access)
func (ab *AppBuilder) SetPrivateAccess() *AppBuilder <span class="cov0" title="0">{
        ab.app.Access = "private"
        // No auth config needed - FTL handles it
        ab.app.Auth = nil
        return ab
}</span>

// SetOrgAccess enables FTL platform authentication (org-level access)
func (ab *AppBuilder) SetOrgAccess() *AppBuilder <span class="cov8" title="1">{
        ab.app.Access = "org"
        // No auth config needed - FTL handles it
        ab.app.Auth = nil
        return ab
}</span>

// SetCustomAuth enables custom JWT authentication
func (ab *AppBuilder) SetCustomAuth(issuer, audience string) *AppBuilder <span class="cov8" title="1">{
        ab.app.Auth = &amp;CDKAuth{
                JWTIssuer:   issuer,
                JWTAudience: audience,
        }
        ab.app.Access = "custom"
        return ab
}</span>

// AddComponent adds a Wasm component to the application
func (ab *AppBuilder) AddComponent(id string) *ComponentBuilder <span class="cov8" title="1">{
        return &amp;ComponentBuilder{
                app: ab,
                component: CDKComponent{
                        ID: id,
                        // Variables will be nil unless explicitly set
                },
        }
}</span>

// Build finalizes the application and returns the CDK
func (ab *AppBuilder) Build() *CDK <span class="cov8" title="1">{
        ab.cdk.app = ab.app
        return ab.cdk
}</span>

// ComponentBuilder provides a fluent interface for building components
type ComponentBuilder struct {
        app       *AppBuilder
        component CDKComponent
}

// FromLocal sets the component source as a local path
func (cb *ComponentBuilder) FromLocal(path string) *ComponentBuilder <span class="cov8" title="1">{
        cb.component.Source = path
        return cb
}</span>

// FromRegistry sets the component source from a registry
func (cb *ComponentBuilder) FromRegistry(registry, pkg, version string) *ComponentBuilder <span class="cov8" title="1">{
        cb.component.Source = map[string]string{
                "registry": registry,
                "package":  pkg,
                "version":  version,
        }
        return cb
}</span>

// WithBuild sets the build configuration
func (cb *ComponentBuilder) WithBuild(command string) *ComponentBuilder <span class="cov8" title="1">{
        if cb.component.Build == nil </span><span class="cov8" title="1">{
                cb.component.Build = &amp;CDKBuildConfig{}
        }</span>
        <span class="cov8" title="1">cb.component.Build.Command = command
        return cb</span>
}

// WithWatch adds watch patterns for development
func (cb *ComponentBuilder) WithWatch(patterns ...string) *ComponentBuilder <span class="cov8" title="1">{
        if cb.component.Build == nil </span><span class="cov8" title="1">{
                cb.component.Build = &amp;CDKBuildConfig{}
        }</span>
        <span class="cov8" title="1">cb.component.Build.Watch = append(cb.component.Build.Watch, patterns...)
        return cb</span>
}

// WithEnv adds environment variables
func (cb *ComponentBuilder) WithEnv(key, value string) *ComponentBuilder <span class="cov8" title="1">{
        if cb.component.Variables == nil </span><span class="cov8" title="1">{
                cb.component.Variables = make(map[string]string)
        }</span>
        <span class="cov8" title="1">cb.component.Variables[key] = value
        return cb</span>
}

// Build completes the component and returns to the app builder
func (cb *ComponentBuilder) Build() *AppBuilder <span class="cov8" title="1">{
        cb.app.app.Components = append(cb.app.app.Components, cb.component)
        return cb.app
}</span>

// Synthesize produces a Spin manifest from the CDK application
func (cdk *CDK) Synthesize() (string, error) <span class="cov8" title="1">{
        if cdk.app == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no application defined - call Build() first")
        }</span>

        // Convert the Go struct to a CUE value using idiomatic patterns
        <span class="cov8" title="1">appValue := cdk.ctx.Encode(cdk.app)
        if appValue.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode app to CUE: %w", appValue.Err())
        }</span>

        // Load our patterns as a CUE schema
        <span class="cov8" title="1">schema := cdk.ctx.CompileString(ftlPatterns)
        if schema.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to compile patterns: %w", schema.Err())
        }</span>

        // Create the complete CUE program that transforms our app
        <span class="cov8" title="1">program := fmt.Sprintf(`
%s

// Import the app data
_appData: %v

// Wrap it in the FTL application structure
app: #FTLApplication &amp; _appData

// Transform through the pipeline
_transform: #TransformToSpin &amp; {
        input: app
}

// Extract the final manifest
manifest: _transform.output
`, ftlPatterns, appValue)

        // Compile and evaluate
        result := cdk.ctx.CompileString(program)
        if result.Err() != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to compile transformation: %w", result.Err())
        }</span>

        // Extract the manifest
        <span class="cov8" title="1">manifestValue := result.LookupPath(cue.ParsePath("manifest"))
        if manifestValue.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to extract manifest: %w", manifestValue.Err())
        }</span>

        // Validate the result
        <span class="cov8" title="1">if err := manifestValue.Validate(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("manifest validation failed: %w", err)
        }</span>

        // Encode to TOML
        <span class="cov8" title="1">synth := NewSynthesizer()
        return synth.encodeToTOML(manifestValue)</span>
}

// ToCUE exports the current application as CUE source
func (cdk *CDK) ToCUE() (string, error) <span class="cov8" title="1">{
        if cdk.app == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no application defined - call Build() first")
        }</span>

        // Convert to CUE value
        <span class="cov8" title="1">appValue := cdk.ctx.Encode(cdk.app)
        if appValue.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode app: %w", appValue.Err())
        }</span>

        // Format as CUE source
        <span class="cov8" title="1">return fmt.Sprintf(`package main

app: %v
`, appValue), nil</span>
}

// ValidateWithSchema validates the application against a CUE schema
func (cdk *CDK) ValidateWithSchema(schemaSource string) error <span class="cov8" title="1">{
        if cdk.app == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no application defined - call Build() first")
        }</span>

        // Compile the schema
        <span class="cov8" title="1">schema := cdk.ctx.CompileString(schemaSource)
        if schema.Err() != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compile schema: %w", schema.Err())
        }</span>

        // Encode the app
        <span class="cov8" title="1">appValue := cdk.ctx.Encode(cdk.app)
        if appValue.Err() != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode app: %w", appValue.Err())
        }</span>

        // Unify with schema and validate
        <span class="cov8" title="1">unified := schema.Unify(appValue)
        if unified.Err() != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unify with schema: %w", unified.Err())
        }</span>

        <span class="cov8" title="1">return unified.Validate()</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package synthesis

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
)

// SynthesizeFromConfig reads a config file and synthesizes it to a Spin manifest
func SynthesizeFromConfig(configPath string) (string, error) <span class="cov8" title="1">{
        // Read the config file
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Detect format based on extension
        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(configPath))
        synth := NewSynthesizer()

        switch ext </span>{
        case ".yaml", ".yml":<span class="cov8" title="1">
                return synth.SynthesizeYAML(data)</span>
        case ".json":<span class="cov8" title="1">
                return synth.SynthesizeJSON(data)</span>
        case ".cue":<span class="cov8" title="1">
                return synth.SynthesizeCUE(string(data))</span>
        default:<span class="cov8" title="1">
                // Try to detect based on content
                var yamlTest interface{}
                if err := yaml.Unmarshal(data, &amp;yamlTest); err == nil </span><span class="cov8" title="1">{
                        return synth.SynthesizeYAML(data)
                }</span>
                <span class="cov8" title="1">return "", fmt.Errorf("unsupported config format for file: %s", configPath)</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package synthesis

import (
        "bytes"
        _ "embed"
        "fmt"

        "cuelang.org/go/cue"
        "cuelang.org/go/cue/cuecontext"
        cuejson "cuelang.org/go/encoding/json"
        "cuelang.org/go/encoding/toml"
        "cuelang.org/go/encoding/yaml"
)

//go:embed patterns.cue
var ftlPatterns string

// Synthesizer is a pure CUE-based synthesizer
type Synthesizer struct {
        ctx *cue.Context
}

// NewSynthesizer creates a new CUE-first synthesizer
func NewSynthesizer() *Synthesizer <span class="cov8" title="1">{
        return &amp;Synthesizer{
                ctx: cuecontext.New(),
        }
}</span>

// SynthesizeYAML takes YAML input and produces a Spin manifest
func (s *Synthesizer) SynthesizeYAML(yamlData []byte) (string, error) <span class="cov8" title="1">{
        // Extract YAML directly into CUE
        file, err := yaml.Extract("input.yaml", yamlData)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to extract YAML: %w", err)
        }</span>

        <span class="cov8" title="1">value := s.ctx.BuildFile(file)
        if value.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to build CUE from YAML: %w", value.Err())
        }</span>

        <span class="cov8" title="1">return s.synthesizeFromValue(value)</span>
}

// SynthesizeJSON takes JSON input and produces a Spin manifest
func (s *Synthesizer) SynthesizeJSON(jsonData []byte) (string, error) <span class="cov8" title="1">{
        // Extract JSON directly into CUE
        decoder := cuejson.NewDecoder(nil, "input.json", bytes.NewReader(jsonData))
        expr, err := decoder.Extract()
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to extract JSON: %w", err)
        }</span>

        <span class="cov8" title="1">value := s.ctx.BuildExpr(expr)
        if value.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to build CUE from JSON: %w", value.Err())
        }</span>

        <span class="cov8" title="1">return s.synthesizeFromValue(value)</span>
}

// SynthesizeCUE takes CUE source and produces a Spin manifest
func (s *Synthesizer) SynthesizeCUE(cueSource string) (string, error) <span class="cov8" title="1">{
        value := s.ctx.CompileString(cueSource)
        if value.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to compile CUE: %w", value.Err())
        }</span>

        <span class="cov8" title="1">return s.synthesizeFromValue(value)</span>
}

// encodeToTOML encodes a CUE value to TOML
func (s *Synthesizer) encodeToTOML(value cue.Value) (string, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        encoder := toml.NewEncoder(&amp;buf)
        if err := encoder.Encode(value); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to encode to TOML: %w", err)
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}

// synthesizeFromValue takes a CUE value and transforms it to a Spin manifest
func (s *Synthesizer) synthesizeFromValue(inputValue cue.Value) (string, error) <span class="cov8" title="1">{
        // Debug: print the input value
        // fmt.Fprintf(os.Stderr, "DEBUG: Input value: %v\n", inputValue)

        // Create the complete transformation program
        // Note: We build the app directly from inputData without intermediate schema
        program := fmt.Sprintf(`
%s

inputData: _

// Build the FTL app structure directly from input
_ftlApp: {
        name:        inputData.application.name
        version:     inputData.application.version | *"0.1.0"
        description: inputData.application.description | *""
        
        components: [ for comp in inputData.components if inputData.components != _|_ {
                id:     comp.id
                source: comp.source
                if comp.build != _|_ {
                        build: comp.build
                }
                if comp.variables != _|_ {
                        variables: comp.variables
                }
        }]
        
        // Pass through access mode, default to public
        if inputData.access != _|_ {
                access: inputData.access
        }
        if inputData.access == _|_ {
                access: "public"
        }
        
        // Pass through auth configuration if present
        if inputData.auth != _|_ {
                auth: inputData.auth
        }
}

// Validate against schema
app: #FTLApplication &amp; _ftlApp

// Apply transformation
_transform: #TransformToSpin &amp; {
        input: app
}

// Extract the final manifest
manifest: _transform.output
`, ftlPatterns)

        // Compile the complete program
        value := s.ctx.CompileString(program)
        if value.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to compile CUE: %w", value.Err())
        }</span>

        // Fill in the input data
        <span class="cov8" title="1">value = value.FillPath(cue.ParsePath("inputData"), inputValue)
        if value.Err() != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to fill input data: %w", value.Err())
        }</span>

        // Extract the manifest field
        <span class="cov8" title="1">manifestValue := value.LookupPath(cue.ParsePath("manifest"))
        if manifestValue.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to extract manifest: %w", manifestValue.Err())
        }</span>

        // Encode to TOML
        <span class="cov8" title="1">var buf bytes.Buffer
        encoder := toml.NewEncoder(&amp;buf)
        if err := encoder.Encode(manifestValue); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to encode to TOML: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package spin provides utilities for orchestrating Spin CLI commands
package spin

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strings"
        "time"

        "github.com/pkg/errors"
)

// Executor provides an interface for executing Spin commands
type Executor interface {
        Run(ctx context.Context, args ...string) error
        RunWithOutput(ctx context.Context, args ...string) (string, error)
        RunWithInput(ctx context.Context, input string, args ...string) error
        RunInteractive(ctx context.Context, args ...string) error
        IsInstalled() bool
        Version() (string, error)
}

// executor is the default implementation of Executor
type executor struct {
        binary string
        env    []string
        dir    string
        stdout io.Writer
        stderr io.Writer
        stdin  io.Reader
}

// NewExecutor creates a new Spin executor
func NewExecutor(options ...Option) Executor <span class="cov8" title="1">{
        e := &amp;executor{
                binary: "spin",
                stdout: os.Stdout,
                stderr: os.Stderr,
                stdin:  os.Stdin,
        }

        for _, opt := range options </span><span class="cov8" title="1">{
                opt(e)
        }</span>

        <span class="cov8" title="1">return e</span>
}

// Option configures an executor
type Option func(*executor)

// WithBinary sets the Spin binary path
func WithBinary(binary string) Option <span class="cov8" title="1">{
        return func(e *executor) </span><span class="cov8" title="1">{
                e.binary = binary
        }</span>
}

// WithEnv sets environment variables
func WithEnv(env []string) Option <span class="cov8" title="1">{
        return func(e *executor) </span><span class="cov8" title="1">{
                e.env = env
        }</span>
}

// WithDir sets the working directory
func WithDir(dir string) Option <span class="cov8" title="1">{
        return func(e *executor) </span><span class="cov8" title="1">{
                e.dir = dir
        }</span>
}

// WithOutput sets custom output writers
func WithOutput(stdout, stderr io.Writer) Option <span class="cov8" title="1">{
        return func(e *executor) </span><span class="cov8" title="1">{
                e.stdout = stdout
                e.stderr = stderr
        }</span>
}

// WithInput sets custom input reader
func WithInput(stdin io.Reader) Option <span class="cov8" title="1">{
        return func(e *executor) </span><span class="cov8" title="1">{
                e.stdin = stdin
        }</span>
}

// Run executes a Spin command
func (e *executor) Run(ctx context.Context, args ...string) error <span class="cov8" title="1">{
        cmd := e.command(ctx, args...)
        cmd.Stdout = e.stdout
        cmd.Stderr = e.stderr
        return e.runCommand(cmd)
}</span>

// RunWithOutput executes a Spin command and returns output
func (e *executor) RunWithOutput(ctx context.Context, args ...string) (string, error) <span class="cov8" title="1">{
        cmd := e.command(ctx, args...)
        var stdout bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = e.stderr

        if err := e.runCommand(cmd); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(stdout.String()), nil</span>
}

// RunWithInput executes a Spin command with input
func (e *executor) RunWithInput(ctx context.Context, input string, args ...string) error <span class="cov8" title="1">{
        cmd := e.command(ctx, args...)
        cmd.Stdin = strings.NewReader(input)
        cmd.Stdout = e.stdout
        cmd.Stderr = e.stderr
        return e.runCommand(cmd)
}</span>

// RunInteractive executes a Spin command interactively
func (e *executor) RunInteractive(ctx context.Context, args ...string) error <span class="cov8" title="1">{
        cmd := e.command(ctx, args...)
        cmd.Stdin = e.stdin
        cmd.Stdout = e.stdout
        cmd.Stderr = e.stderr
        return e.runCommand(cmd)
}</span>

// IsInstalled checks if Spin is installed
func (e *executor) IsInstalled() bool <span class="cov8" title="1">{
        cmd := exec.Command(e.binary, "--version")
        return cmd.Run() == nil
}</span>

// Version returns the Spin version
func (e *executor) Version() (string, error) <span class="cov8" title="1">{
        cmd := exec.Command(e.binary, "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "failed to get Spin version")
        }</span>

        // Parse version from output like "spin 2.0.0 (2.0.0 2024-01-01)"
        <span class="cov8" title="1">parts := strings.Fields(string(output))
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unexpected version output: %s", output)
        }</span>

        <span class="cov8" title="1">return parts[1], nil</span>
}

// command creates a new command
func (e *executor) command(ctx context.Context, args ...string) *exec.Cmd <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, e.binary, args...)

        if e.dir != "" </span><span class="cov0" title="0">{
                cmd.Dir = e.dir
        }</span>

        <span class="cov8" title="1">if len(e.env) &gt; 0 </span><span class="cov8" title="1">{
                cmd.Env = append(os.Environ(), e.env...)
        }</span>

        <span class="cov8" title="1">return cmd</span>
}

// runCommand runs a command with error handling
func (e *executor) runCommand(cmd *exec.Cmd) error <span class="cov8" title="1">{
        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                        return errors.Wrapf(err, "spin command failed with exit code %d", exitErr.ExitCode())
                }</span>
                <span class="cov8" title="1">return errors.Wrap(err, "failed to execute spin command")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Common Spin commands as convenience functions

// Up runs 'spin up'
func Up(ctx context.Context, options ...string) error <span class="cov8" title="1">{
        args := append([]string{"up"}, options...)
        return NewExecutor().Run(ctx, args...)
}</span>

// Build runs 'spin build'
func Build(ctx context.Context, options ...string) error <span class="cov8" title="1">{
        args := append([]string{"build"}, options...)
        return NewExecutor().Run(ctx, args...)
}</span>

// Deploy runs 'spin deploy'
func Deploy(ctx context.Context, options ...string) error <span class="cov8" title="1">{
        args := append([]string{"deploy"}, options...)
        return NewExecutor().Run(ctx, args...)
}</span>

// New runs 'spin new'
func New(ctx context.Context, template, name string, options ...string) error <span class="cov8" title="1">{
        args := append([]string{"new", template, name}, options...)
        return NewExecutor().Run(ctx, args...)
}</span>

// Registry runs 'spin registry' commands
func Registry(ctx context.Context, subcommand string, options ...string) error <span class="cov8" title="1">{
        args := append([]string{"registry", subcommand}, options...)
        return NewExecutor().Run(ctx, args...)
}</span>

// Watch runs 'spin watch'
func Watch(ctx context.Context, options ...string) error <span class="cov8" title="1">{
        args := append([]string{"watch"}, options...)
        return NewExecutor().Run(ctx, args...)
}</span>

// EnsureInstalled ensures Spin is installed
func EnsureInstalled() error <span class="cov8" title="1">{
        e := NewExecutor()
        if !e.IsInstalled() </span><span class="cov0" title="0">{
                return errors.New("spin is not installed. Please install it from https://developer.fermyon.com/spin/install")
        }</span>

        <span class="cov8" title="1">version, err := e.Version()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to check Spin version")
        }</span>

        // Check minimum version (2.0.0)
        <span class="cov8" title="1">if !isVersionSupported(version) </span><span class="cov0" title="0">{
                return fmt.Errorf("spin version %s is not supported, please upgrade to 2.0.0 or later", version)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// isVersionSupported checks if the version meets minimum requirements
func isVersionSupported(version string) bool <span class="cov8" title="1">{
        // Simple check - in production, use proper semver comparison
        return strings.HasPrefix(version, "2.") || strings.HasPrefix(version, "3.")
}</span>

// WaitForReady waits for Spin to be ready on a given address
func WaitForReady(ctx context.Context, address string, timeout time.Duration) error <span class="cov8" title="1">{
        deadline := time.Now().Add(timeout)

        for time.Now().Before(deadline) </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1">
                        // Try to connect (simplified - in production use proper HTTP client)
                        cmd := exec.CommandContext(ctx, "curl", "-s", "-o", "/dev/null", "-w", "%{http_code}", address)
                        if output, err := cmd.Output(); err == nil &amp;&amp; string(output) == "200" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">time.Sleep(100 * time.Millisecond)</span>
                }
        }

        <span class="cov8" title="1">return errors.New("timeout waiting for Spin to be ready")</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package types provides minimal types for FTL configuration
// These types are used for parsing user input (YAML/JSON) and API transport only.
// All validation and transformation happens through CUE patterns.
package types

// Manifest represents an FTL application manifest (ftl.yaml)
// This is the minimal structure needed to parse user input.
// Security note: No KV stores, databases, or AI models - these are platform-only.
type Manifest struct {
        Application Application       `yaml:"application" json:"application"`
        Components  []Component       `yaml:"components,omitempty" json:"components,omitempty"`
        Access      string            `yaml:"access,omitempty" json:"access,omitempty"`
        Auth        *Auth             `yaml:"auth,omitempty" json:"auth,omitempty"`
        Variables   map[string]string `yaml:"variables,omitempty" json:"variables,omitempty"`
}

// Application represents application metadata
type Application struct {
        Name        string `yaml:"name" json:"name"`
        Version     string `yaml:"version,omitempty" json:"version,omitempty"`
        Description string `yaml:"description,omitempty" json:"description,omitempty"`
}

// Component represents a user-defined component
// Note: No KV stores or other platform resources
type Component struct {
        ID        string            `yaml:"id" json:"id"`
        Source    interface{}       `yaml:"source" json:"source"` // string or map
        Build     *Build            `yaml:"build,omitempty" json:"build,omitempty"`
        Variables map[string]string `yaml:"variables,omitempty" json:"variables,omitempty"`
}

// Build represents build configuration
type Build struct {
        Command string   `yaml:"command" json:"command"`
        Workdir string   `yaml:"workdir,omitempty" json:"workdir,omitempty"`
        Watch   []string `yaml:"watch,omitempty" json:"watch,omitempty"`
}

// Auth represents authentication configuration
type Auth struct {
        JWTIssuer   string `yaml:"jwt_issuer,omitempty" json:"jwt_issuer,omitempty"`
        JWTAudience string `yaml:"jwt_audience,omitempty" json:"jwt_audience,omitempty"`
}

// RegistrySource represents a component from a registry
type RegistrySource struct {
        Registry string `json:"registry" yaml:"registry"`
        Package  string `json:"package" yaml:"package"`
        Version  string `json:"version" yaml:"version"`
}

// ParseComponentSource converts the generic source field to a specific type
func ParseComponentSource(source interface{}) (string, *RegistrySource) <span class="cov8" title="1">{
        // Try string first (local path)
        if str, ok := source.(string); ok </span><span class="cov8" title="1">{
                return str, nil
        }</span>

        // Try map (registry source)
        <span class="cov8" title="1">if m, ok := source.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                reg := &amp;RegistrySource{}
                if r, ok := m["registry"].(string); ok </span><span class="cov8" title="1">{
                        reg.Registry = r
                }</span>
                <span class="cov8" title="1">if p, ok := m["package"].(string); ok </span><span class="cov8" title="1">{
                        reg.Package = p
                }</span>
                <span class="cov8" title="1">if v, ok := m["version"].(string); ok </span><span class="cov8" title="1">{
                        reg.Version = v
                }</span>
                // Only return if all required fields are present
                <span class="cov8" title="1">if reg.Registry != "" &amp;&amp; reg.Package != "" &amp;&amp; reg.Version != "" </span><span class="cov8" title="1">{
                        return "", reg
                }</span>
                <span class="cov8" title="1">return "", nil</span>
        }

        // Try map[interface{}]interface{} (from YAML unmarshaling)
        <span class="cov8" title="1">if m, ok := source.(map[interface{}]interface{}); ok </span><span class="cov8" title="1">{
                reg := &amp;RegistrySource{}
                if r, ok := m["registry"].(string); ok </span><span class="cov8" title="1">{
                        reg.Registry = r
                }</span>
                <span class="cov8" title="1">if p, ok := m["package"].(string); ok </span><span class="cov8" title="1">{
                        reg.Package = p
                }</span>
                <span class="cov8" title="1">if v, ok := m["version"].(string); ok </span><span class="cov8" title="1">{
                        reg.Version = v
                }</span>
                // Only return if all required fields are present
                <span class="cov8" title="1">if reg.Registry != "" &amp;&amp; reg.Package != "" &amp;&amp; reg.Version != "" </span><span class="cov8" title="1">{
                        return "", reg
                }</span>
                <span class="cov0" title="0">return "", nil</span>
        }

        <span class="cov8" title="1">return "", nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
